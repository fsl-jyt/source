From ffa577b0ef399c0ab5472d70ed9c3ce49c4df1d3 Mon Sep 17 00:00:00 2001
From: Yutang Jiang <yutang.jiang@nxp.com>
Date: Wed, 15 Feb 2017 01:36:18 +0800
Subject: [PATCH] LS1012 PPFE driver align to sdk-ls1012a-v0.5 release

Signed-off-by: Yutang Jiang <yutang.jiang@nxp.com>
---
 drivers/net/phy/mdio_bus.c                         |    4 +
 drivers/staging/fsl_ppfe/config.h                  |    3 +-
 drivers/staging/fsl_ppfe/include/pfe/cbus.h        |  102 +-
 drivers/staging/fsl_ppfe/include/pfe/cbus/bmu.h    |   57 +-
 .../staging/fsl_ppfe/include/pfe/cbus/class_csr.h  |  391 ++---
 drivers/staging/fsl_ppfe/include/pfe/cbus/emac.h   |  320 ++--
 .../staging/fsl_ppfe/include/pfe/cbus/emac_mtip.h  |  199 +--
 drivers/staging/fsl_ppfe/include/pfe/cbus/gpi.h    |   99 +-
 drivers/staging/fsl_ppfe/include/pfe/cbus/gpt.h    |   11 +-
 drivers/staging/fsl_ppfe/include/pfe/cbus/hif.h    |   97 +-
 .../staging/fsl_ppfe/include/pfe/cbus/hif_nocpy.h  |   67 +-
 .../staging/fsl_ppfe/include/pfe/cbus/tmu_csr.h    |  231 +--
 .../staging/fsl_ppfe/include/pfe/cbus/util_csr.h   |   87 +-
 drivers/staging/fsl_ppfe/include/pfe/class.h       |  124 +-
 drivers/staging/fsl_ppfe/include/pfe/class/ccu.h   |   37 +-
 drivers/staging/fsl_ppfe/include/pfe/class/efet.h  |   43 +-
 .../staging/fsl_ppfe/include/pfe/class/mac_hash.h  |   65 +-
 drivers/staging/fsl_ppfe/include/pfe/class/perg.h  |   63 +-
 .../staging/fsl_ppfe/include/pfe/class/vlan_hash.h |   39 +-
 drivers/staging/fsl_ppfe/include/pfe/gpt.h         |   45 +-
 drivers/staging/fsl_ppfe/include/pfe/pe.h          |  671 +++++----
 drivers/staging/fsl_ppfe/include/pfe/pfe.h         |  267 ++--
 drivers/staging/fsl_ppfe/include/pfe/tmu.h         |   44 +-
 .../staging/fsl_ppfe/include/pfe/tmu/phy_queue.h   |   91 +-
 drivers/staging/fsl_ppfe/include/pfe/tmu/sched.h   |   95 +-
 drivers/staging/fsl_ppfe/include/pfe/tmu/shaper.h  |   51 +-
 drivers/staging/fsl_ppfe/include/pfe/uart.h        |   33 +-
 drivers/staging/fsl_ppfe/include/pfe/util.h        |   57 +-
 drivers/staging/fsl_ppfe/include/pfe/util/eape.h   |   55 +-
 drivers/staging/fsl_ppfe/include/pfe/util/efet.h   |  131 +-
 drivers/staging/fsl_ppfe/include/pfe/util/inq.h    |   33 +-
 drivers/staging/fsl_ppfe/pfe_ctrl.c                |  147 +-
 drivers/staging/fsl_ppfe/pfe_ctrl.h                |   99 +-
 drivers/staging/fsl_ppfe/pfe_ctrl_hal.c            |   81 +-
 drivers/staging/fsl_ppfe/pfe_ctrl_hal.h            |   75 +-
 drivers/staging/fsl_ppfe/pfe_debugfs.c             |   65 +-
 drivers/staging/fsl_ppfe/pfe_eth.c                 | 1548 ++++++++++++--------
 drivers/staging/fsl_ppfe/pfe_eth.h                 |  265 ++--
 drivers/staging/fsl_ppfe/pfe_firmware.c            |  178 ++-
 drivers/staging/fsl_ppfe/pfe_firmware.h            |   34 +-
 drivers/staging/fsl_ppfe/pfe_hal.c                 | 1319 +++++++++--------
 drivers/staging/fsl_ppfe/pfe_hif.c                 |  465 +++---
 drivers/staging/fsl_ppfe/pfe_hif.h                 |   96 +-
 drivers/staging/fsl_ppfe/pfe_hif_lib.c             |  362 +++--
 drivers/staging/fsl_ppfe/pfe_hif_lib.h             |  175 ++-
 drivers/staging/fsl_ppfe/pfe_hw.c                  |   83 +-
 drivers/staging/fsl_ppfe/pfe_hw.h                  |   34 +-
 drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c    |  141 +-
 drivers/staging/fsl_ppfe/pfe_mod.c                 |   73 +-
 drivers/staging/fsl_ppfe/pfe_mod.h                 |   62 +-
 drivers/staging/fsl_ppfe/pfe_perfmon.c             |   90 +-
 drivers/staging/fsl_ppfe/pfe_perfmon.h             |   38 +-
 drivers/staging/fsl_ppfe/pfe_platform.c            |  115 +-
 drivers/staging/fsl_ppfe/pfe_sysfs.c               |  440 +++---
 drivers/staging/fsl_ppfe/pfe_sysfs.h               |   38 +-
 drivers/staging/fsl_ppfe/platform.h                |   34 +-
 include/linux/phy.h                                |    2 +
 57 files changed, 5412 insertions(+), 4259 deletions(-)

diff --git a/drivers/net/phy/mdio_bus.c b/drivers/net/phy/mdio_bus.c
index d1ed227..6225d2c 100644
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -366,6 +366,10 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
 	int err;
 
 	phydev = get_phy_device(bus, addr, false);
+	/* FIXME with correct way of accessing Clasue 45 */
+	if (IS_ERR(phydev) || phydev == NULL)
+		phydev = get_phy_device(bus, addr, true);
+
 	if (IS_ERR(phydev) || phydev == NULL)
 		return phydev;
 
diff --git a/drivers/staging/fsl_ppfe/config.h b/drivers/staging/fsl_ppfe/config.h
index 834cc3e..eec8675 100644
--- a/drivers/staging/fsl_ppfe/config.h
+++ b/drivers/staging/fsl_ppfe/config.h
@@ -4,5 +4,6 @@
 #define CFG_ICC		(1 << 11)
 #define CFG_RTP		(1 << 14)
 #define CFG_ELLIPTIC		(1 << 15)
-#define CFG_ALL			(0 |  CFG_WIFI_OFFLOAD |  CFG_ICC |  CFG_RTP |  CFG_ELLIPTIC )
+#define CFG_ALL		(0 |  CFG_WIFI_OFFLOAD |  CFG_ICC |  CFG_RTP | \
+				CFG_ELLIPTIC)
 #endif /* _CONFIG_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus.h b/drivers/staging/fsl_ppfe/include/pfe/cbus.h
index d06a7ef..cfeb545 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus.h
@@ -1,64 +1,70 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA
+*
 */
 #ifndef _CBUS_H_
 #define _CBUS_H_
 
-#define EMAC1_BASE_ADDR		(CBUS_BASE_ADDR + 0x200000)
-#define EGPI1_BASE_ADDR		(CBUS_BASE_ADDR + 0x210000)
-#define EMAC2_BASE_ADDR		(CBUS_BASE_ADDR + 0x220000)
-#define EGPI2_BASE_ADDR		(CBUS_BASE_ADDR + 0x230000)
-#define BMU1_BASE_ADDR		(CBUS_BASE_ADDR + 0x240000)
-#define BMU2_BASE_ADDR		(CBUS_BASE_ADDR + 0x250000)
-#define ARB_BASE_ADDR		(CBUS_BASE_ADDR + 0x260000) /* FIXME not documented */
-#define DDR_CONFIG_BASE_ADDR	(CBUS_BASE_ADDR + 0x270000) /* FIXME not documented */
-#define HIF_BASE_ADDR		(CBUS_BASE_ADDR + 0x280000)
-#define HGPI_BASE_ADDR		(CBUS_BASE_ADDR + 0x290000)
-#define LMEM_BASE_ADDR		(CBUS_BASE_ADDR + 0x300000)
-#define LMEM_SIZE		0x10000
-#define LMEM_END		(LMEM_BASE_ADDR + LMEM_SIZE)
+#define EMAC1_BASE_ADDR	(CBUS_BASE_ADDR + 0x200000)
+#define EGPI1_BASE_ADDR	(CBUS_BASE_ADDR + 0x210000)
+#define EMAC2_BASE_ADDR	(CBUS_BASE_ADDR + 0x220000)
+#define EGPI2_BASE_ADDR	(CBUS_BASE_ADDR + 0x230000)
+#define BMU1_BASE_ADDR	(CBUS_BASE_ADDR + 0x240000)
+/* FIXME not documented */
+#define BMU2_BASE_ADDR	(CBUS_BASE_ADDR + 0x250000)
+/* FIXME not documented */
+#define ARB_BASE_ADDR	(CBUS_BASE_ADDR + 0x260000)
+#define DDR_CONFIG_BASE_ADDR	(CBUS_BASE_ADDR + 0x270000)
+#define HIF_BASE_ADDR	(CBUS_BASE_ADDR + 0x280000)
+#define HGPI_BASE_ADDR	(CBUS_BASE_ADDR + 0x290000)
+#define LMEM_BASE_ADDR	(CBUS_BASE_ADDR + 0x300000)
+#define LMEM_SIZE	0x10000
+#define LMEM_END	(LMEM_BASE_ADDR + LMEM_SIZE)
 #define TMU_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x310000)
 #define CLASS_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x320000)
 #if defined(CONFIG_PLATFORM_C2000)
-#define EMAC3_BASE_ADDR		(CBUS_BASE_ADDR + 0x330000)
-#define EGPI3_BASE_ADDR		(CBUS_BASE_ADDR + 0x340000)
+#define EMAC3_BASE_ADDR	(CBUS_BASE_ADDR + 0x330000)
+#define EGPI3_BASE_ADDR	(CBUS_BASE_ADDR + 0x340000)
 #endif
 #define HIF_NOCPY_BASE_ADDR	(CBUS_BASE_ADDR + 0x350000)
 #define UTIL_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x360000)
 #define CBUS_GPT_BASE_ADDR	(CBUS_BASE_ADDR + 0x370000)
 
-#define IS_LMEM(addr, len)	(((unsigned long)(addr) >= (unsigned long)LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= (unsigned long)LMEM_END))
+#define IS_LMEM(addr, len)	(((unsigned long)(addr) >= \
+	(unsigned long)LMEM_BASE_ADDR)\
+	&& (((unsigned long)(addr) + (len)) <= (unsigned long)LMEM_END))
 
-/** 
-* \defgroup XXX_MEM_ACCESS_ADDR PE memory access through CSR 
-* XXX_MEM_ACCESS_ADDR register bit definitions. 
-* @{
-*/
-#define PE_MEM_ACCESS_WRITE		(1<<31)			/**< Internal Memory Write. */
-#define PE_MEM_ACCESS_IMEM		(1<<15)
-#define PE_MEM_ACCESS_DMEM		(1<<16)
-#define PE_MEM_ACCESS_BYTE_ENABLE(offset,size)	(((((1 << (size)) - 1) << (4 - (offset) - (size))) & 0xf) << 24)	/**< Byte Enables of the Internal memory access. These are interpred in BE */
-// @}
+/**
+ * \defgroup XXX_MEM_ACCESS_ADDR PE memory access through CSR
+ * XXX_MEM_ACCESS_ADDR register bit definitions.
+ * @{
+ */
+#define PE_MEM_ACCESS_WRITE	(1<<31)	/**< Internal Memory Write. */
+#define PE_MEM_ACCESS_IMEM	(1<<15)
+#define PE_MEM_ACCESS_DMEM	(1<<16)
+/**< Byte Enables of the Internal memory access. These are interpred in BE */
+#define PE_MEM_ACCESS_BYTE_ENABLE(offset, size)	(((((1 << (size)) - 1) << \
+	(4 - (offset) - (size))) & 0xf) << 24)
 #if defined(CONFIG_PLATFORM_LS1012A)
 #include "cbus/emac_mtip.h"
 #else
 #include "cbus/emac.h"
-#endif //CONFIG_PLATFORM_LS1012A
+#endif /*CONFIG_PLATFORM_LS1012A */
 #include "cbus/gpi.h"
 #include "cbus/bmu.h"
 #include "cbus/hif.h"
@@ -70,19 +76,19 @@
 
 
 /* PFE cores states */
-#define CORE_DISABLE	0x00000000 
+#define CORE_DISABLE	0x00000000
 #define CORE_ENABLE	0x00000001
 #define CORE_SW_RESET	0x00000002
 
 /* LMEM defines */
-#define LMEM_HDR_SIZE		0x0010
+#define LMEM_HDR_SIZE	0x0010
 #define LMEM_BUF_SIZE_LN2	0x7
-#define LMEM_BUF_SIZE		(1 << LMEM_BUF_SIZE_LN2)
+#define LMEM_BUF_SIZE	(1 << LMEM_BUF_SIZE_LN2)
 
 /* DDR defines */
-#define DDR_HDR_SIZE		0x0100
+#define DDR_HDR_SIZE	0x0100
 #define DDR_BUF_SIZE_LN2	0xb
-#define DDR_BUF_SIZE		(1 << DDR_BUF_SIZE_LN2)
+#define DDR_BUF_SIZE	(1 << DDR_BUF_SIZE_LN2)
 
 
 #endif /* _CBUS_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/bmu.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/bmu.h
index 904eafb..e4cccb7 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/bmu.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/bmu.h
@@ -1,40 +1,41 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _BMU_H_
 #define _BMU_H_
 
-#define BMU_VERSION		0x000
-#define BMU_CTRL		0x004
+#define BMU_VERSION	0x000
+#define BMU_CTRL	0x004
 #define BMU_UCAST_CONFIG	0x008
 #define BMU_UCAST_BASE_ADDR	0x00c
-#define BMU_BUF_SIZE		0x010
-#define BMU_BUF_CNT		0x014
-#define BMU_THRES		0x018
-#define BMU_INT_SRC		0x020
-#define BMU_INT_ENABLE		0x024
-#define BMU_ALLOC_CTRL		0x030
-#define BMU_FREE_CTRL		0x034
+#define BMU_BUF_SIZE	0x010
+#define BMU_BUF_CNT	0x014
+#define BMU_THRES	0x018
+#define BMU_INT_SRC	0x020
+#define BMU_INT_ENABLE	0x024
+#define BMU_ALLOC_CTRL	0x030
+#define BMU_FREE_CTRL	0x034
 #define BMU_FREE_ERR_ADDR	0x038
 #define BMU_CURR_BUF_CNT	0x03c
-#define BMU_MCAST_CNT		0x040
+#define BMU_MCAST_CNT	0x040
 #define BMU_MCAST_ALLOC_CTRL	0x044
-#define BMU_REM_BUF_CNT		0x048
+#define BMU_REM_BUF_CNT	0x048
 #define BMU_LOW_WATERMARK	0x050
 #define BMU_HIGH_WATERMARK	0x054
 #define BMU_INT_MEM_ACCESS	0x100
@@ -49,7 +50,7 @@ typedef struct {
 #define BMU1_BUF_SIZE	LMEM_BUF_SIZE_LN2
 #define BMU2_BUF_SIZE	DDR_BUF_SIZE_LN2
 
-#define BMU2_MCAST_ALLOC_CTRL	BMU2_BASE_ADDR + BMU_MCAST_ALLOC_CTRL
+#define BMU2_MCAST_ALLOC_CTRL	(BMU2_BASE_ADDR + BMU_MCAST_ALLOC_CTRL)
 
 #endif /* _BMU_H_ */
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/class_csr.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/class_csr.h
index 2fdbb9a..f2cc37b 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/class_csr.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/class_csr.h
@@ -1,230 +1,273 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _CLASS_CSR_H_
 #define _CLASS_CSR_H_
 
 /** @file class_csr.h.
- * class_csr - block containing all the classifier control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+ * class_csr - block containing all the classifier control and status register.
+ * Mapped on CBUS and accessible from all PE's and ARM.
  */
 
 
-#define CLASS_VERSION			(CLASS_CSR_BASE_ADDR + 0x000)
-#define CLASS_TX_CTRL			(CLASS_CSR_BASE_ADDR + 0x004)
-#define CLASS_INQ_PKTPTR		(CLASS_CSR_BASE_ADDR + 0x010)
-#define CLASS_HDR_SIZE			(CLASS_CSR_BASE_ADDR + 0x014)	/**< (ddr_hdr_size[24:16], lmem_hdr_size[5:0]) */
-#define CLASS_HDR_SIZE_LMEM(off)	((off) & 0x3f)			/**< LMEM header size for the Classifier block.\ Data in the LMEM is written from this offset. */
-#define CLASS_HDR_SIZE_DDR(off)		(((off) & 0x1ff) << 16)		/**< DDR header size for the Classifier block.\ Data in the DDR is written from this offset. */
+#define CLASS_VERSION	(CLASS_CSR_BASE_ADDR + 0x000)
+#define CLASS_TX_CTRL	(CLASS_CSR_BASE_ADDR + 0x004)
+#define CLASS_INQ_PKTPTR	(CLASS_CSR_BASE_ADDR + 0x010)
+/**< (ddr_hdr_size[24:16], lmem_hdr_size[5:0]) */
+#define CLASS_HDR_SIZE	(CLASS_CSR_BASE_ADDR + 0x014)
+/**< LMEM header size for the Classifier block.\ Data in the LMEM
+* is written from this offset.
+*/
+#define CLASS_HDR_SIZE_LMEM(off)	((off) & 0x3f)
+/**< DDR header size for the Classifier block.\ Data in the DDR
+* is written from this offset.
+*/
+#define CLASS_HDR_SIZE_DDR(off)	(((off) & 0x1ff) << 16)
 
-#define CLASS_PE0_QB_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x020)	/**< DMEM address of first [15:0] and second [31:16] buffers on QB side. */
-#define CLASS_PE0_QB_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x024)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on QB side. */
+#define CLASS_PE0_QB_DM_ADDR0	(CLASS_CSR_BASE_ADDR + 0x020)
+/**< DMEM address of first [15:0] and second [31:16] buffers on QB side. */
+#define CLASS_PE0_QB_DM_ADDR1	(CLASS_CSR_BASE_ADDR + 0x024)
+/**< DMEM address of third [15:0] and fourth [31:16] buffers on QB side. */
 
-#define CLASS_PE0_RO_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x060)	/**< DMEM address of first [15:0] and second [31:16] buffers on RO side. */
-#define CLASS_PE0_RO_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x064)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on RO side. */
+#define CLASS_PE0_RO_DM_ADDR0	(CLASS_CSR_BASE_ADDR + 0x060)
+/**< DMEM address of first [15:0] and second [31:16] buffers on RO side. */
+#define CLASS_PE0_RO_DM_ADDR1	(CLASS_CSR_BASE_ADDR + 0x064)
+/**< DMEM address of third [15:0] and fourth [31:16] buffers on RO side. */
 
-/** @name Class PE memory access. Allows external PE's and HOST to read/write PMEM/DMEM memory ranges for each classifier PE.
+/** @name Class PE memory access. Allows external PE's and HOST to
+ * read/write PMEM/DMEM memory ranges for each classifier PE.
  */
-//@{
-#define CLASS_MEM_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x100)	/**< {sr_pe_mem_cmd[31], csr_pe_mem_wren[27:24], csr_pe_mem_addr[23:0]}, See \ref XXX_MEM_ACCESS_ADDR for details. */ 
-#define CLASS_MEM_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x104)	/**< Internal Memory Access Write Data [31:0] */
-#define CLASS_MEM_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x108)	/**< Internal Memory Access Read Data [31:0] */
-//@}
-#define CLASS_TM_INQ_ADDR		(CLASS_CSR_BASE_ADDR + 0x114)
-#define CLASS_PE_STATUS			(CLASS_CSR_BASE_ADDR + 0x118)
-
-#define CLASS_PHY1_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x11c)
-#define CLASS_PHY1_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x120)
-#define CLASS_PHY1_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x124)
+/**< {sr_pe_mem_cmd[31], csr_pe_mem_wren[27:24], csr_pe_mem_addr[23:0]},
+* See \ref XXX_MEM_ACCESS_ADDR for details.
+*/
+#define CLASS_MEM_ACCESS_ADDR	(CLASS_CSR_BASE_ADDR + 0x100)
+
+/**< Internal Memory Access Write Data [31:0] */
+#define CLASS_MEM_ACCESS_WDATA	(CLASS_CSR_BASE_ADDR + 0x104)
+/**< Internal Memory Access Read Data [31:0] */
+#define CLASS_MEM_ACCESS_RDATA	(CLASS_CSR_BASE_ADDR + 0x108)
+#define CLASS_TM_INQ_ADDR	(CLASS_CSR_BASE_ADDR + 0x114)
+#define CLASS_PE_STATUS	(CLASS_CSR_BASE_ADDR + 0x118)
+
+#define CLASS_PHY1_RX_PKTS	(CLASS_CSR_BASE_ADDR + 0x11c)
+#define CLASS_PHY1_TX_PKTS	(CLASS_CSR_BASE_ADDR + 0x120)
+#define CLASS_PHY1_LP_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x124)
 #define CLASS_PHY1_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x128)
 #define CLASS_PHY1_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x12c)
-#define CLASS_PHY1_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x130)
-#define CLASS_PHY1_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x134)
-#define CLASS_PHY1_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x138)
+#define CLASS_PHY1_L3_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x130)
+#define CLASS_PHY1_V4_PKTS	(CLASS_CSR_BASE_ADDR + 0x134)
+#define CLASS_PHY1_V6_PKTS	(CLASS_CSR_BASE_ADDR + 0x138)
 #define CLASS_PHY1_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x13c)
-#define CLASS_PHY1_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x140)
-#define CLASS_PHY2_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x144)
-#define CLASS_PHY2_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x148)
-#define CLASS_PHY2_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x14c)
+#define CLASS_PHY1_TTL_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x140)
+#define CLASS_PHY2_RX_PKTS	(CLASS_CSR_BASE_ADDR + 0x144)
+#define CLASS_PHY2_TX_PKTS	(CLASS_CSR_BASE_ADDR + 0x148)
+#define CLASS_PHY2_LP_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x14c)
 #define CLASS_PHY2_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x150)
 #define CLASS_PHY2_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x154)
-#define CLASS_PHY2_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x158)
-#define CLASS_PHY2_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x15c)
-#define CLASS_PHY2_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x160)
+#define CLASS_PHY2_L3_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x158)
+#define CLASS_PHY2_V4_PKTS	(CLASS_CSR_BASE_ADDR + 0x15c)
+#define CLASS_PHY2_V6_PKTS	(CLASS_CSR_BASE_ADDR + 0x160)
 #define CLASS_PHY2_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x164)
-#define CLASS_PHY2_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x168)
-#define CLASS_PHY3_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x16c)
-#define CLASS_PHY3_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x170)
-#define CLASS_PHY3_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x174)
+#define CLASS_PHY2_TTL_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x168)
+#define CLASS_PHY3_RX_PKTS	(CLASS_CSR_BASE_ADDR + 0x16c)
+#define CLASS_PHY3_TX_PKTS	(CLASS_CSR_BASE_ADDR + 0x170)
+#define CLASS_PHY3_LP_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x174)
 #define CLASS_PHY3_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x178)
 #define CLASS_PHY3_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x17c)
-#define CLASS_PHY3_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x180)
-#define CLASS_PHY3_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x184)
-#define CLASS_PHY3_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x188)
+#define CLASS_PHY3_L3_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x180)
+#define CLASS_PHY3_V4_PKTS	(CLASS_CSR_BASE_ADDR + 0x184)
+#define CLASS_PHY3_V6_PKTS	(CLASS_CSR_BASE_ADDR + 0x188)
 #define CLASS_PHY3_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x18c)
-#define CLASS_PHY3_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x190)
-#define CLASS_PHY1_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x194)
-#define CLASS_PHY1_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x198)
-#define CLASS_PHY1_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x19c)
-#define CLASS_PHY1_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a0)
-#define CLASS_PHY2_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a4)
-#define CLASS_PHY2_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a8)
-#define CLASS_PHY2_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ac)
-#define CLASS_PHY2_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b0)
-#define CLASS_PHY3_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b4)
-#define CLASS_PHY3_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b8)
-#define CLASS_PHY3_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1bc)
-#define CLASS_PHY3_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c0)
-#define CLASS_PHY4_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c4)
-#define CLASS_PHY4_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c8)
-#define CLASS_PHY4_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1cc)
-#define CLASS_PHY4_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d0)
-#define CLASS_PHY4_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d4)
-#define CLASS_PHY4_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d8)
-#define CLASS_PHY4_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1dc)
+#define CLASS_PHY3_TTL_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x190)
+#define CLASS_PHY1_ICMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x194)
+#define CLASS_PHY1_IGMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x198)
+#define CLASS_PHY1_TCP_PKTS	(CLASS_CSR_BASE_ADDR + 0x19c)
+#define CLASS_PHY1_UDP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1a0)
+#define CLASS_PHY2_ICMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1a4)
+#define CLASS_PHY2_IGMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1a8)
+#define CLASS_PHY2_TCP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1ac)
+#define CLASS_PHY2_UDP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1b0)
+#define CLASS_PHY3_ICMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1b4)
+#define CLASS_PHY3_IGMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1b8)
+#define CLASS_PHY3_TCP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1bc)
+#define CLASS_PHY3_UDP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1c0)
+#define CLASS_PHY4_ICMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1c4)
+#define CLASS_PHY4_IGMP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1c8)
+#define CLASS_PHY4_TCP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1cc)
+#define CLASS_PHY4_UDP_PKTS	(CLASS_CSR_BASE_ADDR + 0x1d0)
+#define CLASS_PHY4_RX_PKTS	(CLASS_CSR_BASE_ADDR + 0x1d4)
+#define CLASS_PHY4_TX_PKTS	(CLASS_CSR_BASE_ADDR + 0x1d8)
+#define CLASS_PHY4_LP_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x1dc)
 #define CLASS_PHY4_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e0)
 #define CLASS_PHY4_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e4)
-#define CLASS_PHY4_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1e8)
-#define CLASS_PHY4_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ec)
-#define CLASS_PHY4_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f0)
+#define CLASS_PHY4_L3_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e8)
+#define CLASS_PHY4_V4_PKTS	(CLASS_CSR_BASE_ADDR + 0x1ec)
+#define CLASS_PHY4_V6_PKTS	(CLASS_CSR_BASE_ADDR + 0x1f0)
 #define CLASS_PHY4_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x1f4)
-#define CLASS_PHY4_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f8)
+#define CLASS_PHY4_TTL_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x1f8)
 
-#define CLASS_PE_SYS_CLK_RATIO		(CLASS_CSR_BASE_ADDR + 0x200)
-#define CLASS_AFULL_THRES		(CLASS_CSR_BASE_ADDR + 0x204)
-#define CLASS_GAP_BETWEEN_READS		(CLASS_CSR_BASE_ADDR + 0x208)
-#define CLASS_MAX_BUF_CNT		(CLASS_CSR_BASE_ADDR + 0x20c)
-#define CLASS_TSQ_FIFO_THRES		(CLASS_CSR_BASE_ADDR + 0x210)
-#define CLASS_TSQ_MAX_CNT		(CLASS_CSR_BASE_ADDR + 0x214)
-#define CLASS_IRAM_DATA_0		(CLASS_CSR_BASE_ADDR + 0x218)
-#define CLASS_IRAM_DATA_1		(CLASS_CSR_BASE_ADDR + 0x21c)
-#define CLASS_IRAM_DATA_2		(CLASS_CSR_BASE_ADDR + 0x220)
-#define CLASS_IRAM_DATA_3		(CLASS_CSR_BASE_ADDR + 0x224)
+#define CLASS_PE_SYS_CLK_RATIO	(CLASS_CSR_BASE_ADDR + 0x200)
+#define CLASS_AFULL_THRES	(CLASS_CSR_BASE_ADDR + 0x204)
+#define CLASS_GAP_BETWEEN_READS	(CLASS_CSR_BASE_ADDR + 0x208)
+#define CLASS_MAX_BUF_CNT	(CLASS_CSR_BASE_ADDR + 0x20c)
+#define CLASS_TSQ_FIFO_THRES	(CLASS_CSR_BASE_ADDR + 0x210)
+#define CLASS_TSQ_MAX_CNT	(CLASS_CSR_BASE_ADDR + 0x214)
+#define CLASS_IRAM_DATA_0	(CLASS_CSR_BASE_ADDR + 0x218)
+#define CLASS_IRAM_DATA_1	(CLASS_CSR_BASE_ADDR + 0x21c)
+#define CLASS_IRAM_DATA_2	(CLASS_CSR_BASE_ADDR + 0x220)
+#define CLASS_IRAM_DATA_3	(CLASS_CSR_BASE_ADDR + 0x224)
 
-#define CLASS_BUS_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x228)
+#define CLASS_BUS_ACCESS_ADDR	(CLASS_CSR_BASE_ADDR + 0x228)
 
-#define CLASS_BUS_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x22c)
-#define CLASS_BUS_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x230)
+#define CLASS_BUS_ACCESS_WDATA	(CLASS_CSR_BASE_ADDR + 0x22c)
+#define CLASS_BUS_ACCESS_RDATA	(CLASS_CSR_BASE_ADDR + 0x230)
+
+/**< (route_entry_size[9:0], route_hash_size[23:16]
+(this is actually ln2(size))) */
+#define CLASS_ROUTE_HASH_ENTRY_SIZE	(CLASS_CSR_BASE_ADDR + 0x234)
 
-#define CLASS_ROUTE_HASH_ENTRY_SIZE	(CLASS_CSR_BASE_ADDR + 0x234)		/**< (route_entry_size[9:0], route_hash_size[23:16] (this is actually ln2(size))) */
 #define CLASS_ROUTE_ENTRY_SIZE(size)	 ((size) & 0x1ff)
 #define CLASS_ROUTE_HASH_SIZE(hash_bits) (((hash_bits) & 0xff) << 16)
 
-#define CLASS_ROUTE_TABLE_BASE		(CLASS_CSR_BASE_ADDR + 0x238)
+#define CLASS_ROUTE_TABLE_BASE	(CLASS_CSR_BASE_ADDR + 0x238)
 
-#define CLASS_ROUTE_MULTI		(CLASS_CSR_BASE_ADDR + 0x23c)
-#define CLASS_SMEM_OFFSET		(CLASS_CSR_BASE_ADDR + 0x240)
-#define CLASS_LMEM_BUF_SIZE		(CLASS_CSR_BASE_ADDR + 0x244)
-#define CLASS_VLAN_ID			(CLASS_CSR_BASE_ADDR + 0x248)
-#define CLASS_BMU1_BUF_FREE		(CLASS_CSR_BASE_ADDR + 0x24c)
-#define CLASS_USE_TMU_INQ		(CLASS_CSR_BASE_ADDR + 0x250)
-#define CLASS_VLAN_ID1			(CLASS_CSR_BASE_ADDR + 0x254)
+#define CLASS_ROUTE_MULTI	(CLASS_CSR_BASE_ADDR + 0x23c)
+#define CLASS_SMEM_OFFSET	(CLASS_CSR_BASE_ADDR + 0x240)
+#define CLASS_LMEM_BUF_SIZE	(CLASS_CSR_BASE_ADDR + 0x244)
+#define CLASS_VLAN_ID	(CLASS_CSR_BASE_ADDR + 0x248)
+#define CLASS_BMU1_BUF_FREE	(CLASS_CSR_BASE_ADDR + 0x24c)
+#define CLASS_USE_TMU_INQ	(CLASS_CSR_BASE_ADDR + 0x250)
+#define CLASS_VLAN_ID1	(CLASS_CSR_BASE_ADDR + 0x254)
 
-#define CLASS_BUS_ACCESS_BASE		(CLASS_CSR_BASE_ADDR + 0x258)
-#define CLASS_BUS_ACCESS_BASE_MASK	(0xFF000000)	//bit 31:24 of PE peripheral address are stored in CLASS_BUS_ACCESS_BASE
+#define CLASS_BUS_ACCESS_BASE	(CLASS_CSR_BASE_ADDR + 0x258)
+#define CLASS_BUS_ACCESS_BASE_MASK	(0xFF000000)
+/*bit 31:24 of PE peripheral address are stored in CLASS_BUS_ACCESS_BASE */
 
-#define CLASS_HIF_PARSE			(CLASS_CSR_BASE_ADDR + 0x25c)
+#define CLASS_HIF_PARSE	(CLASS_CSR_BASE_ADDR + 0x25c)
 
-#define CLASS_HOST_PE0_GP		(CLASS_CSR_BASE_ADDR + 0x260)
-#define CLASS_PE0_GP			(CLASS_CSR_BASE_ADDR + 0x264)
-#define CLASS_HOST_PE1_GP		(CLASS_CSR_BASE_ADDR + 0x268)
-#define CLASS_PE1_GP			(CLASS_CSR_BASE_ADDR + 0x26c)
-#define CLASS_HOST_PE2_GP		(CLASS_CSR_BASE_ADDR + 0x270)
-#define CLASS_PE2_GP			(CLASS_CSR_BASE_ADDR + 0x274)
-#define CLASS_HOST_PE3_GP		(CLASS_CSR_BASE_ADDR + 0x278)
-#define CLASS_PE3_GP			(CLASS_CSR_BASE_ADDR + 0x27c)
-#define CLASS_HOST_PE4_GP		(CLASS_CSR_BASE_ADDR + 0x280)
-#define CLASS_PE4_GP			(CLASS_CSR_BASE_ADDR + 0x284)
-#define CLASS_HOST_PE5_GP		(CLASS_CSR_BASE_ADDR + 0x288)
-#define CLASS_PE5_GP			(CLASS_CSR_BASE_ADDR + 0x28c)
+#define CLASS_HOST_PE0_GP	(CLASS_CSR_BASE_ADDR + 0x260)
+#define CLASS_PE0_GP	(CLASS_CSR_BASE_ADDR + 0x264)
+#define CLASS_HOST_PE1_GP	(CLASS_CSR_BASE_ADDR + 0x268)
+#define CLASS_PE1_GP	(CLASS_CSR_BASE_ADDR + 0x26c)
+#define CLASS_HOST_PE2_GP	(CLASS_CSR_BASE_ADDR + 0x270)
+#define CLASS_PE2_GP	(CLASS_CSR_BASE_ADDR + 0x274)
+#define CLASS_HOST_PE3_GP	(CLASS_CSR_BASE_ADDR + 0x278)
+#define CLASS_PE3_GP	(CLASS_CSR_BASE_ADDR + 0x27c)
+#define CLASS_HOST_PE4_GP	(CLASS_CSR_BASE_ADDR + 0x280)
+#define CLASS_PE4_GP	(CLASS_CSR_BASE_ADDR + 0x284)
+#define CLASS_HOST_PE5_GP	(CLASS_CSR_BASE_ADDR + 0x288)
+#define CLASS_PE5_GP	(CLASS_CSR_BASE_ADDR + 0x28c)
 
-#define CLASS_PE_INT_SRC		(CLASS_CSR_BASE_ADDR + 0x290)
-#define CLASS_PE_INT_ENABLE		(CLASS_CSR_BASE_ADDR + 0x294)
+#define CLASS_PE_INT_SRC	(CLASS_CSR_BASE_ADDR + 0x290)
+#define CLASS_PE_INT_ENABLE	(CLASS_CSR_BASE_ADDR + 0x294)
 
-#define CLASS_TPID0_TPID1		(CLASS_CSR_BASE_ADDR + 0x298)
-#define CLASS_TPID2			(CLASS_CSR_BASE_ADDR + 0x29c)
+#define CLASS_TPID0_TPID1	(CLASS_CSR_BASE_ADDR + 0x298)
+#define CLASS_TPID2	(CLASS_CSR_BASE_ADDR + 0x29c)
 
-#define CLASS_L4_CHKSUM_ADDR		(CLASS_CSR_BASE_ADDR + 0x2a0)
+#define CLASS_L4_CHKSUM_ADDR	(CLASS_CSR_BASE_ADDR + 0x2a0)
 
-#define CLASS_PE0_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a4)
-#define CLASS_PE1_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a8)
-#define CLASS_PE2_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2ac)
-#define CLASS_PE3_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b0)
-#define CLASS_PE4_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b4)
-#define CLASS_PE5_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b8)
+#define CLASS_PE0_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2a4)
+#define CLASS_PE1_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2a8)
+#define CLASS_PE2_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2ac)
+#define CLASS_PE3_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2b0)
+#define CLASS_PE4_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2b4)
+#define CLASS_PE5_DEBUG	(CLASS_CSR_BASE_ADDR + 0x2b8)
 
-#define CLASS_STATE			(CLASS_CSR_BASE_ADDR + 0x2bc)
+#define CLASS_STATE	(CLASS_CSR_BASE_ADDR + 0x2bc)
 
 /* CLASS defines */
-#define CLASS_PBUF_SIZE			0x100	/* Fixed by hardware */
+#define CLASS_PBUF_SIZE	0x100	/* Fixed by hardware */
 #define CLASS_PBUF_HEADER_OFFSET	0x80	/* Can be configured */
 
-#define CLASS_PBUF0_BASE_ADDR		0x000						/* Can be configured */
-#define CLASS_PBUF1_BASE_ADDR		(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
-#define CLASS_PBUF2_BASE_ADDR		(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
-#define CLASS_PBUF3_BASE_ADDR		(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
-
-#define CLASS_PBUF0_HEADER_BASE_ADDR	(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
-#define CLASS_PBUF1_HEADER_BASE_ADDR	(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
-#define CLASS_PBUF2_HEADER_BASE_ADDR	(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
-#define CLASS_PBUF3_HEADER_BASE_ADDR	(CLASS_PBUF3_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
-
-#define CLASS_PE0_RO_DM_ADDR0_VAL	((CLASS_PBUF1_BASE_ADDR << 16) | CLASS_PBUF0_BASE_ADDR)
-#define CLASS_PE0_RO_DM_ADDR1_VAL	((CLASS_PBUF3_BASE_ADDR << 16) | CLASS_PBUF2_BASE_ADDR)
-
-#define CLASS_PE0_QB_DM_ADDR0_VAL	((CLASS_PBUF1_HEADER_BASE_ADDR << 16) | CLASS_PBUF0_HEADER_BASE_ADDR)
-#define CLASS_PE0_QB_DM_ADDR1_VAL	((CLASS_PBUF3_HEADER_BASE_ADDR << 16) | CLASS_PBUF2_HEADER_BASE_ADDR)
-
-#define CLASS_ROUTE_SIZE		128
-#define CLASS_MAX_ROUTE_SIZE		256
-#define CLASS_ROUTE_HASH_BITS		20
-#define CLASS_ROUTE_HASH_MASK		((1 << CLASS_ROUTE_HASH_BITS) - 1)
-
-#define	CLASS_ROUTE0_BASE_ADDR	0x400						/* Can be configured */
-#define CLASS_ROUTE1_BASE_ADDR	(CLASS_ROUTE0_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
-#define CLASS_ROUTE2_BASE_ADDR	(CLASS_ROUTE1_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
-#define CLASS_ROUTE3_BASE_ADDR	(CLASS_ROUTE2_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
-
-#define CLASS_SA_SIZE		128
+/* Can be configured */
+#define CLASS_PBUF0_BASE_ADDR	0x000
+/* Can be configured */
+#define CLASS_PBUF1_BASE_ADDR	(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_SIZE)
+/* Can be configured */
+#define CLASS_PBUF2_BASE_ADDR	(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_SIZE)
+/* Can be configured */
+#define CLASS_PBUF3_BASE_ADDR	(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_SIZE)
+
+#define CLASS_PBUF0_HEADER_BASE_ADDR	(CLASS_PBUF0_BASE_ADDR + \
+						CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF1_HEADER_BASE_ADDR	(CLASS_PBUF1_BASE_ADDR + \
+						CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF2_HEADER_BASE_ADDR	(CLASS_PBUF2_BASE_ADDR + \
+						CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF3_HEADER_BASE_ADDR	(CLASS_PBUF3_BASE_ADDR + \
+						CLASS_PBUF_HEADER_OFFSET)
+
+#define CLASS_PE0_RO_DM_ADDR0_VAL	((CLASS_PBUF1_BASE_ADDR << 16) | \
+						CLASS_PBUF0_BASE_ADDR)
+#define CLASS_PE0_RO_DM_ADDR1_VAL	((CLASS_PBUF3_BASE_ADDR << 16) | \
+						CLASS_PBUF2_BASE_ADDR)
+
+#define CLASS_PE0_QB_DM_ADDR0_VAL	((CLASS_PBUF1_HEADER_BASE_ADDR << 16) |\
+						CLASS_PBUF0_HEADER_BASE_ADDR)
+#define CLASS_PE0_QB_DM_ADDR1_VAL	((CLASS_PBUF3_HEADER_BASE_ADDR << 16) |\
+						CLASS_PBUF2_HEADER_BASE_ADDR)
+
+#define CLASS_ROUTE_SIZE	128
+#define CLASS_MAX_ROUTE_SIZE	256
+#define CLASS_ROUTE_HASH_BITS	20
+#define CLASS_ROUTE_HASH_MASK	((1 << CLASS_ROUTE_HASH_BITS) - 1)
+
+/* Can be configured */
+#define	CLASS_ROUTE0_BASE_ADDR	0x400
+/* Can be configured */
+#define CLASS_ROUTE1_BASE_ADDR	(CLASS_ROUTE0_BASE_ADDR + CLASS_ROUTE_SIZE)
+/* Can be configured */
+#define CLASS_ROUTE2_BASE_ADDR	(CLASS_ROUTE1_BASE_ADDR + CLASS_ROUTE_SIZE)
+/* Can be configured */
+#define CLASS_ROUTE3_BASE_ADDR	(CLASS_ROUTE2_BASE_ADDR + CLASS_ROUTE_SIZE)
+
+#define CLASS_SA_SIZE	128
 #define CLASS_IPSEC_SA0_BASE_ADDR	0x600
-#define CLASS_IPSEC_SA1_BASE_ADDR	(CLASS_IPSEC_SA0_BASE_ADDR + CLASS_SA_SIZE)	/* not used */
-#define CLASS_IPSEC_SA2_BASE_ADDR	(CLASS_IPSEC_SA1_BASE_ADDR + CLASS_SA_SIZE)	/* not used */
-#define CLASS_IPSEC_SA3_BASE_ADDR	(CLASS_IPSEC_SA2_BASE_ADDR + CLASS_SA_SIZE)	/* not used */
+/* not used */
+#define CLASS_IPSEC_SA1_BASE_ADDR  (CLASS_IPSEC_SA0_BASE_ADDR + CLASS_SA_SIZE)
+/* not used */
+#define CLASS_IPSEC_SA2_BASE_ADDR  (CLASS_IPSEC_SA1_BASE_ADDR + CLASS_SA_SIZE)
+/* not used */
+#define CLASS_IPSEC_SA3_BASE_ADDR  (CLASS_IPSEC_SA2_BASE_ADDR + CLASS_SA_SIZE)
 
 /* generic purpose free dmem buffer, last portion of 2K dmem pbuf */
-#define CLASS_GP_DMEM_BUF_SIZE	(2048 - (CLASS_PBUF_SIZE*4) - (CLASS_ROUTE_SIZE*4) - (CLASS_SA_SIZE))
-#define CLASS_GP_DMEM_BUF		((void *)(CLASS_IPSEC_SA0_BASE_ADDR + CLASS_SA_SIZE))
+#define CLASS_GP_DMEM_BUF_SIZE	(2048 - (CLASS_PBUF_SIZE*4) - \
+				(CLASS_ROUTE_SIZE*4) - (CLASS_SA_SIZE))
+#define CLASS_GP_DMEM_BUF	((void *)(CLASS_IPSEC_SA0_BASE_ADDR + \
+					CLASS_SA_SIZE))
 
 
-#define TWO_LEVEL_ROUTE		(1 << 0)
-#define PHYNO_IN_HASH		(1 << 1)
-#define HW_ROUTE_FETCH		(1 << 3)
-#define HW_BRIDGE_FETCH		(1 << 5)
-#define IP_ALIGNED		(1 << 6)
+#define TWO_LEVEL_ROUTE	(1 << 0)
+#define PHYNO_IN_HASH	(1 << 1)
+#define HW_ROUTE_FETCH	(1 << 3)
+#define HW_BRIDGE_FETCH	(1 << 5)
+#define IP_ALIGNED	(1 << 6)
 #define ARC_HIT_CHECK_EN	(1 << 7)
-#define CLASS_TOE		(1 << 11)
-#define HASH_NORMAL		(0 << 12)
-#define HASH_CRC_PORT		(1 << 12)
-#define HASH_CRC_IP		(2 << 12)
+#define CLASS_TOE	(1 << 11)
+#define HASH_NORMAL	(0 << 12)
+#define HASH_CRC_PORT	(1 << 12)
+#define HASH_CRC_IP	(2 << 12)
 #define HASH_CRC_PORT_IP	(3 << 12)
-#define QB2BUS_LE		(1 << 15)
+#define QB2BUS_LE	(1 << 15)
 
-#define TCP_CHKSUM_DROP		(1 << 0)
-#define UDP_CHKSUM_DROP		(1 << 1)
+#define TCP_CHKSUM_DROP	(1 << 0)
+#define UDP_CHKSUM_DROP	(1 << 1)
 #define IPV4_CHKSUM_DROP	(1 << 9)
 
 /*CLASS_HIF_PARSE bits*/
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/emac.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/emac.h
index 6f60cdf..a1173c5 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/emac.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/emac.h
@@ -1,121 +1,123 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _EMAC_H_
 #define _EMAC_H_
 
-#define EMAC_NETWORK_CONTROL		0x000
-#define EMAC_NETWORK_CONFIG		0x004
-#define EMAC_NETWORK_STATUS		0x008
-#define EMAC_DMA_CONFIG			0x010
-
-#define EMAC_PHY_MANAGEMENT		0x034
-
-#define EMAC_HASH_BOT			0x080
-#define EMAC_HASH_TOP			0x084
-
-#define EMAC_SPEC1_ADD_BOT		0x088
-#define EMAC_SPEC1_ADD_TOP		0x08c
-#define EMAC_SPEC2_ADD_BOT		0x090
-#define EMAC_SPEC2_ADD_TOP		0x094
-#define EMAC_SPEC3_ADD_BOT		0x098
-#define EMAC_SPEC3_ADD_TOP		0x09c
-#define EMAC_SPEC4_ADD_BOT		0x0a0
-#define EMAC_SPEC4_ADD_TOP		0x0a4
-#define EMAC_WOL				0x0b8
-
-#define	EMAC_STACKED_VLAN_REG		0x0c0
-
-#define EMAC_SPEC1_ADD_MASK_BOT		0x0c8
-#define EMAC_SPEC1_ADD_MASK_TOP		0x0cc
-
-#define EMAC_RMON_BASE_OFST		0x100
-
-#define EMAC_SPEC5_ADD_BOT		0x300
-#define EMAC_SPEC5_ADD_TOP		0x304
-#define EMAC_SPEC6_ADD_BOT		0x308
-#define EMAC_SPEC6_ADD_TOP		0x30c
-#define EMAC_SPEC7_ADD_BOT		0x310
-#define EMAC_SPEC7_ADD_TOP		0x314
-#define EMAC_SPEC8_ADD_BOT		0x318
-#define EMAC_SPEC8_ADD_TOP		0x31c
-#define EMAC_SPEC9_ADD_BOT		0x320
-#define EMAC_SPEC9_ADD_TOP		0x324
-#define EMAC_SPEC10_ADD_BOT		0x328
-#define EMAC_SPEC10_ADD_TOP		0x32c
-#define EMAC_SPEC11_ADD_BOT		0x330
-#define EMAC_SPEC11_ADD_TOP		0x334
-#define EMAC_SPEC12_ADD_BOT		0x338
-#define EMAC_SPEC12_ADD_TOP		0x33c
-#define EMAC_SPEC13_ADD_BOT		0x340
-#define EMAC_SPEC13_ADD_TOP		0x344
-#define EMAC_SPEC14_ADD_BOT		0x348
-#define EMAC_SPEC14_ADD_TOP		0x34c
-#define EMAC_SPEC15_ADD_BOT		0x350
-#define EMAC_SPEC15_ADD_TOP		0x354
-#define EMAC_SPEC16_ADD_BOT		0x358
-#define EMAC_SPEC16_ADD_TOP		0x35c
-#define EMAC_SPEC17_ADD_BOT		0x360
-#define EMAC_SPEC17_ADD_TOP		0x364
-#define EMAC_SPEC18_ADD_BOT		0x368
-#define EMAC_SPEC18_ADD_TOP		0x36c
-#define EMAC_SPEC19_ADD_BOT		0x370
-#define EMAC_SPEC19_ADD_TOP		0x374
-#define EMAC_SPEC20_ADD_BOT		0x378
-#define EMAC_SPEC20_ADD_TOP		0x37c
-#define EMAC_SPEC21_ADD_BOT		0x380
-#define EMAC_SPEC21_ADD_TOP		0x384
-#define EMAC_SPEC22_ADD_BOT		0x388
-#define EMAC_SPEC22_ADD_TOP		0x38c
-#define EMAC_SPEC23_ADD_BOT		0x390
-#define EMAC_SPEC23_ADD_TOP		0x394
-#define EMAC_SPEC24_ADD_BOT		0x398
-#define EMAC_SPEC24_ADD_TOP		0x39c
-#define EMAC_SPEC25_ADD_BOT		0x3a0
-#define EMAC_SPEC25_ADD_TOP		0x3a4
-#define EMAC_SPEC26_ADD_BOT		0x3a8
-#define EMAC_SPEC26_ADD_TOP		0x3ac
-#define EMAC_SPEC27_ADD_BOT		0x3b0
-#define EMAC_SPEC27_ADD_TOP		0x3b4
-#define EMAC_SPEC28_ADD_BOT		0x3b8
-#define EMAC_SPEC28_ADD_TOP		0x3bc
-#define EMAC_SPEC29_ADD_BOT		0x3c0
-#define EMAC_SPEC29_ADD_TOP		0x3c4
-#define EMAC_SPEC30_ADD_BOT		0x3c8
-#define EMAC_SPEC30_ADD_TOP		0x3cc
-#define EMAC_SPEC31_ADD_BOT		0x3d0
-#define EMAC_SPEC31_ADD_TOP		0x3d4
-#define EMAC_SPEC32_ADD_BOT		0x3d8
-#define EMAC_SPEC32_ADD_TOP		0x3dc
-
-#define EMAC_SPEC_ADDR_MAX		32
-
-#define EMAC_CONTROL			0x7a0
+#define EMAC_NETWORK_CONTROL	0x000
+#define EMAC_NETWORK_CONFIG	0x004
+#define EMAC_NETWORK_STATUS	0x008
+#define EMAC_DMA_CONFIG	0x010
+
+#define EMAC_PHY_MANAGEMENT	0x034
+
+#define EMAC_HASH_BOT	0x080
+#define EMAC_HASH_TOP	0x084
+
+#define EMAC_SPEC1_ADD_BOT	0x088
+#define EMAC_SPEC1_ADD_TOP	0x08c
+#define EMAC_SPEC2_ADD_BOT	0x090
+#define EMAC_SPEC2_ADD_TOP	0x094
+#define EMAC_SPEC3_ADD_BOT	0x098
+#define EMAC_SPEC3_ADD_TOP	0x09c
+#define EMAC_SPEC4_ADD_BOT	0x0a0
+#define EMAC_SPEC4_ADD_TOP	0x0a4
+#define EMAC_WOL	0x0b8
+
+#define	EMAC_STACKED_VLAN_REG	0x0c0
+
+#define EMAC_SPEC1_ADD_MASK_BOT	0x0c8
+#define EMAC_SPEC1_ADD_MASK_TOP	0x0cc
+
+#define EMAC_RMON_BASE_OFST	0x100
+
+#define EMAC_SPEC5_ADD_BOT	0x300
+#define EMAC_SPEC5_ADD_TOP	0x304
+#define EMAC_SPEC6_ADD_BOT	0x308
+#define EMAC_SPEC6_ADD_TOP	0x30c
+#define EMAC_SPEC7_ADD_BOT	0x310
+#define EMAC_SPEC7_ADD_TOP	0x314
+#define EMAC_SPEC8_ADD_BOT	0x318
+#define EMAC_SPEC8_ADD_TOP	0x31c
+#define EMAC_SPEC9_ADD_BOT	0x320
+#define EMAC_SPEC9_ADD_TOP	0x324
+#define EMAC_SPEC10_ADD_BOT	0x328
+#define EMAC_SPEC10_ADD_TOP	0x32c
+#define EMAC_SPEC11_ADD_BOT	0x330
+#define EMAC_SPEC11_ADD_TOP	0x334
+#define EMAC_SPEC12_ADD_BOT	0x338
+#define EMAC_SPEC12_ADD_TOP	0x33c
+#define EMAC_SPEC13_ADD_BOT	0x340
+#define EMAC_SPEC13_ADD_TOP	0x344
+#define EMAC_SPEC14_ADD_BOT	0x348
+#define EMAC_SPEC14_ADD_TOP	0x34c
+#define EMAC_SPEC15_ADD_BOT	0x350
+#define EMAC_SPEC15_ADD_TOP	0x354
+#define EMAC_SPEC16_ADD_BOT	0x358
+#define EMAC_SPEC16_ADD_TOP	0x35c
+#define EMAC_SPEC17_ADD_BOT	0x360
+#define EMAC_SPEC17_ADD_TOP	0x364
+#define EMAC_SPEC18_ADD_BOT	0x368
+#define EMAC_SPEC18_ADD_TOP	0x36c
+#define EMAC_SPEC19_ADD_BOT	0x370
+#define EMAC_SPEC19_ADD_TOP	0x374
+#define EMAC_SPEC20_ADD_BOT	0x378
+#define EMAC_SPEC20_ADD_TOP	0x37c
+#define EMAC_SPEC21_ADD_BOT	0x380
+#define EMAC_SPEC21_ADD_TOP	0x384
+#define EMAC_SPEC22_ADD_BOT	0x388
+#define EMAC_SPEC22_ADD_TOP	0x38c
+#define EMAC_SPEC23_ADD_BOT	0x390
+#define EMAC_SPEC23_ADD_TOP	0x394
+#define EMAC_SPEC24_ADD_BOT	0x398
+#define EMAC_SPEC24_ADD_TOP	0x39c
+#define EMAC_SPEC25_ADD_BOT	0x3a0
+#define EMAC_SPEC25_ADD_TOP	0x3a4
+#define EMAC_SPEC26_ADD_BOT	0x3a8
+#define EMAC_SPEC26_ADD_TOP	0x3ac
+#define EMAC_SPEC27_ADD_BOT	0x3b0
+#define EMAC_SPEC27_ADD_TOP	0x3b4
+#define EMAC_SPEC28_ADD_BOT	0x3b8
+#define EMAC_SPEC28_ADD_TOP	0x3bc
+#define EMAC_SPEC29_ADD_BOT	0x3c0
+#define EMAC_SPEC29_ADD_TOP	0x3c4
+#define EMAC_SPEC30_ADD_BOT	0x3c8
+#define EMAC_SPEC30_ADD_TOP	0x3cc
+#define EMAC_SPEC31_ADD_BOT	0x3d0
+#define EMAC_SPEC31_ADD_TOP	0x3d4
+#define EMAC_SPEC32_ADD_BOT	0x3d8
+#define EMAC_SPEC32_ADD_TOP	0x3dc
+
+#define EMAC_SPEC_ADDR_MAX	32
+
+#define EMAC_CONTROL	0x7a0
 
 /* GEMAC definitions and settings */
 
-#define EMAC_PORT_0			0
-#define EMAC_PORT_1			1
-#define EMAC_PORT_2			2
+#define EMAC_PORT_0	0
+#define EMAC_PORT_1	1
+#define EMAC_PORT_2	2
 
-/* The possible operating speeds of the MAC, currently supporting 10, 100 and
- * 1000Mb modes.
- */
+/*
+* The possible operating speeds of the MAC, currently supporting 10, 100 and
+* 1000Mb modes.
+*/
 typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 
 #define GMII	1
@@ -128,11 +130,11 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 #define DUP_FULL	0x01
 
 /* EMAC_NETWORK_CONTROL bits definition */
-#define EMAC_LB_PHY 			(1 << 0)
-#define EMAC_LB_MAC 			(1 << 1)
-#define EMAC_RX_ENABLE			(1 << 2)
-#define EMAC_TX_ENABLE			(1 << 3)
-#define EMAC_MDIO_EN         		(1 << 4)      /* Enable MDIO port */
+#define EMAC_LB_PHY	(1 << 0)
+#define EMAC_LB_MAC	(1 << 1)
+#define EMAC_RX_ENABLE	(1 << 2)
+#define EMAC_TX_ENABLE	(1 << 3)
+#define EMAC_MDIO_EN	(1 << 4)      /* Enable MDIO port */
 
 /* WoL (Wake on Lan bit definition) */
 #define EMAC_WOL_MAGIC                  (1 << 16)
@@ -141,20 +143,20 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 #define EMAC_WOL_MULTI                  (1 << 19)
 
 /* EMAC_NETWORK_CONFIG bits definition */
-#define EMAC_SPEED_100		(1 << 0)
-#define EMAC_HALF_DUP		(0 << 1)
-#define EMAC_FULL_DUP		(1 << 1)
+#define EMAC_SPEED_100	(1 << 0)
+#define EMAC_HALF_DUP	(0 << 1)
+#define EMAC_FULL_DUP	(1 << 1)
 #define EMAC_DUPLEX_MASK	(1 << 1)
 #define EMAC_ENABLE_JUMBO_FRAME (1 << 3)
-#define EMAC_ENABLE_COPY_ALL	(1 << 4)	
+#define EMAC_ENABLE_COPY_ALL	(1 << 4)
 #define EMAC_NO_BROADCAST	(1 << 5)
 #define EMAC_ENABLE_MULTICAST	(1 << 6)
 #define EMAC_ENABLE_UNICAST	(1 << 7)
 #define EMAC_ENABLE_1536_RX	(1 << 8)
-#define EMAC_SPEED_1000		(1 << 10)
-#define EMAC_PCS_ENABLE		(1 << 11)
+#define EMAC_SPEED_1000	(1 << 10)
+#define EMAC_PCS_ENABLE	(1 << 11)
 #define EMAC_ENABLE_PAUSE_RX	(1 << 13)
-#define EMAC_REMOVE_FCS		(1 << 17)
+#define EMAC_REMOVE_FCS	(1 << 17)
 #define EMAC_ENABLE_CHKSUM_RX	(1 << 24)
 #define EMAC_MDC_DIV_MASK    (0x7 << 18) /* PCLK divisor for MDC */
 #define EMAC_DATA_BUS_WIDTH_SHIFT       21
@@ -164,14 +166,14 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 #define EMAC_DATA_BUS_WIDTH_128 (0x10 << EMAC_DATA_BUS_WIDTH_SHIFT)
 #define EMAC_ENABLE_FCS_RX	(1 << 26)
 #define EMAC_SGMII_MODE_ENABLE	(1 << 27)
-	
-#define EMAC_SPEED_MASK		(EMAC_SPEED_100 | EMAC_SPEED_1000)
+
+#define EMAC_SPEED_MASK	(EMAC_SPEED_100 | EMAC_SPEED_1000)
 
 /* EMAC_STACKED_VLAN_REG bits definition */
 #define EMAC_ENABLE_STACKED_VLAN	(1 << 31)
 
 /* EMAC_CONTROL bits definition */
-#define EMAC_TWO_BYTES_IP_ALIGN		(1 << 0) // two bytes IP alignement
+#define EMAC_TWO_BYTES_IP_ALIGN	(1 << 0) /* two bytes IP alignement */
 
 /* EMAC_NET_STATUS bits  definition */
 #define EMAC_PHY_IDLE        (1<<2)      /* PHY management is idle */
@@ -181,52 +183,56 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 /* EMAC_DMA_CONFIG Bit definitions */
 #define EMAC_ENABLE_CHKSUM_TX	(1<<11)
 
-//RMII enable – bit 1 / RGMII enable – bit 2
-#define EMAC_RMII_MODE_ENABLE		((1 << 1) | (0 << 2))
-#define EMAC_RMII_MODE_DISABLE		(0 << 1)
-#define EMAC_RGMII_MODE_ENABLE		((0 << 1) | (1 << 2))
-#define EMAC_RGMII_MODE_DISABLE		(0 << 2)
-#define EMAC_MII_MODE_ENABLE		(EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE)
-#define EMAC_GMII_MODE_ENABLE		(EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE)
-#define EMAC_MODE_MASK			(0x3 << 1)
+/*RMII enable – bit 1 / RGMII enable – bit 2 */
+#define EMAC_RMII_MODE_ENABLE	((1 << 1) | (0 << 2))
+#define EMAC_RMII_MODE_DISABLE	(0 << 1)
+#define EMAC_RGMII_MODE_ENABLE	((0 << 1) | (1 << 2))
+#define EMAC_RGMII_MODE_DISABLE	(0 << 2)
+#define EMAC_MII_MODE_ENABLE	(EMAC_RMII_MODE_DISABLE | \
+					EMAC_RGMII_MODE_DISABLE)
+#define EMAC_GMII_MODE_ENABLE	(EMAC_RMII_MODE_DISABLE | \
+					EMAC_RGMII_MODE_DISABLE)
+#define EMAC_MODE_MASK	(0x3 << 1)
 
 /* Default configuration */
-#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
-#define EMAC0_DEFAULT_EMAC_MODE		RGMII      
-#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M   
+#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX
+#define EMAC0_DEFAULT_EMAC_MODE	RGMII
+#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M
 
-#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
-#define EMAC1_DEFAULT_EMAC_MODE		RGMII      
-#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M   
+#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX
+#define EMAC1_DEFAULT_EMAC_MODE	RGMII
+#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M
 
-#define EMAC2_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
-#define EMAC2_DEFAULT_EMAC_MODE		RGMII      
-#define EMAC2_DEFAULT_EMAC_SPEED	SPEED_1000M   
+#define EMAC2_DEFAULT_DUPLEX_MODE	FULLDUPLEX
+#define EMAC2_DEFAULT_EMAC_MODE	RGMII
+#define EMAC2_DEFAULT_EMAC_SPEED	SPEED_1000M
 
 /* EMAC Hash size */
 #define EMAC_HASH_REG_BITS       64
 
-/* The Address organisation for the MAC device.  All addresses are split into
- * two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
- * the address and the other field are the high order bits - this may be 16-bits
- * in the case of MAC addresses, or 32-bits for the hash address.
- * In terms of memory storage, the first item (bottom) is assumed to be at a
- * lower address location than 'top'. i.e. top should be at address location of
- * 'bottom' + 4 bytes.
- */
+/*
+* The Address organisation for the MAC device.  All addresses are split into
+* two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
+* the address and the other field are the high order bits - this may be 16-bits
+* in the case of MAC addresses, or 32-bits for the hash address.
+* In terms of memory storage, the first item (bottom) is assumed to be at a
+* lower address location than 'top'. i.e. top should be at address location of
+* 'bottom' + 4 bytes.
+*/
 typedef struct {
 	u32 bottom;     /* Lower 32-bits of address. */
 	u32 top;        /* Upper 32-bits of address. */
 } MAC_ADDR;
 
 
-/* The following is the organisation of the address filters section of the MAC
- * registers.  The Cadence MAC contains four possible specific address match
- * addresses, if an incoming frame corresponds to any one of these four
- * addresses then the frame will be copied to memory.
- * It is not necessary for all four of the address match registers to be
- * programmed, this is application dependant.
- */
+/*
+* The following is the organisation of the address filters section of the MAC
+* registers.  The Cadence MAC contains four possible specific address match
+* addresses, if an incoming frame corresponds to any one of these four
+* addresses then the frame will be copied to memory.
+* It is not necessary for all four of the address match registers to be
+* programmed, this is application dependant.
+*/
 typedef struct {
 	MAC_ADDR one;        /* Specific address register 1. */
 	MAC_ADDR two;        /* Specific address register 2. */
@@ -235,7 +241,7 @@ typedef struct {
 } SPEC_ADDR;
 
 typedef struct {
-	u32 mode; 
+	u32 mode;
 	u32 speed;
 	u32 duplex;
 } GEMAC_CFG;
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/emac_mtip.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/emac_mtip.h
index f95146f..a34e964 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/emac_mtip.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/emac_mtip.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _EMAC_H_
 #define _EMAC_H_
@@ -23,83 +24,83 @@
 #define EMAC_IMASK_REG	0x008
 #define EMAC_R_DES_ACTIVE_REG	0x010
 #define EMAC_X_DES_ACTIVE_REG	0x014
-#define EMAC_ECNTRL_REG		0x024
+#define EMAC_ECNTRL_REG	0x024
 #define EMAC_MII_DATA_REG	0x040
 #define EMAC_MII_CTRL_REG	0x044
 #define EMAC_MIB_CTRL_STS_REG	0x064
-#define EMAC_RCNTRL_REG		0x084
-#define EMAC_TCNTRL_REG		0x0C4
+#define EMAC_RCNTRL_REG	0x084
+#define EMAC_TCNTRL_REG	0x0C4
 #define EMAC_PHY_ADDR_LOW	0x0E4
 #define EMAC_PHY_ADDR_HIGH	0x0E8
-#define EMAC_GAUR		0x120
-#define EMAC_GALR		0x124
+#define EMAC_GAUR	0x120
+#define EMAC_GALR	0x124
 #define EMAC_TFWR_STR_FWD	0x144
 #define EMAC_RX_SECTIOM_FULL	0x190
 #define EMAC_TX_SECTION_EMPTY	0x1A0
-#define EMAC_TRUNC_FL		0x1B0
+#define EMAC_TRUNC_FL	0x1B0
 
-#define RMON_T_DROP		0x200 /* Count of frames not cntd correctly */
-#define RMON_T_PACKETS		0x204 /* RMON TX packet count */
-#define RMON_T_BC_PKT		0x208 /* RMON TX broadcast pkts */
-#define RMON_T_MC_PKT		0x20c /* RMON TX multicast pkts */
+#define RMON_T_DROP	0x200 /* Count of frames not cntd correctly */
+#define RMON_T_PACKETS	0x204 /* RMON TX packet count */
+#define RMON_T_BC_PKT	0x208 /* RMON TX broadcast pkts */
+#define RMON_T_MC_PKT	0x20c /* RMON TX multicast pkts */
 #define RMON_T_CRC_ALIGN	0x210 /* RMON TX pkts with CRC align err */
 #define RMON_T_UNDERSIZE	0x214 /* RMON TX pkts < 64 bytes, good CRC */
-#define RMON_T_OVERSIZE		0x218 /* RMON TX pkts > MAX_FL bytes good CRC */
-#define RMON_T_FRAG		0x21c /* RMON TX pkts < 64 bytes, bad CRC */
-#define RMON_T_JAB		0x220 /* RMON TX pkts > MAX_FL bytes, bad CRC */
-#define RMON_T_COL		0x224 /* RMON TX collision count */
-#define RMON_T_P64		0x228 /* RMON TX 64 byte pkts */
-#define RMON_T_P65TO127		0x22c /* RMON TX 65 to 127 byte pkts */
+#define RMON_T_OVERSIZE	0x218 /* RMON TX pkts > MAX_FL bytes good CRC */
+#define RMON_T_FRAG	0x21c /* RMON TX pkts < 64 bytes, bad CRC */
+#define RMON_T_JAB	0x220 /* RMON TX pkts > MAX_FL bytes, bad CRC */
+#define RMON_T_COL	0x224 /* RMON TX collision count */
+#define RMON_T_P64	0x228 /* RMON TX 64 byte pkts */
+#define RMON_T_P65TO127	0x22c /* RMON TX 65 to 127 byte pkts */
 #define RMON_T_P128TO255	0x230 /* RMON TX 128 to 255 byte pkts */
 #define RMON_T_P256TO511	0x234 /* RMON TX 256 to 511 byte pkts */
 #define RMON_T_P512TO1023	0x238 /* RMON TX 512 to 1023 byte pkts */
 #define RMON_T_P1024TO2047	0x23c /* RMON TX 1024 to 2047 byte pkts */
 #define RMON_T_P_GTE2048	0x240 /* RMON TX pkts > 2048 bytes */
-#define RMON_T_OCTETS		0x244 /* RMON TX octets */
-#define IEEE_T_DROP		0x248 /* Count of frames not counted crtly */
-#define IEEE_T_FRAME_OK		0x24c /* Frames tx'd OK */
-#define IEEE_T_1COL		0x250 /* Frames tx'd with single collision */
-#define IEEE_T_MCOL		0x254 /* Frames tx'd with multiple collision */
-#define IEEE_T_DEF		0x258 /* Frames tx'd after deferral delay */
-#define IEEE_T_LCOL		0x25c /* Frames tx'd with late collision */
-#define IEEE_T_EXCOL		0x260 /* Frames tx'd with excesv collisions */
-#define IEEE_T_MACERR		0x264 /* Frames tx'd with TX FIFO underrun */
-#define IEEE_T_CSERR		0x268 /* Frames tx'd with carrier sense err */
-#define IEEE_T_SQE		0x26c /* Frames tx'd with SQE err */
-#define IEEE_T_FDXFC		0x270 /* Flow control pause frames tx'd */
+#define RMON_T_OCTETS	0x244 /* RMON TX octets */
+#define IEEE_T_DROP	0x248 /* Count of frames not counted crtly */
+#define IEEE_T_FRAME_OK	0x24c /* Frames tx'd OK */
+#define IEEE_T_1COL	0x250 /* Frames tx'd with single collision */
+#define IEEE_T_MCOL	0x254 /* Frames tx'd with multiple collision */
+#define IEEE_T_DEF	0x258 /* Frames tx'd after deferral delay */
+#define IEEE_T_LCOL	0x25c /* Frames tx'd with late collision */
+#define IEEE_T_EXCOL	0x260 /* Frames tx'd with excesv collisions */
+#define IEEE_T_MACERR	0x264 /* Frames tx'd with TX FIFO underrun */
+#define IEEE_T_CSERR	0x268 /* Frames tx'd with carrier sense err */
+#define IEEE_T_SQE	0x26c /* Frames tx'd with SQE err */
+#define IEEE_T_FDXFC	0x270 /* Flow control pause frames tx'd */
 #define IEEE_T_OCTETS_OK	0x274 /* Octet count for frames tx'd w/o err */
-#define RMON_R_PACKETS		0x284 /* RMON RX packet count */
-#define RMON_R_BC_PKT		0x288 /* RMON RX broadcast pkts */
-#define RMON_R_MC_PKT		0x28c /* RMON RX multicast pkts */
+#define RMON_R_PACKETS	0x284 /* RMON RX packet count */
+#define RMON_R_BC_PKT	0x288 /* RMON RX broadcast pkts */
+#define RMON_R_MC_PKT	0x28c /* RMON RX multicast pkts */
 #define RMON_R_CRC_ALIGN	0x290 /* RMON RX pkts with CRC alignment err */
 #define RMON_R_UNDERSIZE	0x294 /* RMON RX pkts < 64 bytes, good CRC */
-#define RMON_R_OVERSIZE		0x298 /* RMON RX pkts > MAX_FL bytes good CRC */
-#define RMON_R_FRAG		0x29c /* RMON RX pkts < 64 bytes, bad CRC */
-#define RMON_R_JAB		0x2a0 /* RMON RX pkts > MAX_FL bytes, bad CRC */
-#define RMON_R_RESVD_O		0x2a4 /* Reserved */
-#define RMON_R_P64		0x2a8 /* RMON RX 64 byte pkts */
-#define RMON_R_P65TO127		0x2ac /* RMON RX 65 to 127 byte pkts */
+#define RMON_R_OVERSIZE	0x298 /* RMON RX pkts > MAX_FL bytes good CRC */
+#define RMON_R_FRAG	0x29c /* RMON RX pkts < 64 bytes, bad CRC */
+#define RMON_R_JAB	0x2a0 /* RMON RX pkts > MAX_FL bytes, bad CRC */
+#define RMON_R_RESVD_O	0x2a4 /* Reserved */
+#define RMON_R_P64	0x2a8 /* RMON RX 64 byte pkts */
+#define RMON_R_P65TO127	0x2ac /* RMON RX 65 to 127 byte pkts */
 #define RMON_R_P128TO255	0x2b0 /* RMON RX 128 to 255 byte pkts */
 #define RMON_R_P256TO511	0x2b4 /* RMON RX 256 to 511 byte pkts */
 #define RMON_R_P512TO1023	0x2b8 /* RMON RX 512 to 1023 byte pkts */
 #define RMON_R_P1024TO2047	0x2bc /* RMON RX 1024 to 2047 byte pkts */
 #define RMON_R_P_GTE2048	0x2c0 /* RMON RX pkts > 2048 bytes */
-#define RMON_R_OCTETS		0x2c4 /* RMON RX octets */
-#define IEEE_R_DROP		0x2c8 /* Count frames not counted correctly */
-#define IEEE_R_FRAME_OK		0x2cc /* Frames rx'd OK */
-#define IEEE_R_CRC		0x2d0 /* Frames rx'd with CRC err */
-#define IEEE_R_ALIGN		0x2d4 /* Frames rx'd with alignment err */
-#define IEEE_R_MACERR		0x2d8 /* Receive FIFO overflow count */
-#define IEEE_R_FDXFC		0x2dc /* Flow control pause frames rx'd */
+#define RMON_R_OCTETS	0x2c4 /* RMON RX octets */
+#define IEEE_R_DROP	0x2c8 /* Count frames not counted correctly */
+#define IEEE_R_FRAME_OK	0x2cc /* Frames rx'd OK */
+#define IEEE_R_CRC	0x2d0 /* Frames rx'd with CRC err */
+#define IEEE_R_ALIGN	0x2d4 /* Frames rx'd with alignment err */
+#define IEEE_R_MACERR	0x2d8 /* Receive FIFO overflow count */
+#define IEEE_R_FDXFC	0x2dc /* Flow control pause frames rx'd */
 #define IEEE_R_OCTETS_OK	0x2e0 /* Octet cnt for frames rx'd w/o err */
 
-#define EMAC_SMAC_0_0		0x500 /*Supplemental MAC Address 0 (RW).*/
-#define EMAC_SMAC_0_1		0x504 /*Supplemental MAC Address 0 (RW).*/
+#define EMAC_SMAC_0_0	0x500 /*Supplemental MAC Address 0 (RW).*/
+#define EMAC_SMAC_0_1	0x504 /*Supplemental MAC Address 0 (RW).*/
 
 /* GEMAC definitions and settings */
 
-#define EMAC_PORT_0			0
-#define EMAC_PORT_1			1
+#define EMAC_PORT_0	0
+#define EMAC_PORT_1	1
 
 /* GEMAC Bit definitions */
 #define EMAC_IEVENT_HBERR                0x80000000
@@ -141,7 +142,7 @@
 #define EMAC_RCNTRL_SGMII                0x00000080
 #define EMAC_RCNTRL_RMII                 0x00000100
 #define EMAC_RCNTRL_RMII_10T             0x00000200
-#define EMAC_RCNTRL_CRC_FWD		 0x00004000
+#define EMAC_RCNTRL_CRC_FWD	 0x00004000
 
 #define EMAC_TCNTRL_GTS                  0x00000001
 #define EMAC_TCNTRL_HBC                  0x00000002
@@ -161,9 +162,10 @@
 
 
 
-/* The possible operating speeds of the MAC, currently supporting 10, 100 and
- * 1000Mb modes.
- */
+/*
+* The possible operating speeds of the MAC, currently supporting 10, 100 and
+* 1000Mb modes.
+*/
 typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 
 #define GMII	1
@@ -177,18 +179,20 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 
 
 /* Default configuration */
-#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
-#define EMAC0_DEFAULT_EMAC_MODE		RGMII      
-#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M   
+#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX
+#define EMAC0_DEFAULT_EMAC_MODE	RGMII
+#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M
 
-#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
-#define EMAC1_DEFAULT_EMAC_MODE		SGMII      
-#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M   
+#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX
+#define EMAC1_DEFAULT_EMAC_MODE	SGMII
+#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M
 
 /* MII-related definitios */
 #define EMAC_MII_DATA_ST         0x40000000      /* Start of frame delimiter */
 #define EMAC_MII_DATA_OP_RD      0x20000000      /* Perform a read operation */
+#define EMAC_MII_DATA_OP_CL45_RD 0x30000000      /* Perform a read operation */
 #define EMAC_MII_DATA_OP_WR      0x10000000      /* Perform a write operation */
+#define EMAC_MII_DATA_OP_CL45_WR 0x10000000      /* Perform a write operation */
 #define EMAC_MII_DATA_PA_MSK     0x0f800000      /* PHY Address field mask */
 #define EMAC_MII_DATA_RA_MSK     0x007c0000      /* PHY Register field mask */
 #define EMAC_MII_DATA_TA         0x00020000      /* Turnaround */
@@ -199,36 +203,41 @@ typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
 #define EMAC_MII_DATA_PA_SHIFT   23      /* MII PHY address bits */
 #define EMAC_MII_DATA_PA_MASK    0x1F      /* MII PHY address mask */
 
-#define EMAC_MII_DATA_RA(v) ((v & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_RA_SHIFT)
-#define EMAC_MII_DATA_PA(v) ((v & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_PA_SHIFT)
+#define EMAC_MII_DATA_RA(v) ((v & EMAC_MII_DATA_RA_MASK) << \
+				EMAC_MII_DATA_RA_SHIFT)
+#define EMAC_MII_DATA_PA(v) ((v & EMAC_MII_DATA_RA_MASK) << \
+				EMAC_MII_DATA_PA_SHIFT)
 #define EMAC_MII_DATA(v)    (v & 0xffff)
 
 #define EMAC_MII_SPEED_SHIFT	1
 #define EMAC_HOLDTIME_SHIFT	8
 #define EMAC_HOLDTIME_MASK	0x7
-#define EMAC_HOLDTIME(v)	((v & EMAC_HOLDTIME_MASK) << EMAC_HOLDTIME_SHIFT)
-
-/* The Address organisation for the MAC device.  All addresses are split into
- * two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
- * the address and the other field are the high order bits - this may be 16-bits
- * in the case of MAC addresses, or 32-bits for the hash address.
- * In terms of memory storage, the first item (bottom) is assumed to be at a
- * lower address location than 'top'. i.e. top should be at address location of
- * 'bottom' + 4 bytes.
- */
+#define EMAC_HOLDTIME(v)	((v & EMAC_HOLDTIME_MASK) << \
+					EMAC_HOLDTIME_SHIFT)
+
+/*
+* The Address organisation for the MAC device.  All addresses are split into
+* two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
+* the address and the other field are the high order bits - this may be 16-bits
+* in the case of MAC addresses, or 32-bits for the hash address.
+* In terms of memory storage, the first item (bottom) is assumed to be at a
+* lower address location than 'top'. i.e. top should be at address location of
+* 'bottom' + 4 bytes.
+*/
 typedef struct {
 	u32 bottom;     /* Lower 32-bits of address. */
 	u32 top;        /* Upper 32-bits of address. */
 } MAC_ADDR;
 
 
-/* The following is the organisation of the address filters section of the MAC
- * registers.  The Cadence MAC contains four possible specific address match
- * addresses, if an incoming frame corresponds to any one of these four
- * addresses then the frame will be copied to memory.
- * It is not necessary for all four of the address match registers to be
- * programmed, this is application dependant.
- */
+/*
+* The following is the organisation of the address filters section of the MAC
+* registers.  The Cadence MAC contains four possible specific address match
+* addresses, if an incoming frame corresponds to any one of these four
+* addresses then the frame will be copied to memory.
+* It is not necessary for all four of the address match registers to be
+* programmed, this is application dependant.
+*/
 typedef struct {
 	MAC_ADDR one;        /* Specific address register 1. */
 	MAC_ADDR two;        /* Specific address register 2. */
@@ -237,7 +246,7 @@ typedef struct {
 } SPEC_ADDR;
 
 typedef struct {
-	u32 mode; 
+	u32 mode;
 	u32 speed;
 	u32 duplex;
 } GEMAC_CFG;
@@ -245,6 +254,6 @@ typedef struct {
 /* EMAC Hash size */
 #define EMAC_HASH_REG_BITS       64
 
-#define EMAC_SPEC_ADDR_MAX		4
+#define EMAC_SPEC_ADDR_MAX	4
 
 #endif /* _EMAC_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/gpi.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/gpi.h
index b4fd088..c863813 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/gpi.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/gpi.h
@@ -1,48 +1,49 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _GPI_H_
 #define _GPI_H_
 
-#define GPI_VERSION			0x00
-#define GPI_CTRL			0x04
-#define GPI_RX_CONFIG			0x08
-#define GPI_HDR_SIZE			0x0c
-#define GPI_BUF_SIZE			0x10
-#define GPI_LMEM_ALLOC_ADDR		0x14
-#define GPI_LMEM_FREE_ADDR		0x18
-#define GPI_DDR_ALLOC_ADDR		0x1c
-#define GPI_DDR_FREE_ADDR		0x20
-#define GPI_CLASS_ADDR			0x24
-#define GPI_DRX_FIFO			0x28
-#define GPI_TRX_FIFO			0x2c
-#define GPI_INQ_PKTPTR			0x30
-#define GPI_DDR_DATA_OFFSET		0x34
-#define GPI_LMEM_DATA_OFFSET		0x38
-#define GPI_TMLF_TX			0x4c
-#define GPI_DTX_ASEQ			0x50
-#define GPI_FIFO_STATUS			0x54
-#define GPI_FIFO_DEBUG			0x58
-#define GPI_TX_PAUSE_TIME		0x5c
+#define GPI_VERSION	0x00
+#define GPI_CTRL	0x04
+#define GPI_RX_CONFIG	0x08
+#define GPI_HDR_SIZE	0x0c
+#define GPI_BUF_SIZE	0x10
+#define GPI_LMEM_ALLOC_ADDR	0x14
+#define GPI_LMEM_FREE_ADDR	0x18
+#define GPI_DDR_ALLOC_ADDR	0x1c
+#define GPI_DDR_FREE_ADDR	0x20
+#define GPI_CLASS_ADDR	0x24
+#define GPI_DRX_FIFO	0x28
+#define GPI_TRX_FIFO	0x2c
+#define GPI_INQ_PKTPTR	0x30
+#define GPI_DDR_DATA_OFFSET	0x34
+#define GPI_LMEM_DATA_OFFSET	0x38
+#define GPI_TMLF_TX	0x4c
+#define GPI_DTX_ASEQ	0x50
+#define GPI_FIFO_STATUS	0x54
+#define GPI_FIFO_DEBUG	0x58
+#define GPI_TX_PAUSE_TIME	0x5c
 #define GPI_LMEM_SEC_BUF_DATA_OFFSET	0x60
 #define GPI_DDR_SEC_BUF_DATA_OFFSET	0x64
-#define GPI_TOE_CHKSUM_EN		0x68
-#define GPI_OVERRUN_DROPCNT		0x6c
+#define GPI_TOE_CHKSUM_EN	0x68
+#define GPI_OVERRUN_DROPCNT	0x6c
 
 typedef struct {
 	u32 lmem_rtry_cnt;
@@ -51,28 +52,28 @@ typedef struct {
 } GPI_CFG;
 
 
-/* GPI commons defines */ 
-#define GPI_LMEM_BUF_EN		0x1
-#define GPI_DDR_BUF_EN		0x1
+/* GPI commons defines */
+#define GPI_LMEM_BUF_EN	0x1
+#define GPI_DDR_BUF_EN	0x1
 
-/* EGPI 1 defines */ 
+/* EGPI 1 defines */
 #define EGPI1_LMEM_RTRY_CNT	0x40
 #define EGPI1_TMLF_TXTHRES	0xBC
-#define EGPI1_ASEQ_LEN		0x50
+#define EGPI1_ASEQ_LEN	0x50
 
-/* EGPI 2 defines */ 
+/* EGPI 2 defines */
 #define EGPI2_LMEM_RTRY_CNT	0x40
 #define EGPI2_TMLF_TXTHRES	0xBC
-#define EGPI2_ASEQ_LEN		0x40
+#define EGPI2_ASEQ_LEN	0x40
 
-/* EGPI 3 defines */ 
+/* EGPI 3 defines */
 #define EGPI3_LMEM_RTRY_CNT	0x40
 #define EGPI3_TMLF_TXTHRES	0xBC
-#define EGPI3_ASEQ_LEN		0x40
+#define EGPI3_ASEQ_LEN	0x40
 
-/* HGPI defines */ 
+/* HGPI defines */
 #define HGPI_LMEM_RTRY_CNT	0x40
 #define HGPI_TMLF_TXTHRES	0xBC
-#define HGPI_ASEQ_LEN		0x40
+#define HGPI_ASEQ_LEN	0x40
 
 #endif /* _GPI_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/gpt.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/gpt.h
index 26b1035..ac665b7 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/gpt.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/gpt.h
@@ -13,17 +13,18 @@
  *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA  02110-1301, USA.
  *
 */
 #ifndef _CBUS_GPT_H_
 #define _CBUS_GPT_H_
 
 #define CBUS_GPT_VERSION	 (CBUS_GPT_BASE_ADDR + 0x00)
-#define CBUS_GPT_STATUS		 (CBUS_GPT_BASE_ADDR + 0x04)
-#define CBUS_GPT_CONFIG		 (CBUS_GPT_BASE_ADDR + 0x08)
+#define CBUS_GPT_STATUS	 (CBUS_GPT_BASE_ADDR + 0x04)
+#define CBUS_GPT_CONFIG	 (CBUS_GPT_BASE_ADDR + 0x08)
 #define CBUS_GPT_COUNTER	 (CBUS_GPT_BASE_ADDR + 0x0c)
-#define CBUS_GPT_PERIOD		 (CBUS_GPT_BASE_ADDR + 0x10)
-#define CBUS_GPT_WIDTH		 (CBUS_GPT_BASE_ADDR + 0x14)
+#define CBUS_GPT_PERIOD	 (CBUS_GPT_BASE_ADDR + 0x10)
+#define CBUS_GPT_WIDTH	 (CBUS_GPT_BASE_ADDR + 0x14)
 
 #endif /* _CBUS_GPT_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/hif.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/hif.h
index b856cea..e901438 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/hif.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/hif.h
@@ -1,62 +1,63 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _HIF_H_
 #define _HIF_H_
 
 /** @file hif.h.
- * hif - PFE hif block control and status register. Mapped on CBUS and accessible from all PE's and ARM.
- */
-#define HIF_VERSION		(HIF_BASE_ADDR + 0x00)
-#define HIF_TX_CTRL		(HIF_BASE_ADDR + 0x04)
+* hif - PFE hif block control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+*/
+#define HIF_VERSION	(HIF_BASE_ADDR + 0x00)
+#define HIF_TX_CTRL	(HIF_BASE_ADDR + 0x04)
 #define HIF_TX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x08)
-#define HIF_TX_ALLOC		(HIF_BASE_ADDR + 0x0c)
-#define HIF_TX_BDP_ADDR		(HIF_BASE_ADDR + 0x10)
-#define HIF_TX_STATUS		(HIF_BASE_ADDR + 0x14)
-#define HIF_RX_CTRL		(HIF_BASE_ADDR + 0x20)
-#define HIF_RX_BDP_ADDR		(HIF_BASE_ADDR + 0x24)
-#define HIF_RX_STATUS		(HIF_BASE_ADDR + 0x30)
-#define HIF_INT_SRC		(HIF_BASE_ADDR + 0x34)
-#define HIF_INT_ENABLE		(HIF_BASE_ADDR + 0x38)
-#define HIF_POLL_CTRL		(HIF_BASE_ADDR + 0x3c)
+#define HIF_TX_ALLOC	(HIF_BASE_ADDR + 0x0c)
+#define HIF_TX_BDP_ADDR	(HIF_BASE_ADDR + 0x10)
+#define HIF_TX_STATUS	(HIF_BASE_ADDR + 0x14)
+#define HIF_RX_CTRL	(HIF_BASE_ADDR + 0x20)
+#define HIF_RX_BDP_ADDR	(HIF_BASE_ADDR + 0x24)
+#define HIF_RX_STATUS	(HIF_BASE_ADDR + 0x30)
+#define HIF_INT_SRC	(HIF_BASE_ADDR + 0x34)
+#define HIF_INT_ENABLE	(HIF_BASE_ADDR + 0x38)
+#define HIF_POLL_CTRL	(HIF_BASE_ADDR + 0x3c)
 #define HIF_RX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x40)
-#define HIF_RX_ALLOC		(HIF_BASE_ADDR + 0x44)
+#define HIF_RX_ALLOC	(HIF_BASE_ADDR + 0x44)
 #define HIF_TX_DMA_STATUS	(HIF_BASE_ADDR + 0x48)
 #define HIF_RX_DMA_STATUS	(HIF_BASE_ADDR + 0x4c)
-#define HIF_INT_COAL		(HIF_BASE_ADDR + 0x50)
+#define HIF_INT_COAL	(HIF_BASE_ADDR + 0x50)
 
 /*HIF_INT_SRC/ HIF_INT_ENABLE control bits */
-#define HIF_INT        		(1 << 0)
-#define HIF_RXBD_INT   		(1 << 1)
-#define HIF_RXPKT_INT  		(1 << 2)
-#define HIF_TXBD_INT   		(1 << 3)
-#define HIF_TXPKT_INT  		(1 << 4)
+#define HIF_INT	(1 << 0)
+#define HIF_RXBD_INT	(1 << 1)
+#define HIF_RXPKT_INT	(1 << 2)
+#define HIF_TXBD_INT	(1 << 3)
+#define HIF_TXPKT_INT	(1 << 4)
 
 /*HIF_TX_CTRL bits */
-#define HIF_CTRL_DMA_EN			(1<<0)
+#define HIF_CTRL_DMA_EN	(1<<0)
 #define HIF_CTRL_BDP_POLL_CTRL_EN	(1<<1)
 #define HIF_CTRL_BDP_CH_START_WSTB	(1<<2)
 
 /*HIF_INT_ENABLE bits */
-#define HIF_INT_EN		(1 << 0)
-#define HIF_RXBD_INT_EN		(1 << 1)
+#define HIF_INT_EN	(1 << 0)
+#define HIF_RXBD_INT_EN	(1 << 1)
 #define HIF_RXPKT_INT_EN	(1 << 2)
-#define HIF_TXBD_INT_EN		(1 << 3)
+#define HIF_TXBD_INT_EN	(1 << 3)
 #define HIF_TXPKT_INT_EN	(1 << 4)
 
 /*HIF_POLL_CTRL bits*/
@@ -68,15 +69,15 @@
 
 /*Buffer descriptor control bits */
 #define BD_CTRL_BUFLEN_MASK	0x3fff
-#define BD_BUF_LEN(x)		(x & BD_CTRL_BUFLEN_MASK)
+#define BD_BUF_LEN(x)	(x & BD_CTRL_BUFLEN_MASK)
 #define BD_CTRL_CBD_INT_EN	(1 << 16)
 #define BD_CTRL_PKT_INT_EN	(1 << 17)
-#define BD_CTRL_LIFM		(1 << 18)
-#define BD_CTRL_LAST_BD		(1 << 19)
-#define BD_CTRL_DIR		(1 << 20)
+#define BD_CTRL_LIFM	(1 << 18)
+#define BD_CTRL_LAST_BD	(1 << 19)
+#define BD_CTRL_DIR	(1 << 20)
 #define BD_CTRL_LMEM_CPY	(1 << 21) /*Valid only for HIF_NOCPY*/
 #define BD_CTRL_PKT_XFER	(1 << 24)
-#define BD_CTRL_DESC_EN		(1 << 31)
+#define BD_CTRL_DESC_EN	(1 << 31)
 #define BD_CTRL_PARSE_DISABLE	(1 << 25)
 #define BD_CTRL_BRFETCH_DISABLE	(1 << 26)
 #define BD_CTRL_RTFETCH_DISABLE	(1 << 27)
@@ -84,13 +85,13 @@
 /*Buffer descriptor status bits*/
 #define BD_STATUS_CONN_ID(x)	((x) & 0xffff)
 #define BD_STATUS_DIR_PROC_ID	(1 << 16)
-#define BD_STATUS_CONN_ID_EN	(1 << 17))
+#define BD_STATUS_CONN_ID_EN	((1 << 17))
 #define BD_STATUS_PE2PROC_ID(x)	(((x) & 7) << 18)
 #define BD_STATUS_LE_DATA	(1 << 21)
 #define BD_STATUS_CHKSUM_EN	(1 << 22)
 
 /*HIF Buffer descriptor status bits */
-#define DIR_PROC_ID		(1 << 16)
-#define PROC_ID(id)		((id) << 18)
+#define DIR_PROC_ID	(1 << 16)
+#define PROC_ID(id)	((id) << 18)
 
 #endif /* _HIF_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/hif_nocpy.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/hif_nocpy.h
index d5234d0..53618b8 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/hif_nocpy.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/hif_nocpy.h
@@ -1,51 +1,52 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _HIF_NOCPY_H_
 #define _HIF_NOCPY_H_
 
-#define HIF_NOCPY_VERSION		(HIF_NOCPY_BASE_ADDR + 0x00)
-#define HIF_NOCPY_TX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x04)
+#define HIF_NOCPY_VERSION	(HIF_NOCPY_BASE_ADDR + 0x00)
+#define HIF_NOCPY_TX_CTRL	(HIF_NOCPY_BASE_ADDR + 0x04)
 #define HIF_NOCPY_TX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x08)
-#define HIF_NOCPY_TX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x0c)
-#define HIF_NOCPY_TX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x10)
-#define HIF_NOCPY_TX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x14)
-#define HIF_NOCPY_RX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x20)
-#define HIF_NOCPY_RX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x24)
-#define HIF_NOCPY_RX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x30)
-#define HIF_NOCPY_INT_SRC		(HIF_NOCPY_BASE_ADDR + 0x34)
-#define HIF_NOCPY_INT_ENABLE		(HIF_NOCPY_BASE_ADDR + 0x38)
-#define HIF_NOCPY_POLL_CTRL		(HIF_NOCPY_BASE_ADDR + 0x3c)
+#define HIF_NOCPY_TX_ALLOC	(HIF_NOCPY_BASE_ADDR + 0x0c)
+#define HIF_NOCPY_TX_BDP_ADDR	(HIF_NOCPY_BASE_ADDR + 0x10)
+#define HIF_NOCPY_TX_STATUS	(HIF_NOCPY_BASE_ADDR + 0x14)
+#define HIF_NOCPY_RX_CTRL	(HIF_NOCPY_BASE_ADDR + 0x20)
+#define HIF_NOCPY_RX_BDP_ADDR	(HIF_NOCPY_BASE_ADDR + 0x24)
+#define HIF_NOCPY_RX_STATUS	(HIF_NOCPY_BASE_ADDR + 0x30)
+#define HIF_NOCPY_INT_SRC	(HIF_NOCPY_BASE_ADDR + 0x34)
+#define HIF_NOCPY_INT_ENABLE	(HIF_NOCPY_BASE_ADDR + 0x38)
+#define HIF_NOCPY_POLL_CTRL	(HIF_NOCPY_BASE_ADDR + 0x3c)
 #define HIF_NOCPY_RX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x40)
-#define HIF_NOCPY_RX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x44)
-#define HIF_NOCPY_TX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x48)
-#define HIF_NOCPY_RX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x4c)
+#define HIF_NOCPY_RX_ALLOC	(HIF_NOCPY_BASE_ADDR + 0x44)
+#define HIF_NOCPY_TX_DMA_STATUS	(HIF_NOCPY_BASE_ADDR + 0x48)
+#define HIF_NOCPY_RX_DMA_STATUS	(HIF_NOCPY_BASE_ADDR + 0x4c)
 #define HIF_NOCPY_RX_INQ0_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x50)
 #define HIF_NOCPY_RX_INQ1_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x54)
-#define HIF_NOCPY_TX_PORT_NO		(HIF_NOCPY_BASE_ADDR + 0x60)
+#define HIF_NOCPY_TX_PORT_NO	(HIF_NOCPY_BASE_ADDR + 0x60)
 #define HIF_NOCPY_LMEM_ALLOC_ADDR	(HIF_NOCPY_BASE_ADDR + 0x64)
-#define HIF_NOCPY_CLASS_ADDR		(HIF_NOCPY_BASE_ADDR + 0x68)
+#define HIF_NOCPY_CLASS_ADDR	(HIF_NOCPY_BASE_ADDR + 0x68)
 #define HIF_NOCPY_TMU_PORT0_ADDR	(HIF_NOCPY_BASE_ADDR + 0x70)
 #define HIF_NOCPY_TMU_PORT1_ADDR	(HIF_NOCPY_BASE_ADDR + 0x74)
 #define HIF_NOCPY_TMU_PORT2_ADDR	(HIF_NOCPY_BASE_ADDR + 0x7c)
 #define HIF_NOCPY_TMU_PORT3_ADDR	(HIF_NOCPY_BASE_ADDR + 0x80)
 #define HIF_NOCPY_TMU_PORT4_ADDR	(HIF_NOCPY_BASE_ADDR + 0x84)
-#define HIF_NOCPY_INT_COAL		(HIF_NOCPY_BASE_ADDR + 0x90)
+#define HIF_NOCPY_INT_COAL	(HIF_NOCPY_BASE_ADDR + 0x90)
 
 
 #endif /* _HIF_NOCPY_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/tmu_csr.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/tmu_csr.h
index 1b07368..c00512b 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/tmu_csr.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/tmu_csr.h
@@ -1,106 +1,147 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _TMU_CSR_H_
 #define _TMU_CSR_H_
 
-#define TMU_VERSION			(TMU_CSR_BASE_ADDR + 0x000)
-#define TMU_INQ_WATERMARK		(TMU_CSR_BASE_ADDR + 0x004)
-#define TMU_PHY_INQ_PKTPTR		(TMU_CSR_BASE_ADDR + 0x008)
-#define TMU_PHY_INQ_PKTINFO		(TMU_CSR_BASE_ADDR + 0x00c)
-#define TMU_PHY_INQ_FIFO_CNT		(TMU_CSR_BASE_ADDR + 0x010)
-#define TMU_SYS_GENERIC_CONTROL		(TMU_CSR_BASE_ADDR + 0x014)
-#define TMU_SYS_GENERIC_STATUS		(TMU_CSR_BASE_ADDR + 0x018)
-#define TMU_SYS_GEN_CON0		(TMU_CSR_BASE_ADDR + 0x01c)
-#define TMU_SYS_GEN_CON1		(TMU_CSR_BASE_ADDR + 0x020)
-#define TMU_SYS_GEN_CON2		(TMU_CSR_BASE_ADDR + 0x024)
-#define TMU_SYS_GEN_CON3		(TMU_CSR_BASE_ADDR + 0x028)
-#define TMU_SYS_GEN_CON4		(TMU_CSR_BASE_ADDR + 0x02c)
-#define TMU_TEQ_DISABLE_DROPCHK		(TMU_CSR_BASE_ADDR + 0x030)
-#define TMU_TEQ_CTRL			(TMU_CSR_BASE_ADDR + 0x034)
-#define TMU_TEQ_QCFG			(TMU_CSR_BASE_ADDR + 0x038)
-#define TMU_TEQ_DROP_STAT		(TMU_CSR_BASE_ADDR + 0x03c)
-#define TMU_TEQ_QAVG			(TMU_CSR_BASE_ADDR + 0x040)
-#define TMU_TEQ_WREG_PROB		(TMU_CSR_BASE_ADDR + 0x044)
-#define TMU_TEQ_TRANS_STAT		(TMU_CSR_BASE_ADDR + 0x048)
-#define TMU_TEQ_HW_PROB_CFG0		(TMU_CSR_BASE_ADDR + 0x04c)
-#define TMU_TEQ_HW_PROB_CFG1		(TMU_CSR_BASE_ADDR + 0x050)
-#define TMU_TEQ_HW_PROB_CFG2		(TMU_CSR_BASE_ADDR + 0x054)
-#define TMU_TEQ_HW_PROB_CFG3		(TMU_CSR_BASE_ADDR + 0x058)
-#define TMU_TEQ_HW_PROB_CFG4		(TMU_CSR_BASE_ADDR + 0x05c)
-#define TMU_TEQ_HW_PROB_CFG5		(TMU_CSR_BASE_ADDR + 0x060)
-#define TMU_TEQ_HW_PROB_CFG6		(TMU_CSR_BASE_ADDR + 0x064)
-#define TMU_TEQ_HW_PROB_CFG7		(TMU_CSR_BASE_ADDR + 0x068)
-#define TMU_TEQ_HW_PROB_CFG8		(TMU_CSR_BASE_ADDR + 0x06c)
-#define TMU_TEQ_HW_PROB_CFG9		(TMU_CSR_BASE_ADDR + 0x070)
-#define TMU_TEQ_HW_PROB_CFG10		(TMU_CSR_BASE_ADDR + 0x074)
-#define TMU_TEQ_HW_PROB_CFG11		(TMU_CSR_BASE_ADDR + 0x078)
-#define TMU_TEQ_HW_PROB_CFG12		(TMU_CSR_BASE_ADDR + 0x07c)
-#define TMU_TEQ_HW_PROB_CFG13		(TMU_CSR_BASE_ADDR + 0x080)
-#define TMU_TEQ_HW_PROB_CFG14		(TMU_CSR_BASE_ADDR + 0x084)
-#define TMU_TEQ_HW_PROB_CFG15		(TMU_CSR_BASE_ADDR + 0x088)
-#define TMU_TEQ_HW_PROB_CFG16		(TMU_CSR_BASE_ADDR + 0x08c)
-#define TMU_TEQ_HW_PROB_CFG17		(TMU_CSR_BASE_ADDR + 0x090)
-#define TMU_TEQ_HW_PROB_CFG18		(TMU_CSR_BASE_ADDR + 0x094)
-#define TMU_TEQ_HW_PROB_CFG19		(TMU_CSR_BASE_ADDR + 0x098)
-#define TMU_TEQ_HW_PROB_CFG20		(TMU_CSR_BASE_ADDR + 0x09c)
-#define TMU_TEQ_HW_PROB_CFG21		(TMU_CSR_BASE_ADDR + 0x0a0)
-#define TMU_TEQ_HW_PROB_CFG22		(TMU_CSR_BASE_ADDR + 0x0a4)
-#define TMU_TEQ_HW_PROB_CFG23		(TMU_CSR_BASE_ADDR + 0x0a8)
-#define TMU_TEQ_HW_PROB_CFG24		(TMU_CSR_BASE_ADDR + 0x0ac)
-#define TMU_TEQ_HW_PROB_CFG25		(TMU_CSR_BASE_ADDR + 0x0b0)
-#define TMU_TDQ_IIFG_CFG		(TMU_CSR_BASE_ADDR + 0x0b4)
-#define TMU_TDQ0_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x0b8)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY0 */
-#define TMU_LLM_CTRL			(TMU_CSR_BASE_ADDR + 0x0bc)
-#define TMU_LLM_BASE_ADDR		(TMU_CSR_BASE_ADDR + 0x0c0)
-#define TMU_LLM_QUE_LEN			(TMU_CSR_BASE_ADDR + 0x0c4)
-#define TMU_LLM_QUE_HEADPTR		(TMU_CSR_BASE_ADDR + 0x0c8)
-#define TMU_LLM_QUE_TAILPTR		(TMU_CSR_BASE_ADDR + 0x0cc)
-#define TMU_LLM_QUE_DROPCNT		(TMU_CSR_BASE_ADDR + 0x0d0)
-#define TMU_INT_EN			(TMU_CSR_BASE_ADDR + 0x0d4)
-#define TMU_INT_SRC			(TMU_CSR_BASE_ADDR + 0x0d8)
-#define TMU_INQ_STAT			(TMU_CSR_BASE_ADDR + 0x0dc)
-#define TMU_CTRL			(TMU_CSR_BASE_ADDR + 0x0e0)
+#define TMU_VERSION	(TMU_CSR_BASE_ADDR + 0x000)
+#define TMU_INQ_WATERMARK	(TMU_CSR_BASE_ADDR + 0x004)
+#define TMU_PHY_INQ_PKTPTR	(TMU_CSR_BASE_ADDR + 0x008)
+#define TMU_PHY_INQ_PKTINFO	(TMU_CSR_BASE_ADDR + 0x00c)
+#define TMU_PHY_INQ_FIFO_CNT	(TMU_CSR_BASE_ADDR + 0x010)
+#define TMU_SYS_GENERIC_CONTROL	(TMU_CSR_BASE_ADDR + 0x014)
+#define TMU_SYS_GENERIC_STATUS	(TMU_CSR_BASE_ADDR + 0x018)
+#define TMU_SYS_GEN_CON0	(TMU_CSR_BASE_ADDR + 0x01c)
+#define TMU_SYS_GEN_CON1	(TMU_CSR_BASE_ADDR + 0x020)
+#define TMU_SYS_GEN_CON2	(TMU_CSR_BASE_ADDR + 0x024)
+#define TMU_SYS_GEN_CON3	(TMU_CSR_BASE_ADDR + 0x028)
+#define TMU_SYS_GEN_CON4	(TMU_CSR_BASE_ADDR + 0x02c)
+#define TMU_TEQ_DISABLE_DROPCHK	(TMU_CSR_BASE_ADDR + 0x030)
+#define TMU_TEQ_CTRL	(TMU_CSR_BASE_ADDR + 0x034)
+#define TMU_TEQ_QCFG	(TMU_CSR_BASE_ADDR + 0x038)
+#define TMU_TEQ_DROP_STAT	(TMU_CSR_BASE_ADDR + 0x03c)
+#define TMU_TEQ_QAVG	(TMU_CSR_BASE_ADDR + 0x040)
+#define TMU_TEQ_WREG_PROB	(TMU_CSR_BASE_ADDR + 0x044)
+#define TMU_TEQ_TRANS_STAT	(TMU_CSR_BASE_ADDR + 0x048)
+#define TMU_TEQ_HW_PROB_CFG0	(TMU_CSR_BASE_ADDR + 0x04c)
+#define TMU_TEQ_HW_PROB_CFG1	(TMU_CSR_BASE_ADDR + 0x050)
+#define TMU_TEQ_HW_PROB_CFG2	(TMU_CSR_BASE_ADDR + 0x054)
+#define TMU_TEQ_HW_PROB_CFG3	(TMU_CSR_BASE_ADDR + 0x058)
+#define TMU_TEQ_HW_PROB_CFG4	(TMU_CSR_BASE_ADDR + 0x05c)
+#define TMU_TEQ_HW_PROB_CFG5	(TMU_CSR_BASE_ADDR + 0x060)
+#define TMU_TEQ_HW_PROB_CFG6	(TMU_CSR_BASE_ADDR + 0x064)
+#define TMU_TEQ_HW_PROB_CFG7	(TMU_CSR_BASE_ADDR + 0x068)
+#define TMU_TEQ_HW_PROB_CFG8	(TMU_CSR_BASE_ADDR + 0x06c)
+#define TMU_TEQ_HW_PROB_CFG9	(TMU_CSR_BASE_ADDR + 0x070)
+#define TMU_TEQ_HW_PROB_CFG10	(TMU_CSR_BASE_ADDR + 0x074)
+#define TMU_TEQ_HW_PROB_CFG11	(TMU_CSR_BASE_ADDR + 0x078)
+#define TMU_TEQ_HW_PROB_CFG12	(TMU_CSR_BASE_ADDR + 0x07c)
+#define TMU_TEQ_HW_PROB_CFG13	(TMU_CSR_BASE_ADDR + 0x080)
+#define TMU_TEQ_HW_PROB_CFG14	(TMU_CSR_BASE_ADDR + 0x084)
+#define TMU_TEQ_HW_PROB_CFG15	(TMU_CSR_BASE_ADDR + 0x088)
+#define TMU_TEQ_HW_PROB_CFG16	(TMU_CSR_BASE_ADDR + 0x08c)
+#define TMU_TEQ_HW_PROB_CFG17	(TMU_CSR_BASE_ADDR + 0x090)
+#define TMU_TEQ_HW_PROB_CFG18	(TMU_CSR_BASE_ADDR + 0x094)
+#define TMU_TEQ_HW_PROB_CFG19	(TMU_CSR_BASE_ADDR + 0x098)
+#define TMU_TEQ_HW_PROB_CFG20	(TMU_CSR_BASE_ADDR + 0x09c)
+#define TMU_TEQ_HW_PROB_CFG21	(TMU_CSR_BASE_ADDR + 0x0a0)
+#define TMU_TEQ_HW_PROB_CFG22	(TMU_CSR_BASE_ADDR + 0x0a4)
+#define TMU_TEQ_HW_PROB_CFG23	(TMU_CSR_BASE_ADDR + 0x0a8)
+#define TMU_TEQ_HW_PROB_CFG24	(TMU_CSR_BASE_ADDR + 0x0ac)
+#define TMU_TEQ_HW_PROB_CFG25	(TMU_CSR_BASE_ADDR + 0x0b0)
+#define TMU_TDQ_IIFG_CFG	(TMU_CSR_BASE_ADDR + 0x0b4)
+/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ.
+ This is a global Enable for all schedulers in PHY0 */
+#define TMU_TDQ0_SCH_CTRL	(TMU_CSR_BASE_ADDR + 0x0b8)
 
-#define TMU_MEM_ACCESS_ADDR		(TMU_CSR_BASE_ADDR + 0x0e4)	/**< [31] Mem Access Command. 0 = Internal Memory Read, 1 = Internal memory Write [27:24] Byte Enables of the Internal memory access [23:0] Address of the internal memory. This address is used to access both the PM and DM of all the PE's */
-#define TMU_MEM_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x0e8)	/**< Internal Memory Access Write Data */
-#define TMU_MEM_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x0ec)	/**< Internal Memory Access Read Data. The commands are blocked at the mem_access only */
+#define TMU_LLM_CTRL	(TMU_CSR_BASE_ADDR + 0x0bc)
+#define TMU_LLM_BASE_ADDR	(TMU_CSR_BASE_ADDR + 0x0c0)
+#define TMU_LLM_QUE_LEN	(TMU_CSR_BASE_ADDR + 0x0c4)
+#define TMU_LLM_QUE_HEADPTR	(TMU_CSR_BASE_ADDR + 0x0c8)
+#define TMU_LLM_QUE_TAILPTR	(TMU_CSR_BASE_ADDR + 0x0cc)
+#define TMU_LLM_QUE_DROPCNT	(TMU_CSR_BASE_ADDR + 0x0d0)
+#define TMU_INT_EN	(TMU_CSR_BASE_ADDR + 0x0d4)
+#define TMU_INT_SRC	(TMU_CSR_BASE_ADDR + 0x0d8)
+#define TMU_INQ_STAT	(TMU_CSR_BASE_ADDR + 0x0dc)
+#define TMU_CTRL	(TMU_CSR_BASE_ADDR + 0x0e0)
 
-#define TMU_PHY0_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f0)	/**< [31:0] PHY0 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
-#define TMU_PHY1_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f4)	/**< [31:0] PHY1 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
-#define TMU_PHY2_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f8)	/**< [31:0] PHY2 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
-#define TMU_PHY3_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0fc)	/**< [31:0] PHY3 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
-#define TMU_BMU_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x100)
-#define TMU_TX_CTRL			(TMU_CSR_BASE_ADDR + 0x104)
+/**< [31] Mem Access Command. 0 = Internal Memory Read, 1 = Internal memory
+* Write [27:24] Byte Enables of the Internal memory access [23:0] Address of
+* the internal memory. This address is used to access both the PM and DM of
+* all the PE's
+*/
+#define TMU_MEM_ACCESS_ADDR	(TMU_CSR_BASE_ADDR + 0x0e4)
+
+/**< Internal Memory Access Write Data */
+#define TMU_MEM_ACCESS_WDATA	(TMU_CSR_BASE_ADDR + 0x0e8)
+/**< Internal Memory Access Read Data. The commands are blocked
+* at the mem_access only
+*/
+#define TMU_MEM_ACCESS_RDATA	(TMU_CSR_BASE_ADDR + 0x0ec)
 
-#define TMU_BUS_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x108)
-#define TMU_BUS_ACCESS			(TMU_CSR_BASE_ADDR + 0x10c)
-#define TMU_BUS_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x110)
+/**< [31:0] PHY0 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY0_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x0f0)
+/**< [31:0] PHY1 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY1_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x0f4)
+/**< [31:0] PHY2 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY2_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x0f8)
+/**< [31:0] PHY3 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY3_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x0fc)
+#define TMU_BMU_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x100)
+#define TMU_TX_CTRL	(TMU_CSR_BASE_ADDR + 0x104)
 
-#define TMU_PE_SYS_CLK_RATIO		(TMU_CSR_BASE_ADDR + 0x114)
-#define TMU_PE_STATUS			(TMU_CSR_BASE_ADDR + 0x118)
-#define TMU_TEQ_MAX_THRESHOLD		(TMU_CSR_BASE_ADDR + 0x11c)
-#define TMU_PHY4_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x134)	/**< [31:0] PHY4 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
-#define TMU_TDQ1_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x138)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY1 */
-#define TMU_TDQ2_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x13c)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY2 */
-#define TMU_TDQ3_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x140)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY3 */
-#define TMU_BMU_BUF_SIZE		(TMU_CSR_BASE_ADDR + 0x144)
-#define TMU_PHY5_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x148)	/**< [31:0] PHY5 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_BUS_ACCESS_WDATA	(TMU_CSR_BASE_ADDR + 0x108)
+#define TMU_BUS_ACCESS	(TMU_CSR_BASE_ADDR + 0x10c)
+#define TMU_BUS_ACCESS_RDATA	(TMU_CSR_BASE_ADDR + 0x110)
+
+#define TMU_PE_SYS_CLK_RATIO	(TMU_CSR_BASE_ADDR + 0x114)
+#define TMU_PE_STATUS	(TMU_CSR_BASE_ADDR + 0x118)
+#define TMU_TEQ_MAX_THRESHOLD	(TMU_CSR_BASE_ADDR + 0x11c)
+/**< [31:0] PHY4 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY4_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x134)
+/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ.
+* This is a global Enable for all schedulers in PHY1
+*/
+#define TMU_TDQ1_SCH_CTRL	(TMU_CSR_BASE_ADDR + 0x138)
+/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ.
+* This is a global Enable for all schedulers in PHY2
+*/
+#define TMU_TDQ2_SCH_CTRL	(TMU_CSR_BASE_ADDR + 0x13c)
+/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ.
+* This is a global Enable for all schedulers in PHY3
+*/
+#define TMU_TDQ3_SCH_CTRL	(TMU_CSR_BASE_ADDR + 0x140)
+#define TMU_BMU_BUF_SIZE	(TMU_CSR_BASE_ADDR + 0x144)
+/**< [31:0] PHY5 in queue address (must be initialized with one of the
+* xxx_INQ_PKTPTR cbus addresses)
+*/
+#define TMU_PHY5_INQ_ADDR	(TMU_CSR_BASE_ADDR + 0x148)
 
 #define SW_RESET	(1 << 0)	/**< Global software reset */
 #define INQ_RESET	(1 << 2)
@@ -121,7 +162,7 @@ typedef struct {
 
 /* Not HW related for pfe_ctrl / pfe common defines */
 #define DEFAULT_MAX_QDEPTH	80
-#define DEFAULT_Q0_QDEPTH	511 //We keep one large queue for host tx qos
+#define DEFAULT_Q0_QDEPTH	511 /*We keep one large queue for host tx qos */
 #define DEFAULT_TMU3_QDEPTH	127
 
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/cbus/util_csr.h b/drivers/staging/fsl_ppfe/include/pfe/cbus/util_csr.h
index 4eff391..52884e6 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/cbus/util_csr.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/cbus/util_csr.h
@@ -1,58 +1,59 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _UTIL_CSR_H_
 #define _UTIL_CSR_H_
 
-#define UTIL_VERSION			(UTIL_CSR_BASE_ADDR + 0x000)
-#define UTIL_TX_CTRL			(UTIL_CSR_BASE_ADDR + 0x004)
-#define UTIL_INQ_PKTPTR			(UTIL_CSR_BASE_ADDR + 0x010)
+#define UTIL_VERSION	(UTIL_CSR_BASE_ADDR + 0x000)
+#define UTIL_TX_CTRL	(UTIL_CSR_BASE_ADDR + 0x004)
+#define UTIL_INQ_PKTPTR	(UTIL_CSR_BASE_ADDR + 0x010)
 
-#define UTIL_HDR_SIZE			(UTIL_CSR_BASE_ADDR + 0x014)
+#define UTIL_HDR_SIZE	(UTIL_CSR_BASE_ADDR + 0x014)
 
-#define UTIL_PE0_QB_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x020)
-#define UTIL_PE0_QB_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x024)
-#define UTIL_PE0_RO_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x060)
-#define UTIL_PE0_RO_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x064)
+#define UTIL_PE0_QB_DM_ADDR0	(UTIL_CSR_BASE_ADDR + 0x020)
+#define UTIL_PE0_QB_DM_ADDR1	(UTIL_CSR_BASE_ADDR + 0x024)
+#define UTIL_PE0_RO_DM_ADDR0	(UTIL_CSR_BASE_ADDR + 0x060)
+#define UTIL_PE0_RO_DM_ADDR1	(UTIL_CSR_BASE_ADDR + 0x064)
 
-#define UTIL_MEM_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x100)
-#define UTIL_MEM_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x104)
-#define UTIL_MEM_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x108)
+#define UTIL_MEM_ACCESS_ADDR	(UTIL_CSR_BASE_ADDR + 0x100)
+#define UTIL_MEM_ACCESS_WDATA	(UTIL_CSR_BASE_ADDR + 0x104)
+#define UTIL_MEM_ACCESS_RDATA	(UTIL_CSR_BASE_ADDR + 0x108)
 
-#define UTIL_TM_INQ_ADDR		(UTIL_CSR_BASE_ADDR + 0x114)
-#define UTIL_PE_STATUS			(UTIL_CSR_BASE_ADDR + 0x118)
+#define UTIL_TM_INQ_ADDR	(UTIL_CSR_BASE_ADDR + 0x114)
+#define UTIL_PE_STATUS	(UTIL_CSR_BASE_ADDR + 0x118)
 
-#define UTIL_PE_SYS_CLK_RATIO		(UTIL_CSR_BASE_ADDR + 0x200)
-#define UTIL_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x204)
-#define UTIL_GAP_BETWEEN_READS		(UTIL_CSR_BASE_ADDR + 0x208)
-#define UTIL_MAX_BUF_CNT		(UTIL_CSR_BASE_ADDR + 0x20c)
-#define UTIL_TSQ_FIFO_THRES		(UTIL_CSR_BASE_ADDR + 0x210)
-#define UTIL_TSQ_MAX_CNT		(UTIL_CSR_BASE_ADDR + 0x214)
-#define UTIL_IRAM_DATA_0		(UTIL_CSR_BASE_ADDR + 0x218)
-#define UTIL_IRAM_DATA_1		(UTIL_CSR_BASE_ADDR + 0x21c)
-#define UTIL_IRAM_DATA_2		(UTIL_CSR_BASE_ADDR + 0x220)
-#define UTIL_IRAM_DATA_3		(UTIL_CSR_BASE_ADDR + 0x224)
+#define UTIL_PE_SYS_CLK_RATIO	(UTIL_CSR_BASE_ADDR + 0x200)
+#define UTIL_AFULL_THRES	(UTIL_CSR_BASE_ADDR + 0x204)
+#define UTIL_GAP_BETWEEN_READS	(UTIL_CSR_BASE_ADDR + 0x208)
+#define UTIL_MAX_BUF_CNT	(UTIL_CSR_BASE_ADDR + 0x20c)
+#define UTIL_TSQ_FIFO_THRES	(UTIL_CSR_BASE_ADDR + 0x210)
+#define UTIL_TSQ_MAX_CNT	(UTIL_CSR_BASE_ADDR + 0x214)
+#define UTIL_IRAM_DATA_0	(UTIL_CSR_BASE_ADDR + 0x218)
+#define UTIL_IRAM_DATA_1	(UTIL_CSR_BASE_ADDR + 0x21c)
+#define UTIL_IRAM_DATA_2	(UTIL_CSR_BASE_ADDR + 0x220)
+#define UTIL_IRAM_DATA_3	(UTIL_CSR_BASE_ADDR + 0x224)
 
-#define UTIL_BUS_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x228)
-#define UTIL_BUS_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x22c)
-#define UTIL_BUS_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x230)
+#define UTIL_BUS_ACCESS_ADDR	(UTIL_CSR_BASE_ADDR + 0x228)
+#define UTIL_BUS_ACCESS_WDATA	(UTIL_CSR_BASE_ADDR + 0x22c)
+#define UTIL_BUS_ACCESS_RDATA	(UTIL_CSR_BASE_ADDR + 0x230)
 
-#define UTIL_INQ_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x234)
+#define UTIL_INQ_AFULL_THRES	(UTIL_CSR_BASE_ADDR + 0x234)
 
 typedef struct {
 	u32 pe_sys_clk_ratio;
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class.h b/drivers/staging/fsl_ppfe/include/pfe/class.h
index b20a1f3..112cc70 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _CLASS_H_
 #define _CLASS_H_
@@ -22,32 +23,36 @@
 #include "pe.h"
 
 #define CLASS_DMEM_BASE_ADDR	0x00000000
-#define CLASS_DMEM_SIZE		0x2000
-#define CLASS_DMEM_END		(CLASS_DMEM_BASE_ADDR + CLASS_DMEM_SIZE)
+#define CLASS_DMEM_SIZE	0x2000
+#define CLASS_DMEM_END	(CLASS_DMEM_BASE_ADDR + CLASS_DMEM_SIZE)
 #define CLASS_PMEM_BASE_ADDR	0x00010000
 
-#define CBUS_BASE_ADDR		0xc0000000
+#define CBUS_BASE_ADDR	0xc0000000
 #define CLASS_APB_BASE_ADDR	0xc1000000
 #define CLASS_AHB1_BASE_ADDR	0xc2000000
 #define CLASS_AHB2_BASE_ADDR	0xc3000000
 
 #include "cbus.h"
 
-#define GPT_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x00000)
-#define UART_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x10000)
-#define PERG_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x20000)
-#define EFET_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x40000)
+#define GPT_BASE_ADDR	(CLASS_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR	(CLASS_APB_BASE_ADDR + 0x10000)
+#define PERG_BASE_ADDR	(CLASS_APB_BASE_ADDR + 0x20000)
+#define EFET_BASE_ADDR	(CLASS_APB_BASE_ADDR + 0x40000)
 
 #define MAC_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x30000)
 #define VLAN_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x50000)
 
 #define PE_LMEM_BASE_ADDR	(CLASS_AHB2_BASE_ADDR + 0x10000)
-#define PE_LMEM_SIZE		0x8000
-#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
-#define CCU_BASE_ADDR		(CLASS_AHB2_BASE_ADDR + 0x20000)
+#define PE_LMEM_SIZE	0x8000
+#define PE_LMEM_END	(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+#define CCU_BASE_ADDR	(CLASS_AHB2_BASE_ADDR + 0x20000)
 
-#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= CLASS_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= CLASS_DMEM_END))
-#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
+#define IS_DMEM(addr, len)    (((unsigned long)(addr) >= CLASS_DMEM_BASE_ADDR) \
+					&& (((unsigned long)(addr) + \
+					(len)) <= CLASS_DMEM_END))
+#define IS_PE_LMEM(addr, len)  (((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) \
+					&& (((unsigned long)(addr) + \
+					(len)) <= PE_LMEM_END))
 
 
 #include "gpt.h"
@@ -63,30 +68,31 @@
 
 #define PBUF_HWPARSE_OFFSET	0x10	/* Fixed by hardware */
 
-#define PAYLOAD_DMEM_MAX_SIZE	(CLASS_PBUF_SIZE - CLASS_PBUF_HEADER_OFFSET - sizeof(class_rx_hdr_t))
+#define PAYLOAD_DMEM_MAX_SIZE	(CLASS_PBUF_SIZE - CLASS_PBUF_HEADER_OFFSET - \
+					sizeof(class_rx_hdr_t))
 
 
-#define MIN_PKT_SIZE		56
+#define MIN_PKT_SIZE	56
 
-#define PARSE_ETH_TYPE		(1 << 0)
-#define PARSE_VLAN_TYPE		(1 << 1)
+#define PARSE_ETH_TYPE	(1 << 0)
+#define PARSE_VLAN_TYPE	(1 << 1)
 #define PARSE_PPPOE_TYPE	(1 << 2)
-#define PARSE_ARP_TYPE		(1 << 3)
+#define PARSE_ARP_TYPE	(1 << 3)
 #define PARSE_MCAST_TYPE	(1 << 4)
-#define PARSE_IP_TYPE		(1 << 5)
-#define PARSE_IPV6_TYPE		(1 << 6)
-#define PARSE_IPV4_TYPE		(1 << 7)
+#define PARSE_IP_TYPE	(1 << 5)
+#define PARSE_IPV6_TYPE	(1 << 6)
+#define PARSE_IPV4_TYPE	(1 << 7)
 
-#define PARSE_IPX_TYPE		(1 << 9)
+#define PARSE_IPX_TYPE	(1 << 9)
 
-#define PARSE_UDP_FLOW		(1 << 11)
-#define PARSE_TCP_FLOW		(1 << 12)
-#define PARSE_ICMP_FLOW		(1 << 13)
-#define PARSE_IGMP_FLOW		(1 << 14)
-#define PARSE_FRAG_FLOW		(1 << 15)
+#define PARSE_UDP_FLOW	(1 << 11)
+#define PARSE_TCP_FLOW	(1 << 12)
+#define PARSE_ICMP_FLOW	(1 << 13)
+#define PARSE_IGMP_FLOW	(1 << 14)
+#define PARSE_FRAG_FLOW	(1 << 15)
 
-#define PARSE_HIF_PKT		(1 << 23)
-#define PARSE_ARC_HIT		(1 << 24)
+#define PARSE_HIF_PKT	(1 << 23)
+#define PARSE_ARC_HIT	(1 << 24)
 #define PARSE_PKT_OVERFLOW	(1 << 25)
 
 #define PARSE_PROTO_MISMATCH	(1 << 28)
@@ -121,13 +127,29 @@ typedef struct _hwparse_t {
 
 
 typedef struct {
-	u8	num_cpy;	/* no of copies to send out from RO block, for each there must be a corresponding tx pre-header */
-	u8	dma_len;	/* len to be DMAed to DDR mem, including all tx pre-headers */
-	u16	src_addr;	/* class dmem source address, pointing to first tx pre-header */
-	u32	dst_addr;	/* DDR memory destination address of first tx pre-header, must be so packet data is continuous in DDR */
-	u32	res1;		/* reserved for software usage - queue number? */
-	u16	res2;		/* reserved for software usage */
-	u16	tsv;		/* time stamp val */
+	u8	num_cpy;	/*
+				* no of copies to send out from RO block,
+				* for each there must be a corresponding
+				* tx pre-header
+				*/
+	u8	dma_len;	/*
+				* len to be DMAed to DDR mem, including
+				* all tx pre-headers
+				*/
+	u16	src_addr;	/*
+				* class dmem source address, pointing
+				* to first tx pre-header
+				*/
+	u32	dst_addr;	/*
+				* DDR memory destination address of first
+				* tx pre-header, must be so packet data is
+				* continuous in DDR
+				*/
+	u32	res1;	/* reserved for software usage -
+			* queue number?
+			*/
+	u16	res2;	/* reserved for software usage */
+	u16	tsv;	/* time stamp val */
 } class_tx_desc_t;
 
 #endif /* _CLASS_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class/ccu.h b/drivers/staging/fsl_ppfe/include/pfe/class/ccu.h
index 7b65717..8d96693 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class/ccu.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class/ccu.h
@@ -1,28 +1,29 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _CCU_H_
 #define _CCU_H_
 
 #define CCU_ADDR	(CCU_BASE_ADDR + 0x00)
-#define CCU_CNT		(CCU_BASE_ADDR + 0x04)
+#define CCU_CNT	(CCU_BASE_ADDR + 0x04)
 #define CCU_STATUS	(CCU_BASE_ADDR + 0x08)
-#define CCU_VAL		(CCU_BASE_ADDR + 0x0c)
+#define CCU_VAL	(CCU_BASE_ADDR + 0x0c)
 
 #endif /* _CCU_H_ */
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class/efet.h b/drivers/staging/fsl_ppfe/include/pfe/class/efet.h
index 15192bd..829a9aa 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class/efet.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class/efet.h
@@ -1,31 +1,32 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _CLASS_EFET_H_
 #define _CLASS_EFET_H_
 
-//#define CLASS_EFET_ASYNC	1
+/*#define CLASS_EFET_ASYNC	1 */
 
-#define CLASS_EFET_ENTRY_ADDR		(EFET_BASE_ADDR + 0x00)
-#define CLASS_EFET_ENTRY_SIZE		(EFET_BASE_ADDR + 0x04)
+#define CLASS_EFET_ENTRY_ADDR	(EFET_BASE_ADDR + 0x00)
+#define CLASS_EFET_ENTRY_SIZE	(EFET_BASE_ADDR + 0x04)
 #define CLASS_EFET_ENTRY_DMEM_ADDR	(EFET_BASE_ADDR + 0x08)
-#define CLASS_EFET_ENTRY_STATUS		(EFET_BASE_ADDR + 0x0c)
-#define CLASS_EFET_ENTRY_ENDIAN		(EFET_BASE_ADDR + 0x10)
+#define CLASS_EFET_ENTRY_STATUS	(EFET_BASE_ADDR + 0x0c)
+#define CLASS_EFET_ENTRY_ENDIAN	(EFET_BASE_ADDR + 0x10)
 
 #define CBUS2DMEM	0
 #define DMEM2CBUS	1
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class/mac_hash.h b/drivers/staging/fsl_ppfe/include/pfe/class/mac_hash.h
index b2860d8..96d52c2 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class/mac_hash.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class/mac_hash.h
@@ -1,40 +1,41 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _MAC_HASH_H_
 #define _MAC_HASH_H_
 
-#define MAC_HASH_REQ1_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x000)
-#define MAC_HASH_REQ2_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x020)
-#define MAC_HASH_REQ3_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x040)
-#define MAC_HASH_REQ4_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x060)
-#define MAC_HASH_REQ5_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x080)
-#define MAC_HASH_REQ6_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0a0)
-#define MAC_HASH_REQ7_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0c0)
-#define MAC_HASH_REQ8_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0e0)
+#define MAC_HASH_REQ1_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ2_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x020)
+#define MAC_HASH_REQ3_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x040)
+#define MAC_HASH_REQ4_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x060)
+#define MAC_HASH_REQ5_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x080)
+#define MAC_HASH_REQ6_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x0a0)
+#define MAC_HASH_REQ7_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x0c0)
+#define MAC_HASH_REQ8_BASE_ADDR	(MAC_HASH_BASE_ADDR + 0x0e0)
 
-#define MAC_HASH_REQ_CMD(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ_CMD(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x000)
 #define MAC_HASH_REQ_MAC1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x004)
 #define MAC_HASH_REQ_MAC2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x008)
 #define MAC_HASH_REQ_MASK1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x00c)
 #define MAC_HASH_REQ_MASK2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x010)
-#define MAC_HASH_REQ_ENTRY(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x014)
-#define MAC_HASH_REQ_STATUS(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define MAC_HASH_REQ_ENTRY(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define MAC_HASH_REQ_STATUS(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x018)
 #define MAC_HASH_REQ_ENTRY_MAYCH(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x01c)
 
 
@@ -43,11 +44,11 @@
 #define MAC_HASH_FREELIST_ENTRIES_ADDR	(MAC_HASH_BASE_ADDR + 0x108)
 
 
-#define HASH_CMD_INIT		1
-#define HASH_CMD_ADD		2
-#define HASH_CMD_DELETE		3
-#define HASH_CMD_UPDATE		4
-#define HASH_CMD_SEARCH		5
+#define HASH_CMD_INIT	1
+#define HASH_CMD_ADD	2
+#define HASH_CMD_DELETE	3
+#define HASH_CMD_UPDATE	4
+#define HASH_CMD_SEARCH	5
 #define HASH_CMD_MEM_READ	6
 #define HASH_CMD_MEM_WRITE	7
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class/perg.h b/drivers/staging/fsl_ppfe/include/pfe/class/perg.h
index 8dcea25..e2f3a2f 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class/perg.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class/perg.h
@@ -1,39 +1,40 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _PERG_H_
 #define _PERG_H_
 
-#define PERG_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x00)
-#define PERG_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x04)
-#define PERG_CLR_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x08)
-#define PERG_SET_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x0c)
-#define PERG_CLR_RO_ERR_PKT		(PERG_BASE_ADDR + 0x10)
-#define PERG_CLR_BMU2_ERR_PKT		(PERG_BASE_ADDR + 0x14)
+#define PERG_QB_BUF_STATUS	(PERG_BASE_ADDR + 0x00)
+#define PERG_RO_BUF_STATUS	(PERG_BASE_ADDR + 0x04)
+#define PERG_CLR_QB_BUF_STATUS	(PERG_BASE_ADDR + 0x08)
+#define PERG_SET_RO_BUF_STATUS	(PERG_BASE_ADDR + 0x0c)
+#define PERG_CLR_RO_ERR_PKT	(PERG_BASE_ADDR + 0x10)
+#define PERG_CLR_BMU2_ERR_PKT	(PERG_BASE_ADDR + 0x14)
 
-#define PERG_ID				(PERG_BASE_ADDR + 0x18)
-#define PERG_TIMER1			(PERG_BASE_ADDR + 0x1c)
-//FIXME #define PERG_TIMER2			(PERG_BASE_ADDR + 0x20)
-#define PERG_BMU1_CURRDEPTH		(PERG_BASE_ADDR + 0x20)
-#define PERG_BMU2_CURRDEPTH		(PERG_BASE_ADDR + 0x24)
-#define PERG_HOST_GP			(PERG_BASE_ADDR + 0x2c)
-#define PERG_PE_GP			(PERG_BASE_ADDR + 0x30)
-#define PERG_INT_ENABLE			(PERG_BASE_ADDR + 0x34)
-#define PERG_INT_SRC			(PERG_BASE_ADDR + 0x38)
+#define PERG_ID	(PERG_BASE_ADDR + 0x18)
+#define PERG_TIMER1	(PERG_BASE_ADDR + 0x1c)
+/*FIXME #define PERG_TIMER2	(PERG_BASE_ADDR + 0x20) */
+#define PERG_BMU1_CURRDEPTH	(PERG_BASE_ADDR + 0x20)
+#define PERG_BMU2_CURRDEPTH	(PERG_BASE_ADDR + 0x24)
+#define PERG_HOST_GP	(PERG_BASE_ADDR + 0x2c)
+#define PERG_PE_GP	(PERG_BASE_ADDR + 0x30)
+#define PERG_INT_ENABLE	(PERG_BASE_ADDR + 0x34)
+#define PERG_INT_SRC	(PERG_BASE_ADDR + 0x38)
 
 #endif /* _PERG_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/class/vlan_hash.h b/drivers/staging/fsl_ppfe/include/pfe/class/vlan_hash.h
index d04d783..288f4a3 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/class/vlan_hash.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/class/vlan_hash.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _VLAN_HASH_H_
 #define _VLAN_HASH_H_
@@ -28,13 +29,13 @@
 #define VLAN_HASH_REQ7_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0c0)
 #define VLAN_HASH_REQ8_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0e0)
 
-#define VLAN_HASH_REQ_CMD(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define VLAN_HASH_REQ_CMD(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x000)
 #define VLAN_HASH_REQ_MAC1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x004)
 #define VLAN_HASH_REQ_MAC2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x008)
 #define VLAN_HASH_REQ_MASK1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x00c)
 #define VLAN_HASH_REQ_MASK2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x010)
-#define VLAN_HASH_REQ_ENTRY(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x014)
-#define VLAN_HASH_REQ_STATUS(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define VLAN_HASH_REQ_ENTRY(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define VLAN_HASH_REQ_STATUS(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x018)
 #define VLAN_HASH_REQ_ENTRY_MAYCH(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x01c)
 
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/gpt.h b/drivers/staging/fsl_ppfe/include/pfe/gpt.h
index 35ad3ff..775f3a8 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/gpt.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/gpt.h
@@ -1,30 +1,31 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _GPT_H_
 #define _GPT_H_
 
-#define GPT_VERSION		 (GPT_BASE_ADDR + 0x00)
-#define GPT_STATUS		 (GPT_BASE_ADDR + 0x04)
-#define GPT_CONFIG		 (GPT_BASE_ADDR + 0x08)
-#define GPT_COUNTER		 (GPT_BASE_ADDR + 0x0c)
-#define GPT_PERIOD		 (GPT_BASE_ADDR + 0x10)
-#define GPT_WIDTH		 (GPT_BASE_ADDR + 0x14)
+#define GPT_VERSION	 (GPT_BASE_ADDR + 0x00)
+#define GPT_STATUS	 (GPT_BASE_ADDR + 0x04)
+#define GPT_CONFIG	 (GPT_BASE_ADDR + 0x08)
+#define GPT_COUNTER	 (GPT_BASE_ADDR + 0x0c)
+#define GPT_PERIOD	 (GPT_BASE_ADDR + 0x10)
+#define GPT_WIDTH	 (GPT_BASE_ADDR + 0x14)
 
 /*** These bits are defined for GPT_STATUS register */
 #define GPT_STAT_IRQ            (1<<0)
diff --git a/drivers/staging/fsl_ppfe/include/pfe/pe.h b/drivers/staging/fsl_ppfe/include/pfe/pe.h
index 94a371d..9e77673 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/pe.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/pe.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _PE_H_
 #define _PE_H_
@@ -53,11 +54,17 @@ enum CLASS_RX_PHY {
 	RX_PHY_2,
 	RX_PHY_HIF,
 	RX_PHY_HIF_NOCPY,
-	RX_PHY_CLASS = 1 << 14, /**< Control bit (in PHYNO field) used to inform CLASS PE that packet comes from Class. */
-	RX_PHY_UTIL = 1 << 15 /**< Control bit (in PHYNO field) used to inform CLASS PE that packet comes from UtilPE. */
+	RX_PHY_CLASS = 1 << 14, /**< Control bit (in PHYNO field) used to
+			  inform CLASS PE that packet comes from Class. */
+	RX_PHY_UTIL = 1 << 15 /**< Control bit (in PHYNO field) used to inform
+				CLASS PE that packet comes from UtilPE. */
 };
 
-#define RX_PHY_SW_INPUT_PORT_OFFSET		11	/**< Offset in PHYNO field where the original input port will be stored for packets coming directly from software (UtilPE or Class). */
+#define RX_PHY_SW_INPUT_PORT_OFFSET	11
+/**< Offset in PHYNO
+* field where the original input port will be stored for packets coming directly
+* from software (UtilPE or Class).
+*/
 
 
 /* CLASS/TMU tx header phy number */
@@ -69,26 +76,28 @@ enum TMU_TX_PHY {
 };
 
 
-// NOTE: Any changes to the following drop counter definitions must also
-//	be reflected in the pfe/pfe.h file and in pfe_ctrl/pfe_sysfs.c.
+/*
+* NOTE: Any changes to the following drop counter definitions must also
+* be reflected in the pfe/pfe.h file and in pfe_ctrl/pfe_sysfs.c.
+*/
 
 #if defined(COMCERTO_2000_CLASS)
 
-#define	CLASS_DROP_ICC			0
+#define	CLASS_DROP_ICC	0
 #define	CLASS_DROP_HOST_PKT_ERROR	1
-#define	CLASS_DROP_RX_ERROR		2
-#define	CLASS_DROP_IPSEC_OUT		3
-#define	CLASS_DROP_IPSEC_IN		4
-#define	CLASS_DROP_EXPT_IPSEC		5
-#define	CLASS_DROP_REASSEMBLY		6
-#define	CLASS_DROP_FRAGMENTER		7
-#define	CLASS_DROP_NATT			8
-#define	CLASS_DROP_SOCKET		9
-#define	CLASS_DROP_MULTICAST		10
-#define	CLASS_DROP_NATPT		11
-#define	CLASS_DROP_TX_DISABLE		12
-
-#define	CLASS_NUM_DROP_COUNTERS		13
+#define	CLASS_DROP_RX_ERROR	2
+#define	CLASS_DROP_IPSEC_OUT	3
+#define	CLASS_DROP_IPSEC_IN	4
+#define	CLASS_DROP_EXPT_IPSEC	5
+#define	CLASS_DROP_REASSEMBLY	6
+#define	CLASS_DROP_FRAGMENTER	7
+#define	CLASS_DROP_NATT	8
+#define	CLASS_DROP_SOCKET	9
+#define	CLASS_DROP_MULTICAST	10
+#define	CLASS_DROP_NATPT	11
+#define	CLASS_DROP_TX_DISABLE	12
+
+#define	CLASS_NUM_DROP_COUNTERS	13
 
 extern U32 drop_counter[CLASS_NUM_DROP_COUNTERS];
 #define	DROP_PACKET(pmtd, counter) free_packet(pmtd, CLASS_DROP_##counter)
@@ -96,16 +105,16 @@ extern U32 drop_counter[CLASS_NUM_DROP_COUNTERS];
 
 #elif defined(COMCERTO_2000_UTIL)
 
-#define	UTIL_DROP_IPSEC_OUT		0
-#define	UTIL_DROP_IPSEC_IN		1
+#define	UTIL_DROP_IPSEC_OUT	0
+#define	UTIL_DROP_IPSEC_IN	1
 #define	UTIL_DROP_IPSEC_RATE_LIMIT	2
-#define	UTIL_DROP_FRAGMENTER		3
-#define	UTIL_DROP_SOCKET		4
-#define	UTIL_DROP_TX_DISABLE		5
-#define	UTIL_DROP_RX_ERROR		6
-#define	UTIL_DROP_NO_MTD		7
+#define	UTIL_DROP_FRAGMENTER	3
+#define	UTIL_DROP_SOCKET	4
+#define	UTIL_DROP_TX_DISABLE	5
+#define	UTIL_DROP_RX_ERROR	6
+#define	UTIL_DROP_NO_MTD	7
 
-#define	UTIL_NUM_DROP_COUNTERS		8
+#define	UTIL_NUM_DROP_COUNTERS	8
 
 extern U32 drop_counter[UTIL_NUM_DROP_COUNTERS];
 #define	DROP_PACKET(pmtd, counter) free_packet(pmtd, UTIL_DROP_##counter)
@@ -115,11 +124,12 @@ extern U32 drop_counter[UTIL_NUM_DROP_COUNTERS];
 
 
 
-#define DDR_BASE_ADDR		0x00020000
-#define DDR_END			0x86000000 /* This includes ACP and IRAM areas */
-#define IRAM_BASE_ADDR		0x83000000
+#define DDR_BASE_ADDR	0x00020000
+#define DDR_END	0x86000000 /* This includes ACP and IRAM areas */
+#define IRAM_BASE_ADDR	0x83000000
 
-#define IS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DDR_END))
+#define IS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_BASE_ADDR) && \
+				(((unsigned long)(addr) + (len)) <= DDR_END))
 /* action bits of act_phyno is defined as follows */
 
 #define ACT_SRC_MAC_REPLACE     (1 << (4 + 0))
@@ -130,65 +140,82 @@ extern U32 drop_counter[UTIL_NUM_DROP_COUNTERS];
 #define ACT_IPCHKSUM_REPLACE    (1 << (4 + 6))
 
 typedef struct {
-	u8	start_data_off;		/* packet data start offset, relative to start of this tx pre-header */
-	u8	start_buf_off;		/* this tx pre-header start offset, relative to start of DDR buffer */
-	u16	pkt_length;		/* total packet length */
-	u8	act_phyno;		/* action / phy number */
-	u8	queueno;		/* queueno */
+	u8	start_data_off;	/*
+				* packet data start offset, relative
+				* to start of this tx pre-header
+				*/
+	u8	start_buf_off;	/*
+				* this tx pre-header start offset,
+				* relative to start of DDR buffer
+				*/
+	u16	pkt_length;	/* total packet length */
+	u8	act_phyno;	/* action / phy number */
+	u8	queueno;	/* queueno */
 	u16	unused;
 } class_tx_hdr_t;
 
 typedef struct {
-	u8	start_data_off;		/* packet data start offset, relative to start of this tx pre-header */
-	u8	start_buf_off;		/* this tx pre-header start offset, relative to start of DDR buffer */
-	u16	pkt_length;		/* total packet length */
-	u8	act_phyno;		/* action / phy number */
-	u8	queueno;		/* queueno */
-	u16	src_mac_msb;		/* indicates src_mac 47:32 */
-	u32	src_mac_lsb;		/* indicates src_mac 31:0 */
-	u32	vlanid;			/* vlanid */
+	u8	start_data_off;	/*
+				* packet data start offset, relative
+				* to start of this tx pre-header
+				*/
+	u8	start_buf_off;	/*
+				* this tx pre-header start offset,
+				* relative to start of DDR buffer
+				*/
+	u16	pkt_length;	/* total packet length */
+	u8	act_phyno;	/* action / phy number */
+	u8	queueno;	/* queueno */
+	u16	src_mac_msb;	/* indicates src_mac 47:32 */
+	u32	src_mac_lsb;	/* indicates src_mac 31:0 */
+	u32	vlanid;	/* vlanid */
 } class_tx_hdr_mc_t;
 
 typedef struct {
-        u32     next_ptr;       /* ptr to the start of the first DDR buffer */
-        u16     length;         /* total packet length */
-        u16     phyno;          /* input physical port number */
-        u32     status;         /* gemac status bits bits[32:63]*/
-        u32     status2;        /* gemac status bits bits[0:31] */
+	u32     next_ptr;       /* ptr to the start of the first DDR buffer */
+	u16     length;         /* total packet length */
+	u16     phyno;          /* input physical port number */
+	u32     status;         /* gemac status bits bits[32:63]*/
+	u32     status2;        /* gemac status bits bits[0:31] */
 } class_rx_hdr_t;
-/* class_rx_hdr status bits  (status0 bits in hardware blocks)
- * from hif_top/dma_dxr_dtx.v
- * STATUS[9:0] is the encoding of bits in the LMEM buffer as seen by the QB block,
- * NOT the encoding of bits as seen by the Class PEs in the DMEM rx header */
-#define STATUS_PARSE_DISABLE		(1 << 0)
-#define STATUS_BRFETCH_DISABLE		(1 << 1)
-#define STATUS_RTFETCH_DISABLE		(1 << 2)
-#define STATUS_DIR_PROC_ID		(1 << 3)
-#define STATUS_CONN_ID_EN		(1 << 4))
-#define STATUS_PE2PROC_ID(x)		(((x) & 7) << 5)
-#define STATUS_LE_DATA			(1 << 8)
-#define STATUS_CHKSUM_EN		(1 << 9)
+/*
+* class_rx_hdr status bits  (status0 bits in hardware blocks)
+* from hif_top/dma_dxr_dtx.v
+* STATUS[9:0] is the encoding of bits in the LMEM buffer as seen by the QB
+* block,
+* NOT the encoding of bits as seen by the Class PEs in the DMEM rx header
+*/
+#define STATUS_PARSE_DISABLE	(1 << 0)
+#define STATUS_BRFETCH_DISABLE	(1 << 1)
+#define STATUS_RTFETCH_DISABLE	(1 << 2)
+#define STATUS_DIR_PROC_ID	(1 << 3)
+#define STATUS_CONN_ID_EN	(1 << 4)
+#define STATUS_PE2PROC_ID(x)	(((x) & 7) << 5)
+#define STATUS_LE_DATA	(1 << 8)
+#define STATUS_CHKSUM_EN	(1 << 9)
 
 /* from gpi/gpi_rmlf.v */
-#define STATUS_CUMULATIVE_ERR		(1 << 16)
-#define STATUS_LENGTH_ERR		(1 << 17)
-#define STATUS_CRC_ERR			(1 << 18)
-#define STATUS_TOO_SHORT_ERR		(1 << 19)
-#define STATUS_TOO_LONG_ERR		(1 << 20)
-#define STATUS_CODE_ERR			(1 << 21)
-#define STATUS_MC_HASH_MATCH		(1 << 22)
+#define STATUS_CUMULATIVE_ERR	(1 << 16)
+#define STATUS_LENGTH_ERR	(1 << 17)
+#define STATUS_CRC_ERR	(1 << 18)
+#define STATUS_TOO_SHORT_ERR	(1 << 19)
+#define STATUS_TOO_LONG_ERR	(1 << 20)
+#define STATUS_CODE_ERR	(1 << 21)
+#define STATUS_MC_HASH_MATCH	(1 << 22)
 #define STATUS_CUMULATIVE_ARC_HIT	(1 << 23)
 #define STATUS_UNICAST_HASH_MATCH	(1 << 24)
 #define STATUS_IP_CHECKSUM_CORRECT	(1 << 25)
 #define STATUS_TCP_CHECKSUM_CORRECT	(1 << 26)
 #define STATUS_UDP_CHECKSUM_CORRECT	(1 << 27)
-#define STATUS_OVERFLOW_ERR		(1 << 28)
+#define STATUS_OVERFLOW_ERR	(1 << 28)
 
 #define UTIL_MAGIC_NUM	0xffd8ffe000104a46
 #define UTIL_DDRC_WA
 
-/* The following structure is filled by class-pe when the packet
- * has to be sent to util-pe, by filling the required information */
+/*
+* The following structure is filled by class-pe when the packet
+* has to be sent to util-pe, by filling the required information
+*/
 typedef struct {
 	u32 mtd_flags : 16;
 	u32 packet_type : 8;
@@ -196,23 +223,27 @@ typedef struct {
 	u32 data_offset : 4;
 	u32 word[MTD_PRIV];
 #ifdef UTIL_DDRC_WA
-	u64 magic_num; // magic_number to verify the data validity in utilpe
+	u64 magic_num; /* magic_number to verify the data validity in utilpe*/
 #endif
-} __attribute__((aligned(8))) util_rx_hdr_t; // Size must be a multiple of 64-bit to allow copies using EFET.
-
-#define UTIL_RX_IPS_IN_PKT		EVENT_IPS_IN
-#define UTIL_RX_IPS_OUT_PKT		EVENT_IPS_OUT
-#define UTIL_RX_RTP_PKT			EVENT_RTP_RELAY
-#define UTIL_RX_RTP_QOS_PKT		EVENT_RTP_QOS
-#define UTIL_RX_FRAG4_PKT		EVENT_FRAG4
-#define UTIL_RX_FRAG6_PKT		EVENT_FRAG6
+} __aligned(8) util_rx_hdr_t;	/*
+				* Size must be a multiple of
+				* 64-bit to allow copies using EFET.
+				*/
+
+#define UTIL_RX_IPS_IN_PKT	EVENT_IPS_IN
+#define UTIL_RX_IPS_OUT_PKT	EVENT_IPS_OUT
+#define UTIL_RX_RTP_PKT	EVENT_RTP_RELAY
+#define UTIL_RX_RTP_QOS_PKT	EVENT_RTP_QOS
+#define UTIL_RX_FRAG4_PKT	EVENT_FRAG4
+#define UTIL_RX_FRAG6_PKT	EVENT_FRAG6
 
-/** Structure passed from UtilPE to Class, stored at the end of the LMEM buffer. Defined and used by software only.
- *
- */
+/*
+* Structure passed from UtilPE to Class, stored at the end of the LMEM
+* buffer. Defined and used by software only.
+*
+*/
 
-typedef struct
-{
+typedef struct {
 	void *next;
 	u16 next_length;
 	u8 next_l3offset;
@@ -228,49 +259,54 @@ typedef struct {
 
 	u16 mtd_flags;
 	union {
-		u16 half[6];
-		u8 byte[12];
-
-		struct {
-			u16 sa_handle[2]; // SA_MAX_OP value should be used here instead of 2
-			u8 proto;
-			S8 sa_op;
-			u8 l2hdr_len;
-			u8 adj_dmem;
-		} ipsec;
-
-		struct {
-			u16 l4offset;
-			u16 socket_id;
-			BOOL update;
-			u8 reserved;
-			u32 payload_diff;
-		} relay;
-
-		struct {
-			u16 l3offset;
-			u16 l4offset;
-
-			frag_info frag;
-		} ipv6;
-
-		struct {
-			u16 l3offset;
-		} ipv4;
-
-		struct {
-			u32 ddr_addr;
-			u16 length;
-			u8 port;
-			u8 queue;
-			u8 action;
-		} tx;
+	u16 half[6];
+	u8 byte[12];
+
+	struct {
+	u16 sa_handle[2]; /*
+			  * SA_MAX_OP value should be used
+			  * here instead of 2
+			  */
+	u8 proto;
+	S8 sa_op;
+	u8 l2hdr_len;
+	u8 adj_dmem;
+	} ipsec;
+
+	struct {
+	u16 l4offset;
+	u16 socket_id;
+	BOOL update;
+	u8 reserved;
+	u32 payload_diff;
+	} relay;
+
+	struct {
+	u16 l3offset;
+	u16 l4offset;
+
+	frag_info frag;
+	} ipv6;
+
+	struct {
+	u16 l3offset;
+	} ipv4;
+
+	struct {
+	u32 ddr_addr;
+	u16 length;
+	u8 port;
+	u8 queue;
+	u8 action;
+	} tx;
 	};
 } lmem_trailer_t;
 
-/* The following values are defined for packet_type of lmem_trailer_t.
- * These represent different types of packets sent from util to class
- * for processing */
+/*
+* The following values are defined for packet_type of lmem_trailer_t.
+* These represent different types of packets sent from util to class
+* for processing
+*/
 enum {
 	UTIL_TX_IPS_IN = 0,
 	UTIL_TX_IPV4_RTP_PKT,
@@ -286,7 +322,8 @@ enum {
 
 
 #define UTIL_TX_TRAILER_SIZE	sizeof(lmem_trailer_t)
-#define UTIL_TX_TRAILER(mtd)	((lmem_trailer_t *)ROUND_UP32((u32)(mtd)->rx_dmem_end))
+#define UTIL_TX_TRAILER(mtd)	((lmem_trailer_t\
+				*)ROUND_UP32((u32)(mtd)->rx_dmem_end))
 
 typedef struct {
 	u32 pkt_ptr;
@@ -295,7 +332,7 @@ typedef struct {
 	u16 len;
 } tmu_tx_hdr_t;
 
-struct hif_pkt_hdr {		
+struct hif_pkt_hdr {
 	u8	client_id;
 	u8	qNo;
 	u16	client_ctrl_le_lsw;
@@ -305,7 +342,10 @@ struct hif_pkt_hdr {
 
 #if defined(CFG_WIFI_OFFLOAD)
 #define	MAX_WIFI_VAPS	3
-#define PFE_WIFI_PKT_HEADROOM	96 /*PFE inserts this headroom for WiFi tx packets only in lro mode */
+#define PFE_WIFI_PKT_HEADROOM	96 /*
+				   * PFE inserts this headroom for WiFi tx
+				   * packets only in lro mode
+				   */
 #else
 #define	MAX_WIFI_VAPS	0
 #endif
@@ -322,25 +362,26 @@ enum HIF_CLIENT_ID {
 };
 
 
-#define IS_WIFI_CLIENT_ID(_clid) (((_clid) >= CLIENT_ID_WIFI0) && ((_clid) <= CLIENT_ID_WIFI_LAST))
+#define IS_WIFI_CLIENT_ID(_clid) (((_clid) >= CLIENT_ID_WIFI0) && ((_clid) <=\
+					CLIENT_ID_WIFI_LAST))
 
 /* These match LE definition */
-#define HIF_CTRL_TX_TSO_NOCPY		__cpu_to_le32(1 << 8)
-#define HIF_CTRL_TX_IPSEC_OUT		__cpu_to_le32(1 << 7)
-#define HIF_CTRL_TX_WIFI_OWNMAC		__cpu_to_le32(1 << 6)
-#define HIF_CTRL_TX_TSO_END		__cpu_to_le32(1 << 5)
-#define HIF_CTRL_TX_TSO6		__cpu_to_le32(1 << 4)
-#define HIF_CTRL_TX_TSO			__cpu_to_le32(1 << 3)
-#define HIF_CTRL_TX_CHECKSUM		__cpu_to_le32(1 << 2)
+#define HIF_CTRL_TX_TSO_NOCPY	__cpu_to_le32(1 << 8)
+#define HIF_CTRL_TX_IPSEC_OUT	__cpu_to_le32(1 << 7)
+#define HIF_CTRL_TX_WIFI_OWNMAC	__cpu_to_le32(1 << 6)
+#define HIF_CTRL_TX_TSO_END	__cpu_to_le32(1 << 5)
+#define HIF_CTRL_TX_TSO6	__cpu_to_le32(1 << 4)
+#define HIF_CTRL_TX_TSO	__cpu_to_le32(1 << 3)
+#define HIF_CTRL_TX_CHECKSUM	__cpu_to_le32(1 << 2)
 #define HIF_CTRL_TX_CSUM_VALIDATE	__cpu_to_le32(1 << 1)
-#define HIF_CTRL_TX_WIFI_TXOFLD		__cpu_to_le32(1 << 0)
-
-#define HIF_CTRL_RX_OFFSET_MASK		__cpu_to_le32(0xf << 24)
-#define HIF_CTRL_RX_PE_ID_MASK		__cpu_to_le32(0xf << 16)
-#define HIF_CTRL_RX_IPSEC_IN		__cpu_to_le32(1 << 4)
-#define HIF_CTRL_RX_WIFI_EXPT		__cpu_to_le32(1 << 3)
-#define HIF_CTRL_RX_CHECKSUMMED		__cpu_to_le32(1 << 2)
-#define HIF_CTRL_RX_CONTINUED		__cpu_to_le32(1 << 1)
+#define HIF_CTRL_TX_WIFI_TXOFLD	__cpu_to_le32(1 << 0)
+
+#define HIF_CTRL_RX_OFFSET_MASK	__cpu_to_le32(0xf << 24)
+#define HIF_CTRL_RX_PE_ID_MASK	__cpu_to_le32(0xf << 16)
+#define HIF_CTRL_RX_IPSEC_IN	__cpu_to_le32(1 << 4)
+#define HIF_CTRL_RX_WIFI_EXPT	__cpu_to_le32(1 << 3)
+#define HIF_CTRL_RX_CHECKSUMMED	__cpu_to_le32(1 << 2)
+#define HIF_CTRL_RX_CONTINUED	__cpu_to_le32(1 << 1)
 #define HIF_CTRL_RX_WIFI_HEADROOM	__cpu_to_le32(1 << 0)
 
 #ifdef CFG_LRO
@@ -379,21 +420,19 @@ struct hif_tso_hdr_nocpy {
 };
 
 struct hif_pcap_hdr {
-        u8      ifindex;
-        u8      unused;
-        u16     seqno;
-        u32     timestamp;
+	u8      ifindex;
+	u8      unused;
+	u16     seqno;
+	u32     timestamp;
 };
 
 
-struct pe_sync_mailbox
-{
+struct pe_sync_mailbox {
 	u32 stop;
 	u32 stopped;
 };
 
-struct pe_msg_mailbox
-{
+struct pe_msg_mailbox {
 	u32 dst;
 	u32 src;
 	u32 len;
@@ -402,23 +441,25 @@ struct pe_msg_mailbox
 
 
 /** Basic busy loop delay function
-*
-* @param cycles		Number of cycles to delay (actual cpu cycles should be close to 3 x cycles)
-*
-*/
+ *
+ * @param cycles	Number of cycles to delay (actual cpu cycles should be
+ * close to 3 x cycles)
+ *
+ */
 static inline void delay(u32 cycles)
 {
 	volatile int i;
 
-	for (i = 0; i < cycles; i++);
+	for (i = 0; i < cycles; i++)
+		;
 }
 
 
 /** Read PE id
-*
-* @return	PE id (0 - 5 for CLASS-PE's, 6 - 9 for TMU-PE's, 10 for UTIL-PE)
-*
-*/
+ *
+ * @return	PE id (0 - 5 for CLASS-PE's, 6 - 9 for TMU-PE's, 10 for UTIL-PE)
+ *
+ */
 static inline u32 esi_get_mpid(void)
 {
 	u32 mpid;
@@ -430,11 +471,11 @@ static inline u32 esi_get_mpid(void)
 
 
 #define esi_get_csr(bank, csr) \
-({ \
-	u32 res; \
-	asm ("rcsr %0, " #bank ", " #csr : "=d" (res)); \
-	res; \
-})
+	({ \
+	 u32 res; \
+	 asm ("rcsr %0, " #bank ", " #csr : "=d" (res)); \
+	 res; \
+	 })
 
 #define esi_get_isa0() esi_get_csr(Configuration, ISA0)
 #define esi_get_isa1() esi_get_csr(Configuration, ISA1)
@@ -449,71 +490,85 @@ static inline void esi_pe_stop(U32 state)
 {
 	PESTATUS_SETSTATE(state);
 	while (1)
-	{
 		asm("stop");
-	}
 }
 
 
 /** Same 64bit alignment memory copy using efet.
-* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
-* Both the source and destination must have the same 64bit alignment, length should be more than four bytes
-* or dst/src must be 32bit aligned. Otherwise use efet_memcpy_any()
-* Uses efet synchronous interface to copy the data.
-*
-* @param dst	Destination address to write to (must have the same 64bit alignment as src)
-* @param src	Source address to read from (must have the same 64bit alignment as dst)
-* @param len	Number of bytes to copy
-*
-*/
+ * Either the source or destination address must be in DMEM, the other address
+ * can be in LMEM or DDR.
+ * Both the source and destination must have the same 64bit alignment, length
+ * should be more than four bytes
+ * or dst/src must be 32bit aligned. Otherwise use efet_memcpy_any()
+ * Uses efet synchronous interface to copy the data.
+ *
+ * @param dst	Destination address to write to (must have the same 64bit
+ * alignment as src)
+ * @param src	Source address to read from (must have the same 64bit alignment
+ * as dst)
+ * @param len	Number of bytes to copy
+ *
+ */
 void efet_memcpy(void *dst, void *src, unsigned int len);
 
 /** Same 64bit alignment memory copy using efet.
-* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
-* Both the source and destination must have the same 64bit alignment, there is no restriction on length.
-* For UTIL-PE revA0, this function will still fail to handle small/unaligned writes.
-* Uses efet synchronous interface to copy the data.
-*
-* @param dst	Destination address to write to (must have the same 64bit alignment as src)
-* @param src	Source address to read from (must have the same 64bit alignment as dst)
-* @param len	Number of bytes to copy
-*
-*/
+ * Either the source or destination address must be in DMEM, the other address
+ * can be in LMEM or DDR.
+ * Both the source and destination must have the same 64bit alignment, there is
+ * no restriction on length.
+ * For UTIL-PE revA0, this function will still fail to handle small/unaligned
+ * writes.
+ * Uses efet synchronous interface to copy the data.
+ *
+ * @param dst	Destination address to write to (must have the same 64bit
+ * alignment as src)
+ * @param src	Source address to read from (must have the same 64bit alignment
+ * as dst)
+ * @param len	Number of bytes to copy
+ *
+ */
 void efet_memcpy_any(void *dst, void *src, unsigned int len);
 
 /** Same 64bit alignment memory copy using efet.
-* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
-* Both the source and destination must have the same 64bit alignment, length should be more than four bytes
-* or dst/src must be 32bit aligned.
-* Uses efet asynchronous interface to copy the data.
-*
-* @param dst	Destination address to write to (must have the same 64bit alignment as src)
-* @param src	Source address to read from (must have the same 64bit alignment as dst)
-* @param len	Number of bytes to copy
-*
-*/
+ * Either the source or destination address must be in DMEM, the other address
+ * can be in LMEM or DDR.
+ * Both the source and destination must have the same 64bit alignment, length
+ * should be more than four bytes
+ * or dst/src must be 32bit aligned.
+ * Uses efet asynchronous interface to copy the data.
+ *
+ * @param dst	Destination address to write to (must have the same 64bit
+ * alignment as src)
+ * @param src	Source address to read from (must have the same 64bit alignment
+ * as dst)
+ * @param len	Number of bytes to copy
+ *
+ */
 void efet_memcpy_nowait(void *dst, void *src, unsigned int len);
 
 /** Unaligned memory copy using efet.
-* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
-* There is not restriction on source and destination, nor on length.
-*
-* @param dst		Destination address to write to
-* @param src		Source address to read from
-* @param len		Number of bytes to copy
-* @param dmem_buf	temp dmem buffer to use, must be 64bit aligned
-* @param dmem_len	length of dmem buffer, must be 64bit aligned and at least 16 bytes
-*
-*/
-void efet_memcpy_unaligned(void *dst, void *src, unsigned int len, void *dmem_buf, unsigned int dmem_len);
+ * Either the source or destination address must be in DMEM, the other address
+ * can be in LMEM or DDR.
+ * There is not restriction on source and destination, nor on length.
+ *
+ * @param dst	Destination address to write to
+ * @param src	Source address to read from
+ * @param len	Number of bytes to copy
+ * @param dmem_buf	temp dmem buffer to use, must be 64bit aligned
+ * @param dmem_len	length of dmem buffer, must be 64bit aligned and at
+ * least 16 bytes
+ *
+ */
+void efet_memcpy_unaligned(void *dst, void *src, unsigned int len, void
+	*dmem_buf, unsigned int dmem_len);
 
 /** Aligned memory copy of 4 bytes to register address.
-* Register address must be 32 bit aligned.
-*
-* @param val		value to be copied.       
-* @param reg_addr	Register address (must be 16bit aligned)
-*
-*/
+ * Register address must be 32 bit aligned.
+ *
+ * @param val	value to be copied.
+ * @param reg_addr	Register address (must be 16bit aligned)
+ *
+ */
 void __efet_writel(u32 val, void *addr);
 
 #ifdef REVA_WA
@@ -524,103 +579,115 @@ void __efet_writel(u32 val, void *addr);
 
 
 /** 32bit aligned memory copy.
-* Source and destination addresses must be 32bit aligned, there is no restriction on the length.
-*
-* @param dst		Destination address (must be 32bit aligned)
-* @param src		Source address (must be 32bit aligned)
-* @param len		Number of bytes to copy
-*
-*/
+ * Source and destination addresses must be 32bit aligned, there is no
+ * restriction on the length.
+ *
+ * @param dst	Destination address (must be 32bit aligned)
+ * @param src	Source address (must be 32bit aligned)
+ * @param len	Number of bytes to copy
+ *
+ */
 void memcpy_aligned32(void *dst, void *src, unsigned int len);
 
 /** Aligned memory copy.
-* Source and destination addresses must have the same alignment
-* relative to 32bit boundaries (but otherwsie may have any alignment),
-* there is no restriction on the length.
-*
-* @param dst		Destination address
-* @param src		Source address (must have same 32bit alignment as dst)
-* @param len		Number of bytes to copy
-*
-*/
+ * Source and destination addresses must have the same alignment
+ * relative to 32bit boundaries (but otherwsie may have any alignment),
+ * there is no restriction on the length.
+ *
+ * @param dst	Destination address
+ * @param src	Source address (must have same 32bit alignment as dst)
+ * @param len	Number of bytes to copy
+ *
+ */
 void memcpy_aligned(void *dst, void *src, unsigned int len);
 
 /** Unaligned memory copy.
-* Implements unaligned memory copy. We first align the destination
-* to a 32bit boundary (using byte copies) then the src, and finally use a loop
-* of read, shift, write
-*
-* @param dst		Destination address
-* @param src		Source address (must have same 32bit alignment as dst)
-* @param len		Number of bytes to copy
-*
-*/
+ * Implements unaligned memory copy. We first align the destination
+ * to a 32bit boundary (using byte copies) then the src, and finally use a loop
+ * of read, shift, write
+ *
+ * @param dst	Destination address
+ * @param src	Source address (must have same 32bit alignment as dst)
+ * @param len	Number of bytes to copy
+ *
+ */
 void memcpy_unaligned(void *dst, void *src, unsigned int len);
 
 /** Generic memory set.
-* Implements a generic memory set. Not very optimal (uses byte writes for the entire range)
-*
-*
-* @param dst		Destination address
-* @param val		Value to set memory to
-* @param len		Number of bytes to set
-*
-*/
+ * Implements a generic memory set. Not very optimal (uses byte writes for the
+ * entire range)
+ *
+ *
+ * @param dst	Destination address
+ * @param val	Value to set memory to
+ * @param len	Number of bytes to set
+ *
+ */
 void memset(void *dst, u8 val, unsigned int len);
 
 /** Generic memory copy.
-* Implements generic memory copy. If source and destination have the same
-* alignment memcpy_aligned() is used, otherwise memcpy_unaligned()
-*
-* @param dst		Destination address
-* @param src		Source address
-* @param len		Number of bytes to copy
-*
-*/
+ * Implements generic memory copy. If source and destination have the same
+ * alignment memcpy_aligned() is used, otherwise memcpy_unaligned()
+ *
+ * @param dst	Destination address
+ * @param src	Source address
+ * @param len	Number of bytes to copy
+ *
+ */
 void memcpy(void *dst, void *src, unsigned int len);
 
 /** Generic memorymove.
-* Implements generic memorymove, where copies across overlapping
-* memory regions is supported.
-* Uses the dmem_buf passed as a parameter as a temporary buffer.
-* Includes two copies, forces one of the copies to be definitely aligned.
-* The "dmem_len" being passed should be atleast 3 bytes greater than "len"
-* The 3 bytes here are shift bytes used to ensure one aligned copy.
-*
-* @param dst		Destination address
-* @param src		Source address
-* @param len		Number of bytes to copy
-* @param dmem_buf	temp dmem buffer to use, must be 32bit aligned
-* @param dmem_len	length of dmem buffer, must be 32bit aligned and at least 3 bytes greater
-*			than @param len
-*
-*/
+ * Implements generic memorymove, where copies across overlapping
+ * memory regions is supported.
+ * Uses the dmem_buf passed as a parameter as a temporary buffer.
+ * Includes two copies, forces one of the copies to be definitely aligned.
+ * The "dmem_len" being passed should be atleast 3 bytes greater than "len"
+ * The 3 bytes here are shift bytes used to ensure one aligned copy.
+ *
+ * @param dst	Destination address
+ * @param src	Source address
+ * @param len	Number of bytes to copy
+ * @param dmem_buf	temp dmem buffer to use, must be 32bit aligned
+ * @param dmem_len	length of dmem buffer, must be 32bit aligned and at
+ * least 3 bytes greater
+ *	than @param len
+ *
+ */
 
-void *memorymove(void * dst, void * src, unsigned int len, void *dmem_buf, unsigned int dmem_len);
+void *memorymove(void *dst, void *src, unsigned int len, void *dmem_buf,
+	unsigned int dmem_len);
 
 /** Aligned memory copy in DDR memory.
- * Implements aligned memory copy between two DDR buffers using efet_memcpy64 and DMEM
- * Both the source and destination must have the same 64bit alignment, there is no restriction on length.
- * If start or end are not 64bit aligned, data in destination buffer before start/after end will be corrupted.
+ * Implements aligned memory copy between two DDR buffers using efet_memcpy64
+ * and DMEM
+ * Both the source and destination must have the same 64bit alignment, there is
+ * no restriction on length.
+ * If start or end are not 64bit aligned, data in destination buffer before
+ * start/after end will be corrupted.
  *
- * @param dst 		DDR Destination address
- * @param src		DDR Source address
- * @param len		Number of bytes to copy
+ * @param dst	DDR Destination address
+ * @param src	DDR Source address
+ * @param len	Number of bytes to copy
  * @param dmem_buf	temp dmem buffer to use, must be 64bit aligned
- * @param dmem_len	length of dmem buffer, must be 64bit aligned and at least 16 bytes
+ * @param dmem_len	length of dmem buffer, must be 64bit aligned and at
+ * least 16 bytes
  */
-void memcpy_ddr_to_ddr(void *dst, void *src, unsigned int len, void *dmem_buf, unsigned int dmem_len);
+void memcpy_ddr_to_ddr(void *dst, void *src, unsigned int len, void *dmem_buf,
+	unsigned int dmem_len);
 
 /** Unaligned memory copy in DDR memory.
- * Implements generic memory copy between two DDR buffers using efet_memcpy and DMEM
+ * Implements generic memory copy between two DDR buffers using efet_memcpy and
+ * DMEM
  * There is no restriction on the source, destination and length alignments.
  *
- * @param dst 		DDR Destination address
- * @param src		DDR Source address
- * @param len		Number of bytes to copy
+ * @param dst	DDR Destination address
+ * @param src	DDR Source address
+ * @param len	Number of bytes to copy
  * @param dmem_buf	temp dmem buffer to use, must be 64bit aligned
- * @param dmem_len	length of dmem buffer, must be 64bit aligned and at least 16 bytes
+ * @param dmem_len	length of dmem buffer, must be 64bit aligned and at
+ least 16 bytes
  */
-void memcpy_ddr_to_ddr_unaligned(void *dst, void *src, unsigned int len, void *dmem_buf, unsigned int dmem_len);
+void memcpy_ddr_to_ddr_unaligned(void *dst, void *src, unsigned int len, void
+	*dmem_buf, unsigned int dmem_len);
 
 #endif /* _PE_H_ */
diff --git a/drivers/staging/fsl_ppfe/include/pfe/pfe.h b/drivers/staging/fsl_ppfe/include/pfe/pfe.h
index ff122e6..7d3ac28 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/pfe.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/pfe.h
@@ -1,60 +1,80 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _PFE_H_
 #define _PFE_H_
 
 #define CLASS_DMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20))
-#define CLASS_IMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20)) /* Only valid for mem access register interface */
-#define CLASS_DMEM_SIZE		0x00002000
-#define CLASS_IMEM_SIZE		0x00008000
+/*
+* Only valid for mem access register interface
+*/
+#define CLASS_IMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20))
+#define CLASS_DMEM_SIZE	0x00002000
+#define CLASS_IMEM_SIZE	0x00008000
 
 #define TMU_DMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20))
-#define TMU_IMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20)) /* Only valid for mem access register interface */
-#define TMU_DMEM_SIZE		0x00000800
-#define TMU_IMEM_SIZE		0x00002000
+/*
+* Only valid for mem access register interface
+*/
+#define TMU_IMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20))
+#define TMU_DMEM_SIZE	0x00000800
+#define TMU_IMEM_SIZE	0x00002000
 
 #define UTIL_DMEM_BASE_ADDR	0x00000000
-#define UTIL_DMEM_SIZE		0x00002000
+#define UTIL_DMEM_SIZE	0x00002000
 
 #define PE_LMEM_BASE_ADDR	0xc3010000
-#define PE_LMEM_SIZE		0x8000
-#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+#define PE_LMEM_SIZE	0x8000
+#define PE_LMEM_END	(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
 
-#define DMEM_BASE_ADDR		0x00000000
-#define DMEM_SIZE		0x2000		/**< TMU has less... */
-#define DMEM_END		(DMEM_BASE_ADDR + DMEM_SIZE)
+#define DMEM_BASE_ADDR	0x00000000
+#define DMEM_SIZE	0x2000	/**< TMU has less... */
+#define DMEM_END	(DMEM_BASE_ADDR + DMEM_SIZE)
 
-#define PMEM_BASE_ADDR		0x00010000
-#define PMEM_SIZE		0x8000		/**< TMU has less... */
-#define PMEM_END		(PMEM_BASE_ADDR + PMEM_SIZE)
+#define PMEM_BASE_ADDR	0x00010000
+#define PMEM_SIZE	0x8000	/**< TMU has less... */
+#define PMEM_END	(PMEM_BASE_ADDR + PMEM_SIZE)
 
 
 /* These check memory ranges from PE point of view/memory map */
-#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DMEM_END))
-#define IS_PMEM(addr, len)	(((unsigned long)(addr) >= PMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PMEM_END))
-#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
-
-#define IS_PFE_LMEM(addr, len)	(((unsigned long)(addr) >= CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR)) && (((unsigned long)(addr) + (len)) <= CBUS_VIRT_TO_PFE(LMEM_END)))
-#define __IS_PHYS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_PHYS_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DDR_PHYS_END))
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= DMEM_BASE_ADDR) && \
+				(((unsigned long)(addr) + (len)) <= DMEM_END))
+#define IS_PMEM(addr, len)	(((unsigned long)(addr) >= PMEM_BASE_ADDR) && \
+				(((unsigned long)(addr) + (len)) <= PMEM_END))
+#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) \
+				&& (((unsigned long)(addr) + \
+				(len)) <= PE_LMEM_END))
+
+#define IS_PFE_LMEM(addr, len)	(((unsigned long)(addr) >= \
+					CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR)) && \
+					(((unsigned long)(addr) + (len)) <= \
+					CBUS_VIRT_TO_PFE(LMEM_END)))
+
+#define __IS_PHYS_DDR(addr, len)	(((unsigned long)(addr) >= \
+						DDR_PHYS_BASE_ADDR) &&\
+					(((unsigned long)(addr) + (len)) <= \
+					DDR_PHYS_END))
 #define IS_PHYS_DDR(addr, len)	__IS_PHYS_DDR(DDR_PFE_TO_PHYS(addr), len)
 
-/* If using a run-time virtual address for the cbus base address use this code */
+/*
+* If using a run-time virtual address for the cbus base address use this code
+*/
 extern void *cbus_base_addr;
 extern void *ddr_base_addr;
 extern unsigned long ddr_phys_base_addr;
@@ -62,44 +82,57 @@ extern unsigned int ddr_size;
 
 #if defined(COMCERTO_2000_CONTROL)
 #include <linux/version.h>
-#if defined (CONFIG_PLATFORM_C2000)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+#if defined(CONFIG_PLATFORM_C2000)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 /*This is copied from arch/arm/include/asm/system_info.h */
 extern unsigned int system_rev;
 #endif
 #endif
 #endif
 
-#define CBUS_BASE_ADDR		cbus_base_addr
+#define CBUS_BASE_ADDR	cbus_base_addr
 #define DDR_PHYS_BASE_ADDR	ddr_phys_base_addr
-#define DDR_BASE_ADDR		ddr_base_addr
-#define DDR_SIZE		ddr_size
+#define DDR_BASE_ADDR	ddr_base_addr
+#define DDR_SIZE	ddr_size
 
 #define DDR_PHYS_END	(DDR_PHYS_BASE_ADDR + DDR_SIZE)
 
 #if defined(CONFIG_PLATFORM_C2000)
-#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address as seen by PE's. */
+#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address
+						  as seen by PE's. */
 #define DDR_PHYS_TO_PFE(p)	(p)
 #define DDR_PFE_TO_PHYS(p)	(p)
 #define CBUS_PHYS_TO_PFE(p)	(p)
 #else
-#define LS1012A_PFE_RESET_WA	/*PFE doesn't have global reset and re-init should takecare few things to make PFE functional after reset */
-#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address as seen by PE's. */
-#define PFE_CBUS_PHYS_BASE_ADDR_FROM_PFE	0xc0000000	/**< CBUS physical base address as seen by PE's. */
+#define LS1012A_PFE_RESET_WA	/*
+				* PFE doesn't have global reset and re-init
+				* should takecare few things to make PFE
+				* functional after reset
+				*/
+#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address
+						as seen by PE's. */
+/**< CBUS physical base address as seen by PE's. */
+#define PFE_CBUS_PHYS_BASE_ADDR_FROM_PFE	0xc0000000
+
 #define DDR_PHYS_TO_PFE(p)	(((unsigned long int) (p)) & 0x7FFFFFFF)
 #define DDR_PFE_TO_PHYS(p)	(((unsigned long int) (p)) | 0x80000000)
-#define CBUS_PHYS_TO_PFE(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + PFE_CBUS_PHYS_BASE_ADDR_FROM_PFE) /*Translates to PFE address map */
+#define CBUS_PHYS_TO_PFE(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + \
+				PFE_CBUS_PHYS_BASE_ADDR_FROM_PFE)
+/*Translates to PFE address map */
 #endif
 
 #define DDR_PHYS_TO_VIRT(p)	(((p) - DDR_PHYS_BASE_ADDR) + DDR_BASE_ADDR)
 #define DDR_VIRT_TO_PHYS(v)	(((v) - DDR_BASE_ADDR) + DDR_PHYS_BASE_ADDR)
 #define DDR_VIRT_TO_PFE(p)	(DDR_PHYS_TO_PFE(DDR_VIRT_TO_PHYS(p)))
 
-#define CBUS_VIRT_TO_PFE(v)	(((v) - CBUS_BASE_ADDR) + PFE_CBUS_PHYS_BASE_ADDR)
-#define CBUS_PFE_TO_VIRT(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + CBUS_BASE_ADDR)
+#define CBUS_VIRT_TO_PFE(v)	(((v) - CBUS_BASE_ADDR) + \
+				PFE_CBUS_PHYS_BASE_ADDR)
+#define CBUS_PFE_TO_VIRT(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + \
+				CBUS_BASE_ADDR)
 
 /* The below part of the code is used in QOS control driver from host */
-#define TMU_APB_BASE_ADDR       0xc1000000      /** TMU base address seen by pe's */
+#define TMU_APB_BASE_ADDR       0xc1000000      /** TMU base address seen by
+						pe's */
 
 #define SHAPER0_BASE_ADDR       (TMU_APB_BASE_ADDR + 0x020000)
 #define SHAPER1_BASE_ADDR       (TMU_APB_BASE_ADDR + 0x030000)
@@ -121,10 +154,16 @@ extern unsigned int system_rev;
 #define SCHED6_BASE_ADDR        (TMU_APB_BASE_ADDR + 0x220000)
 #define SCHED7_BASE_ADDR        (TMU_APB_BASE_ADDR + 0x230000)
 
+/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1,
+TMU2->PHY2, TMU3->PHY3), [6:0] winner input queue number */
 #define PHY_QUEUE_BASE_ADDR     (TMU_APB_BASE_ADDR + 0x260000)
-#define QUEUE_RESULT0           (PHY_QUEUE_BASE_ADDR + 0x48)    /**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY3), [6:0] winner input queue number */
-#define QUEUE_RESULT1           (PHY_QUEUE_BASE_ADDR + 0x4c)    /**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number */
-#define QUEUE_RESULT2           (PHY_QUEUE_BASE_ADDR + 0x50)    /**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY5), [6:0] winner input queue number */
+/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1,
+TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number */
+#define QUEUE_RESULT0           (PHY_QUEUE_BASE_ADDR + 0x48)
+/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1,
+TMU2->PHY2, TMU3->PHY5),[6:0] winner input queue number */
+#define QUEUE_RESULT1           (PHY_QUEUE_BASE_ADDR + 0x4c)
+#define QUEUE_RESULT2           (PHY_QUEUE_BASE_ADDR + 0x50)
 
 #define QUEUE_RESULT0_REGOFFSET	(QUEUE_RESULT0 - QUEUE_RESULT0)
 #define QUEUE_RESULT1_REGOFFSET	(QUEUE_RESULT1 - QUEUE_RESULT0)
@@ -163,18 +202,23 @@ enum {
 };
 
 #if !defined(CONFIG_PLATFORM_PCI)
-#define CLASS_MASK	((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID) | (1 << CLASS4_ID) | (1 << CLASS5_ID))
+#define CLASS_MASK	((1 << CLASS0_ID) | (1 << CLASS1_ID) |\
+			(1 << CLASS2_ID) | (1 << CLASS3_ID) |\
+			(1 << CLASS4_ID) | (1 << CLASS5_ID))
 #define CLASS_MAX_ID	CLASS5_ID
 #else
-#define CLASS_MASK      ((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID))
+#define CLASS_MASK      ((1 << CLASS0_ID) | (1 << CLASS1_ID) |\
+			(1 << CLASS2_ID) | (1 << CLASS3_ID))
 #define CLASS_MAX_ID	CLASS3_ID
 #endif
 
 #if !defined(CONFIG_TMU_DUMMY)
 #if defined(CONFIG_PLATFORM_LS1012A)
-#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) | (1 << TMU3_ID))
+#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) |\
+			(1 << TMU3_ID))
 #else
-#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) | (1 << TMU2_ID) | (1 << TMU3_ID))
+#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) |\
+			(1 << TMU2_ID) | (1 << TMU3_ID))
 #endif
 #define TMU_MAX_ID	TMU3_ID
 #else
@@ -186,14 +230,13 @@ enum {
 #define UTIL_MASK	(1 << UTIL_ID)
 #endif
 
-typedef struct tPE_STATUS
-{
+typedef struct tPE_STATUS {
 	u32	cpu_state;
 	u32	activity_counter;
 	u32	rx;
 	union {
-		u32	tx;
-		u32	tmu_qstatus;
+	u32	tx;
+	u32	tmu_qstatus;
 	};
 	u32	drop;
 #if defined(CFG_PE_DEBUG)
@@ -203,42 +246,44 @@ typedef struct tPE_STATUS
 } __attribute__((aligned(16))) PE_STATUS;
 
 
-struct pe_sync_mailbox
-{
+struct pe_sync_mailbox {
 	u32 stop;
 	u32 stopped;
 };
 
-struct pe_msg_mailbox
-{
+struct pe_msg_mailbox {
 	u32 dst;
 	u32 src;
 	u32 len;
 	u32 request;
 };
 
-// Drop counter definitions
+/* Drop counter definitions */
 
-#define	CLASS_NUM_DROP_COUNTERS		13
-#define	UTIL_NUM_DROP_COUNTERS		8
+#define	CLASS_NUM_DROP_COUNTERS	13
+#define	UTIL_NUM_DROP_COUNTERS	8
 
 
 /** PE information.
- * Structure containing PE's specific information. It is used to create
- * generic C functions common to all PE's.
- * Before using the library functions this structure needs to be initialized with the different registers virtual addresses
- * (according to the ARM MMU mmaping). The default initialization supports a virtual == physical mapping.
- *
- */
-struct pe_info
-{
-	u32 dmem_base_addr;		/**< PE's dmem base address */
-	u32 pmem_base_addr;		/**< PE's pmem base address */
-	u32 pmem_size;			/**< PE's pmem size */
-
-	void *mem_access_wdata;		/**< PE's _MEM_ACCESS_WDATA register address */
-	void *mem_access_addr;		/**< PE's _MEM_ACCESS_ADDR register address */
-	void *mem_access_rdata;		/**< PE's _MEM_ACCESS_RDATA register address */
+* Structure containing PE's specific information. It is used to create
+* generic C functions common to all PE's.
+* Before using the library functions this structure needs to be initialized
+with the different registers virtual addresses
+* (according to the ARM MMU mmaping). The default initialization supports a
+virtual == physical mapping.
+*
+*/
+struct pe_info {
+	u32 dmem_base_addr;	/**< PE's dmem base address */
+	u32 pmem_base_addr;	/**< PE's pmem base address */
+	u32 pmem_size;	/**< PE's pmem size */
+
+	void *mem_access_wdata;	/**< PE's _MEM_ACCESS_WDATA register
+				  address */
+	void *mem_access_addr;	/**< PE's _MEM_ACCESS_ADDR register
+				  address */
+	void *mem_access_rdata;	/**< PE's _MEM_ACCESS_RDATA register
+				  address */
 };
 
 
@@ -258,36 +303,39 @@ void class_bus_write(u32 val, u32 addr, u8 size);
 u32 class_bus_read(u32 addr, u8 size);
 
 
-#define class_bus_readl(addr)			class_bus_read(addr, 4)
-#define class_bus_readw(addr)			class_bus_read(addr, 2)
-#define class_bus_readb(addr)			class_bus_read(addr, 1)
+#define class_bus_readl(addr)	class_bus_read(addr, 4)
+#define class_bus_readw(addr)	class_bus_read(addr, 2)
+#define class_bus_readb(addr)	class_bus_read(addr, 1)
 
-#define class_bus_writel(val, addr)		class_bus_write(val, addr, 4)
-#define class_bus_writew(val, addr)		class_bus_write(val, addr, 2)
-#define class_bus_writeb(val, addr)		class_bus_write(val, addr, 1)
+#define class_bus_writel(val, addr)	class_bus_write(val, addr, 4)
+#define class_bus_writew(val, addr)	class_bus_write(val, addr, 2)
+#define class_bus_writeb(val, addr)	class_bus_write(val, addr, 1)
 
-#define pe_dmem_readl(id, addr)			pe_dmem_read(id, addr, 4)
-#define pe_dmem_readw(id, addr)			pe_dmem_read(id, addr, 2)
-#define pe_dmem_readb(id, addr)			pe_dmem_read(id, addr, 1)
+#define pe_dmem_readl(id, addr)	pe_dmem_read(id, addr, 4)
+#define pe_dmem_readw(id, addr)	pe_dmem_read(id, addr, 2)
+#define pe_dmem_readb(id, addr)	pe_dmem_read(id, addr, 1)
 
-#define pe_dmem_writel(id, val, addr)		pe_dmem_write(id, val, addr, 4)
-#define pe_dmem_writew(id, val, addr)		pe_dmem_write(id, val, addr, 2)
-#define pe_dmem_writeb(id, val, addr)		pe_dmem_write(id, val, addr, 1)
+#define pe_dmem_writel(id, val, addr)	pe_dmem_write(id, val, addr, 4)
+#define pe_dmem_writew(id, val, addr)	pe_dmem_write(id, val, addr, 2)
+#define pe_dmem_writeb(id, val, addr)	pe_dmem_write(id, val, addr, 1)
 
-//int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr);
-int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr, struct device *dev);
+/*int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr); */
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr, struct
+				device * dev);
 
-void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base, unsigned int ddr_size);
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base,
+				unsigned int ddr_size);
 void bmu_init(void *base, BMU_CFG *cfg);
 void bmu_reset(void *base);
 void bmu_enable(void *base);
 void bmu_disable(void *base);
 void bmu_set_config(void *base, BMU_CFG *cfg);
 
-/* An enumerated type for loopback values.  This can be one of three values, no
- * loopback -normal operation, local loopback with internal loopback module of
- * MAC or PHY loopback which is through the external PHY.
- */
+/*
+* An enumerated type for loopback values.  This can be one of three values, no
+* loopback -normal operation, local loopback with internal loopback module of
+* MAC or PHY loopback which is through the external PHY.
+*/
 #ifndef __MAC_LOOP_ENUM__
 #define __MAC_LOOP_ENUM__
 typedef enum {LB_NONE, LB_EXT, LB_LOCAL} MAC_LOOP;
@@ -307,7 +355,7 @@ void gemac_disable(void *base);
 void gemac_reset(void *base);
 void gemac_set_address(void *base, SPEC_ADDR *addr);
 SPEC_ADDR gemac_get_address(void *base);
-void gemac_set_loop( void *base, MAC_LOOP gem_loop );
+void gemac_set_loop(void *base, MAC_LOOP gem_loop);
 void gemac_set_laddr1(void *base, MAC_ADDR *address);
 void gemac_set_laddr2(void *base, MAC_ADDR *address);
 void gemac_set_laddr3(void *base, MAC_ADDR *address);
@@ -318,8 +366,8 @@ void gemac_clear_laddr2(void *base);
 void gemac_clear_laddr3(void *base);
 void gemac_clear_laddr4(void *base);
 void gemac_clear_laddrN(void *base, unsigned int entry_index);
-MAC_ADDR gemac_get_hash( void *base );
-void gemac_set_hash( void *base, MAC_ADDR *hash );
+MAC_ADDR gemac_get_hash(void *base);
+void gemac_set_hash(void *base, MAC_ADDR *hash);
 MAC_ADDR gem_get_laddr1(void *base);
 MAC_ADDR gem_get_laddr2(void *base);
 MAC_ADDR gem_get_laddr3(void *base);
@@ -390,10 +438,10 @@ void hif_rx_disable(void);
 
 static inline unsigned int CHIP_REVISION(void)
 {
-#if defined (CONFIG_PLATFORM_C2000)
+#if defined(CONFIG_PLATFORM_C2000)
 #if 1
 	return system_rev;
-	//return 0;
+	/*return 0; */
 #else
 	return (readl(COMCERTO_GPIO_DEVICE_ID_REG) >> 24) & 0xf;
 #endif
@@ -428,7 +476,8 @@ static inline void hif_tx_dma_start(void)
 static inline void hif_nocpy_rx_dma_start(void)
 {
 	/*TODO not sure poll_cntrl_en is required or not */
-	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB), HIF_NOCPY_RX_CTRL);
+	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB),
+	HIF_NOCPY_RX_CTRL);
 }
 
 /** Start HIF_NOCPY tx DMA
diff --git a/drivers/staging/fsl_ppfe/include/pfe/tmu.h b/drivers/staging/fsl_ppfe/include/pfe/tmu.h
index a4a9992..c1a5368 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/tmu.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/tmu.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _TMU_H_
 #define _TMU_H_
@@ -22,15 +23,15 @@
 #define TMU_DMEM_BASE_ADDR	0x00000000
 #define TMU_PMEM_BASE_ADDR	0x00010000
 
-#define CBUS_BASE_ADDR		0xc0000000
+#define CBUS_BASE_ADDR	0xc0000000
 #define TMU_APB_BASE_ADDR	0xc1000000
 
-#if defined (COMCERTO_2000_TMU) || defined (COMCERTO_2000_CONTROL)
+#if defined(COMCERTO_2000_TMU) || defined(COMCERTO_2000_CONTROL)
 
 #include "cbus.h"
 
-#define GPT_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x00000)
-#define UART_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x10000)
+#define GPT_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x10000)
 
 #define SHAPER0_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x020000)
 #define SHAPER1_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x030000)
@@ -52,7 +53,8 @@
 #define SCHED6_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x220000)
 #define SCHED7_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x230000)
 
-#define SHAPER_STATUS		(TMU_APB_BASE_ADDR + 0x270000) /**< [9:0] bitmask of shapers that have positive credit */
+/**< [9:0] bitmask of shapers that have positive credit */
+#define SHAPER_STATUS	(TMU_APB_BASE_ADDR + 0x270000)
 
 #include "gpt.h"
 #include "uart.h"
diff --git a/drivers/staging/fsl_ppfe/include/pfe/tmu/phy_queue.h b/drivers/staging/fsl_ppfe/include/pfe/tmu/phy_queue.h
index 744244c..fbab272 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/tmu/phy_queue.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/tmu/phy_queue.h
@@ -1,47 +1,62 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _PHY_QUEUE_H_
 #define _PHY_QUEUE_H_
 
-#define PHY_QUEUE_SHAPER_STATUS	(PHY_QUEUE_BASE_ADDR + 0x00)	/**< [28:19] same as SHAPER_STATUS, [18:3] same as QUEUE_STATUS, [2:0] must be zero before a new packet may be dequeued */
-#define QUEUE_STATUS		(PHY_QUEUE_BASE_ADDR + 0x04)	/**< [15:0] bit mask of input queues with pending packets */
+/**< [28:19] same as SHAPER_STATUS, [18:3] same as QUEUE_STATUS,
+* [2:0] must be zero before a new packet may be dequeued
+*/
+#define PHY_QUEUE_SHAPER_STATUS	(PHY_QUEUE_BASE_ADDR + 0x00)
+/**< [15:0] bit mask of input queues with pending packets */
+#define QUEUE_STATUS	(PHY_QUEUE_BASE_ADDR + 0x04)
 
-#define QUEUE0_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x08)
-#define QUEUE1_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x0c)
-#define QUEUE2_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x10)
-#define QUEUE3_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x14)
-#define QUEUE4_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x18)
-#define QUEUE5_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x1c)
-#define QUEUE6_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x20)
-#define QUEUE7_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x24)
-#define QUEUE8_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x28)
-#define QUEUE9_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x2c)
-#define QUEUE10_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x30)
-#define QUEUE11_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x34)
-#define QUEUE12_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x38)
-#define QUEUE13_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x3c)
-#define QUEUE14_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x40)
-#define QUEUE15_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x44)
-#define QUEUE_RESULT0		(PHY_QUEUE_BASE_ADDR + 0x48)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY3), [6:0] winner input queue number */
-#define QUEUE_RESULT1		(PHY_QUEUE_BASE_ADDR + 0x4c)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number */
-#define QUEUE_RESULT2		(PHY_QUEUE_BASE_ADDR + 0x50)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY5), [6:0] winner input queue number */
-#define TMU_PE_GP_REG		(PHY_QUEUE_BASE_ADDR + 0x54)
+#define QUEUE0_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x08)
+#define QUEUE1_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x0c)
+#define QUEUE2_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x10)
+#define QUEUE3_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x14)
+#define QUEUE4_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x18)
+#define QUEUE5_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x1c)
+#define QUEUE6_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x20)
+#define QUEUE7_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x24)
+#define QUEUE8_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x28)
+#define QUEUE9_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x2c)
+#define QUEUE10_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x30)
+#define QUEUE11_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x34)
+#define QUEUE12_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x38)
+#define QUEUE13_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x3c)
+#define QUEUE14_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x40)
+#define QUEUE15_PKT_LEN	(PHY_QUEUE_BASE_ADDR + 0x44)
+/**< [7] set to one to indicate output PHY
+* (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY3), [6:0] winner
+* input queue number
+*/
+#define QUEUE_RESULT0	(PHY_QUEUE_BASE_ADDR + 0x48)
+/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1,
+* TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number
+*/
+#define QUEUE_RESULT1	(PHY_QUEUE_BASE_ADDR + 0x4c)
+/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1,
+* TMU2->PHY2, TMU3->PHY5), [6:0] winner input queue number
+*/
+#define QUEUE_RESULT2	(PHY_QUEUE_BASE_ADDR + 0x50)
+#define TMU_PE_GP_REG	(PHY_QUEUE_BASE_ADDR + 0x54)
 #define QUEUE_GBL_PKTLEN	(PHY_QUEUE_BASE_ADDR + 0x5c)
 #define QUEUE_GBL_PKTLEN_MASK	(PHY_QUEUE_BASE_ADDR + 0x60)
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/tmu/sched.h b/drivers/staging/fsl_ppfe/include/pfe/tmu/sched.h
index 9da9eda..62b0f37 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/tmu/sched.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/tmu/sched.h
@@ -1,58 +1,59 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _SCHED_H_
 #define _SCHED_H_
 
 /* Offsets from SCHEDx_BASE_ADDR */
-#define SCHED_CTRL			0x00
-#define SCHED_SLOT_TIME			0x04
-#define SCHED_RES			0x08
-#define SCHED_QUEUE_ALLOC0		0x0c
-#define SCHED_QUEUE_ALLOC1		0x10
-#define SCHED_BW			0x14
-#define SCHED_GUR_DEF_CTR		0x18
-#define SCHED_AVL_CTR			0x1c
-#define SCHED_QU0_WGHT			0x20
-#define SCHED_QU1_WGHT			0x24
-#define SCHED_QU2_WGHT			0x28
-#define SCHED_QU3_WGHT			0x2c
-#define SCHED_QU4_WGHT			0x30
-#define SCHED_QU5_WGHT			0x34
-#define SCHED_QU6_WGHT			0x38
-#define SCHED_QU7_WGHT			0x3c
-#define SCHED_QUE0_DEFICIT_CNT		0x40
-#define SCHED_QUE1_DEFICIT_CNT		0x44
-#define SCHED_QUE2_DEFICIT_CNT		0x48
-#define SCHED_QUE3_DEFICIT_CNT		0x4c
-#define SCHED_QUE4_DEFICIT_CNT		0x50
-#define SCHED_QUE5_DEFICIT_CNT		0x54
-#define SCHED_QUE6_DEFICIT_CNT		0x58
-#define SCHED_QUE7_DEFICIT_CNT		0x5c
-#define SCHED_PKT_LEN			0x60
+#define SCHED_CTRL	0x00
+#define SCHED_SLOT_TIME	0x04
+#define SCHED_RES	0x08
+#define SCHED_QUEUE_ALLOC0	0x0c
+#define SCHED_QUEUE_ALLOC1	0x10
+#define SCHED_BW	0x14
+#define SCHED_GUR_DEF_CTR	0x18
+#define SCHED_AVL_CTR	0x1c
+#define SCHED_QU0_WGHT	0x20
+#define SCHED_QU1_WGHT	0x24
+#define SCHED_QU2_WGHT	0x28
+#define SCHED_QU3_WGHT	0x2c
+#define SCHED_QU4_WGHT	0x30
+#define SCHED_QU5_WGHT	0x34
+#define SCHED_QU6_WGHT	0x38
+#define SCHED_QU7_WGHT	0x3c
+#define SCHED_QUE0_DEFICIT_CNT	0x40
+#define SCHED_QUE1_DEFICIT_CNT	0x44
+#define SCHED_QUE2_DEFICIT_CNT	0x48
+#define SCHED_QUE3_DEFICIT_CNT	0x4c
+#define SCHED_QUE4_DEFICIT_CNT	0x50
+#define SCHED_QUE5_DEFICIT_CNT	0x54
+#define SCHED_QUE6_DEFICIT_CNT	0x58
+#define SCHED_QUE7_DEFICIT_CNT	0x5c
+#define SCHED_PKT_LEN	0x60
 
-#define SCHED_CTRL_ALGOTYPE(x) 		(((x) & 0xf) << 0)
-#define SCHED_CTRL_CALQUOTA(x) 		(((x) & 0x1) << 4)
-#define SCHED_CTRL_ACTIVE_Q(x) 		(((x) & 0xff) << 8)
-#define SCHED_CTRL_SHARE_BW(x) 		(((x) & 0xff) << 16)
-#define SCHED_CTRL_BARROW_BW(x) 	(((x) & 0xff) << 24)
+#define SCHED_CTRL_ALGOTYPE(x)	(((x) & 0xf) << 0)
+#define SCHED_CTRL_CALQUOTA(x)	(((x) & 0x1) << 4)
+#define SCHED_CTRL_ACTIVE_Q(x)	(((x) & 0xff) << 8)
+#define SCHED_CTRL_SHARE_BW(x)	(((x) & 0xff) << 16)
+#define SCHED_CTRL_BARROW_BW(x)	(((x) & 0xff) << 24)
 
-#define SCHED_QUEUE_ALLOC(x, b)	 	(((x) & 0x1f) << (b))
+#define SCHED_QUEUE_ALLOC(x, b)	(((x) & 0x1f) << (b))
 
 #define SCHED_QUEUE_ALLOC0_QUEUEA(x)	(((x) & 0x1f) << 0)
 #define SCHED_QUEUE_ALLOC0_QUEUEB(x)	(((x) & 0x1f) << 8)
diff --git a/drivers/staging/fsl_ppfe/include/pfe/tmu/shaper.h b/drivers/staging/fsl_ppfe/include/pfe/tmu/shaper.h
index 17f9611..8842f10 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/tmu/shaper.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/tmu/shaper.h
@@ -1,36 +1,37 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _SHAPER_H_
 #define _SHAPER_H_
 
 /* Offsets from SHAPPERx_BASE_ADDR */
-#define SHAPER_CTRL		0x00
-#define SHAPER_WEIGHT		0x04
-#define SHAPER_PKT_LEN		0x08
+#define SHAPER_CTRL	0x00
+#define SHAPER_WEIGHT	0x04
+#define SHAPER_PKT_LEN	0x08
 
-#define SHAPER_CTRL_ENABLE(x) 	(((x) & 0x1) << 0)
-#define SHAPER_CTRL_QNO(x) 	(((x) & 0x3f) << 1)
-#define SHAPER_CTRL_CLKDIV(x) 	(((x) & 0xffff) << 16)
+#define SHAPER_CTRL_ENABLE(x)	(((x) & 0x1) << 0)
+#define SHAPER_CTRL_QNO(x)	(((x) & 0x3f) << 1)
+#define SHAPER_CTRL_CLKDIV(x)	(((x) & 0xffff) << 16)
 
-#define SHAPER_WEIGHT_FRACWT(x) 	(((x) & 0xff) << 0)
-#define SHAPER_WEIGHT_INTWT(x) 		(((x) & 0x3) << 8)
-#define SHAPER_WEIGHT_MAXCREDIT(x) 	(((x) & 0x3fffff) << 10)
+#define SHAPER_WEIGHT_FRACWT(x)	(((x) & 0xff) << 0)
+#define SHAPER_WEIGHT_INTWT(x)	(((x) & 0x3) << 8)
+#define SHAPER_WEIGHT_MAXCREDIT(x)	(((x) & 0x3fffff) << 10)
 
 #define PORT_SHAPER_MASK (1 << 0)
 
diff --git a/drivers/staging/fsl_ppfe/include/pfe/uart.h b/drivers/staging/fsl_ppfe/include/pfe/uart.h
index 43a7cdd..d66ecb6 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/uart.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/uart.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _UART_H_
 #define _UART_H_
diff --git a/drivers/staging/fsl_ppfe/include/pfe/util.h b/drivers/staging/fsl_ppfe/include/pfe/util.h
index c0e848e..0f6f948 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/util.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/util.h
@@ -1,42 +1,45 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _UTIL_H_
 #define _UTIL_H_
 
 #define UTIL_DMEM_BASE_ADDR	0x00000000
-#define UTIL_DMEM_SIZE		0x00002000
-#define UTIL_DMEM_END		(UTIL_DMEM_BASE_ADDR + UTIL_DMEM_SIZE)
+#define UTIL_DMEM_SIZE	0x00002000
+#define UTIL_DMEM_END	(UTIL_DMEM_BASE_ADDR + UTIL_DMEM_SIZE)
 
-#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= UTIL_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= UTIL_DMEM_END))
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= UTIL_DMEM_BASE_ADDR)\
+				&& (((unsigned long)(addr) + (len)) \
+				<= UTIL_DMEM_END))
 
-#define CBUS_BASE_ADDR		0xc0000000
+#define CBUS_BASE_ADDR	0xc0000000
 #define UTIL_APB_BASE_ADDR	0xc1000000
 
 #include "cbus.h"
 
-#define GPT_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x00000)
-#define UART_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x10000)
-#define EAPE_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x20000)
-#define INQ_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x30000)
-#define EFET1_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x40000)
-#define EFET2_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x50000)
-#define EFET3_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x60000)
+#define GPT_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x10000)
+#define EAPE_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x20000)
+#define INQ_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x30000)
+#define EFET1_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x40000)
+#define EFET2_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x50000)
+#define EFET3_BASE_ADDR	(UTIL_APB_BASE_ADDR + 0x60000)
 
 
 #include "gpt.h"
diff --git a/drivers/staging/fsl_ppfe/include/pfe/util/eape.h b/drivers/staging/fsl_ppfe/include/pfe/util/eape.h
index 16c4328..8e2eb7c 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/util/eape.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/util/eape.h
@@ -1,31 +1,33 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _EAPE_H_
 #define _EAPE_H_
 
-#define EAPE_STATUS		(EAPE_BASE_ADDR + 0x0)
-#define EAPE_INT_ENABLE		(EAPE_BASE_ADDR + 0x4)
-#define EAPE_INT_SRC		(EAPE_BASE_ADDR + 0x8)
+#define EAPE_STATUS	(EAPE_BASE_ADDR + 0x0)
+#define EAPE_INT_ENABLE	(EAPE_BASE_ADDR + 0x4)
+#define EAPE_INT_SRC	(EAPE_BASE_ADDR + 0x8)
 #define EAPE_HOST_INT_ENABLE	(EAPE_BASE_ADDR + 0xc)
 
 /** The following bits represents to enable interrupts from host and to host
-* from / to utilpe */
+* from  to utilpe
+*/
 
 #define IRQ_EN_EFET_TO_UTIL	0x1
 #define IRQ_EN_QB_TO_UTIL	0x2
@@ -38,17 +40,18 @@
 
 /** Out interrupts */
 
-#define IRQ_EN_EFET_OUT		0x100
-#define IRQ_EN_QB_OUT		0x200
-#define IRQ_EN_INQ_OUT		0x400
-#define IRQ_EN_EAPE_OUT		0x800
+#define IRQ_EN_EFET_OUT	0x100
+#define IRQ_EN_QB_OUT	0x200
+#define IRQ_EN_INQ_OUT	0x400
+#define IRQ_EN_EAPE_OUT	0x800
 #define IRQ_EN_GPT_TMR_OUT	0x1000
-#define IRQ_EN_UART_OUT		0x2000
+#define IRQ_EN_UART_OUT	0x2000
 #define IRQ_EN_SYSLP_OUT	0x4000
 #define IRQ_EN_UPEGP_OUT	0x8000
 
 /** The following bits are enabled in the status register
- * which are mapped to IPSEC status register bits */
+ * which are mapped to IPSEC status register bits
+*/
 #define EAPE_IN_STAT_AVAIL      0x1
 #define EAPE_OUT_STAT_AVAIL     0x2
 #define EAPE_IN_CMD_AVAIL       0x4
diff --git a/drivers/staging/fsl_ppfe/include/pfe/util/efet.h b/drivers/staging/fsl_ppfe/include/pfe/util/efet.h
index 20ac41b..15da824 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/util/efet.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/util/efet.h
@@ -1,26 +1,27 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _UTIL_EFET_H_
 #define _UTIL_EFET_H_
 
-#define EFET_ENTRY_ADDR		0x00
-#define EFET_ENTRY_SIZE		0x04
+#define EFET_ENTRY_ADDR	0x00
+#define EFET_ENTRY_SIZE	0x04
 #define EFET_ENTRY_DMEM_ADDR	0x08
 #define EFET_ENTRY_STATUS	0x0c
 #define EFET_ENTRY_ENDIAN	0x10
@@ -30,70 +31,77 @@
 
 #define EFET2BUS_LE     (1 << 0)
 
-#define EFET1		0
-#define EFET2		1
-#define EFET3		2
+#define EFET1	0
+#define EFET2	1
+#define EFET3	2
 #define MAX_UTIL_EFET_LEN	128
 
 extern const unsigned long util_efet_baseaddr[3];
 extern u32 util_efet_status;
 
-/* The barrier call is an empirical work-around for an unknown bug: for some unknown reason, it solves
- * a UtilPE crash observed with LRO and packet steering. Other solutions also worked (e.g. barrier,
- * nop calls in other positions). However, no common pattern could be extracted from those solutions
- * to narrow down the source of the crash.
- */
+/*
+* The barrier call is an empirical work-around for an unknown bug: for some
+* unknown reason, it solves a UtilPE crash observed with LRO and packet
+* steering. Other solutions also worked (e.g. barrier,nop calls in other
+* positions). However, no common pattern could be extracted from those
+* solutions to narrow down the source of the crash.
+*/
 
-#define __UTIL_EFET(i, cbus_addr, dmem_addr,len,dir) do { \
-	__writel((len & 0x3FF) | (dir << 16), util_efet_baseaddr[i] + EFET_ENTRY_SIZE); \
+#define __UTIL_EFET(i, cbus_addr, dmem_addr, len, dir) do { \
+	__writel((len & 0x3FF) | (dir << 16),\
+			util_efet_baseaddr[i] + EFET_ENTRY_SIZE); \
 	__writel(dmem_addr, util_efet_baseaddr[i] + EFET_ENTRY_DMEM_ADDR);\
 	__writel(cbus_addr, util_efet_baseaddr[i] + EFET_ENTRY_ADDR);\
 	nop();\
-	}while(0)
+} while (0)
 
-#define UTIL_EFET(i, cbus_addr, dmem_addr,len,dir) do { \
+#define UTIL_EFET(i, cbus_addr, dmem_addr, len, dir) do { \
 	__UTIL_EFET(i, cbus_addr, dmem_addr, len, dir);	\
-	util_efet_status |= (1 << i);			\
-	} while(0)
+	util_efet_status |= (1 << i);	\
+} while (0)
 
 
 /** Waits for the util efet to finish a transaction, blocking the caller
-* (without updating the status).
-* Can be called at any time.
-*
-* @param i      Efet index
-*
-*
-*/
+ * (without updating the status).
+ * Can be called at any time.
+ *
+ * @param i      Efet index
+ *
+ *
+ */
 static inline void __util_efet_wait(int i)
 {
-        while (!(readl(util_efet_baseaddr[i] + EFET_ENTRY_STATUS) & 0x1)) ;
+	while (!(readl(util_efet_baseaddr[i] + EFET_ENTRY_STATUS) & 0x1))
+		;
 }
 
 /** Waits for the util efet to finish a transaction, blocking the caller.
-* Can be called at any time.
-*
-* @param i      Efet index
-*
-*/
+ * Can be called at any time.
+ *
+ * @param i      Efet index
+ *
+ */
 static inline void util_efet_wait(int i)
 {
 	__util_efet_wait(i);
-	
+
 	util_efet_status &= ~(1 << i);
 }
 
 /** Asynchronous interface to util efet read/write functions.
-* It will wait for the efet to finish previous transaction, but does not wait for the current transaction to finish.
-*
-* @param i              Efet index
-* @param cbus_addr      Cbus address (must be 64bits aligned)
-* @param dmem_addr      DMEM address (must be 64bits aligned)
-* @param len            Number of bytes to copy (must be 64bits aligned size)
-* @param dir            Direction of the transaction (0 - cbus to dmem, 1 - dmem to cbus)
-*
-*/
-static inline void util_efet_async(int i, u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir)
+ * It will wait for the efet to finish previous transaction,
+ * but does not wait for the current transaction to finish.
+ *
+ * @param i              Efet index
+ * @param cbus_addr      Cbus address (must be 64bits aligned)
+ * @param dmem_addr      DMEM address (must be 64bits aligned)
+ * @param len            Number of bytes to copy (must be 64bits aligned size)
+ * @param dir            Direction of the transaction
+ *			 (0 - cbus to dmem, 1 - dmem to cbus)
+ *
+ */
+static inline void util_efet_async(int i, u32 cbus_addr, u32 dmem_addr,
+		u32 len, u8 dir)
 {
 	if (util_efet_status & (1 << i))
 		util_efet_wait(i);
@@ -102,18 +110,19 @@ static inline void util_efet_async(int i, u32 cbus_addr, u32 dmem_addr, u32 len,
 }
 
 
-static inline void util_efet_async0( u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir)
+static inline void util_efet_async0(u32 cbus_addr, u32 dmem_addr,
+		u32 len, u8 dir)
 {
-	util_efet_async(0, cbus_addr, dmem_addr, len,dir);
+	util_efet_async(0, cbus_addr, dmem_addr, len, dir);
 }
 
 /* EFET 2 is aways used for SYNC operations */
-static inline void util_efet_sync2(u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir)
+static inline void util_efet_sync2(u32 cbus_addr, u32 dmem_addr,
+		u32 len, u8 dir)
 {
-	__UTIL_EFET(2, cbus_addr, dmem_addr, len,dir);
+	__UTIL_EFET(2, cbus_addr, dmem_addr, len, dir);
 	__util_efet_wait(2);
 }
 
 void util_efet_sync0(u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir);
 #endif /* _UTIL_EFET_H_ */
-
diff --git a/drivers/staging/fsl_ppfe/include/pfe/util/inq.h b/drivers/staging/fsl_ppfe/include/pfe/util/inq.h
index 89140fc..f599fba 100644
--- a/drivers/staging/fsl_ppfe/include/pfe/util/inq.h
+++ b/drivers/staging/fsl_ppfe/include/pfe/util/inq.h
@@ -1,20 +1,21 @@
 /*
- *  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- *
+*  Copyright (c) 2011, 2014 Freescale Semiconductor, Inc.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License
+*  as published by the Free Software Foundation; either version 2
+*  of the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 51 Franklin Street, Fifth Floor,
+*  Boston, MA  02110-1301, USA.
+*
 */
 #ifndef _INQ_H_
 #define _INQ_H_
diff --git a/drivers/staging/fsl_ppfe/pfe_ctrl.c b/drivers/staging/fsl_ppfe/pfe_ctrl.c
index 6306b78..f21718d 100644
--- a/drivers/staging/fsl_ppfe/pfe_ctrl.c
+++ b/drivers/staging/fsl_ppfe/pfe_ctrl.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifdef __KERNEL__
 #include <linux/kernel.h>
@@ -51,7 +51,7 @@ static u32 UTIL_DMEM_SH2(resume);
 
 static int pfe_ctrl_timer(void *data);
 
-static int initialized = 0;
+static int initialized;
 
 #define TIMEOUT_MS	1000
 
@@ -59,15 +59,14 @@ int relax(unsigned long end)
 {
 #ifdef __KERNEL__
 	if (time_after(jiffies, end)) {
-		if (time_after(jiffies, end + (TIMEOUT_MS * HZ) / 1000)) {
+		if (time_after(jiffies, end + (TIMEOUT_MS * HZ) / 1000))
 			return -1;
-		}
 
 		if (need_resched())
 			schedule();
 	}
 #else
-                udelay(1);
+	udelay(1);
 #endif
 
 	return 0;
@@ -84,17 +83,21 @@ void pfe_ctrl_suspend(struct pfe_ctrl *ctrl)
 
 	initialized = 0;
 	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++)
-			pe_dmem_write(id, cpu_to_be32(0x1), (unsigned long)virt_to_class_dmem(&class_resume), 4);
+			pe_dmem_write(id, cpu_to_be32(0x1), (unsigned
+				long)virt_to_class_dmem(&class_resume), 4);
 
 	for (id = TMU0_ID; id <= TMU_MAX_ID; id++) {
 #if defined(CONFIG_PLATFORM_LS1012A)
-		if(id == TMU2_ID) continue;
+		if (id == TMU2_ID)
+			continue;
 #endif
-		pe_dmem_write(id, cpu_to_be32(0x1), (unsigned long)virt_to_class_dmem(&tmu_resume), 4);
+		pe_dmem_write(id, cpu_to_be32(0x1), (unsigned
+				long)virt_to_class_dmem(&tmu_resume), 4);
 	}
 
 #if !defined(CONFIG_UTIL_DISABLED)
-	pe_dmem_write(UTIL_ID, cpu_to_be32(0x1), (unsigned long)virt_to_class_dmem(&util_resume), 4);
+	pe_dmem_write(UTIL_ID, cpu_to_be32(0x1), (unsigned
+			long)virt_to_class_dmem(&util_resume), 4);
 #endif
 
 	pe_sync_stop(&pfe->ctrl, 0xFF);
@@ -109,7 +112,8 @@ void pfe_ctrl_resume(struct pfe_ctrl *ctrl)
 	pe_start(&pfe->ctrl, 0xFF);
 	mutex_unlock(&ctrl->mutex);
 
-	ctrl->timer_thread = kthread_create(pfe_ctrl_timer, ctrl, "pfe_ctrl_timer");
+	ctrl->timer_thread = kthread_create(pfe_ctrl_timer, ctrl,
+						"pfe_ctrl_timer");
 
 	wake_up_process(ctrl->timer_thread);
 }
@@ -131,14 +135,15 @@ int pe_sync_stop(struct pfe_ctrl *ctrl, int pe_mask)
 	int i;
 
 #if defined(CONFIG_PLATFORM_LS1012A)
-	//TODO Util should be removed after IPSec is ported
-	pe_mask &= 0x2FF;  //Exclude Util + TMU2 
+	/*TODO Util should be removed after IPSec is ported */
+	pe_mask &= 0x2FF;  /*Exclude Util + TMU2 */
 #endif
 	for (i = 0; i < MAX_PE; i++)
 		if (pe_mask & (1 << i)) {
 			mbox = (void *)ctrl->sync_mailbox_baseaddr[i];
 
-			pe_dmem_write(i, cpu_to_be32(0x1), (unsigned long)&mbox->stop, 4);
+			pe_dmem_write(i, cpu_to_be32(0x1), (unsigned
+					long)&mbox->stop, 4);
 		}
 
 	while (pe_stopped != pe_mask) {
@@ -146,7 +151,9 @@ int pe_sync_stop(struct pfe_ctrl *ctrl, int pe_mask)
 			if ((pe_mask & (1 << i)) && !(pe_stopped & (1 << i))) {
 				mbox = (void *)ctrl->sync_mailbox_baseaddr[i];
 
-				if (pe_dmem_read(i, (unsigned long)&mbox->stopped, 4) & cpu_to_be32(0x1))
+				if (pe_dmem_read(i, (unsigned
+					long)&mbox->stopped, 4) &
+					cpu_to_be32(0x1))
 					pe_stopped |= (1 << i);
 			}
 
@@ -163,7 +170,8 @@ err:
 		if (pe_mask & (1 << i)) {
 			mbox = (void *)ctrl->sync_mailbox_baseaddr[i];
 
-			pe_dmem_write(i, cpu_to_be32(0x0), (unsigned long)&mbox->stop, 4);
+			pe_dmem_write(i, cpu_to_be32(0x0), (unsigned
+					long)&mbox->stop, 4);
 	}
 
 	return -EIO;
@@ -183,20 +191,23 @@ void pe_start(struct pfe_ctrl *ctrl, int pe_mask)
 	int i;
 
 #if defined(CONFIG_PLATFORM_LS1012A)
-	//TODO Util should be removed after IPSec is ported
-	pe_mask &= 0x2FF;  //Exclude Util + TMU2 
+	/*TODO Util should be removed after IPSec is ported */
+	pe_mask &= 0x2FF;  /*Exclude Util + TMU2 */
 #endif
 	for (i = 0; i < MAX_PE; i++)
 		if (pe_mask & (1 << i)) {
 
 			mbox = (void *)ctrl->sync_mailbox_baseaddr[i];
 
-			pe_dmem_write(i, cpu_to_be32(0x0), (unsigned long)&mbox->stop, 4);
+			pe_dmem_write(i, cpu_to_be32(0x0), (unsigned
+					long)&mbox->stop, 4);
 		}
 }
 
 
-/** Sends a control request to a given PE (to copy data to/from internal memory from/to DDR).
+/** Sends a control request to a given PE (to copy data to/from internal memory
+* from/to DDR).
+*
 * The caller must hold ctrl->mutex.
 *
 * @param ctrl		Control context
@@ -206,7 +217,8 @@ void pe_start(struct pfe_ctrl *ctrl, int pe_mask)
 * @param len		Data length
 *
 */
-int pe_request(struct pfe_ctrl *ctrl, int id, unsigned short cmd_type, unsigned long dst, unsigned long src, int len)
+int pe_request(struct pfe_ctrl *ctrl, int id, unsigned short cmd_type, unsigned
+			long dst, unsigned long src, int len)
 {
 	struct pe_msg_mailbox mbox = {
 		.dst = cpu_to_be32(dst),
@@ -221,7 +233,8 @@ int pe_request(struct pfe_ctrl *ctrl, int id, unsigned short cmd_type, unsigned
 	/* This works because .request is written last */
 	pe_dmem_memcpy_to32(id, (unsigned long)pmbox, &mbox, sizeof(mbox));
 
-	while ((rc = pe_dmem_read(id, (unsigned long)&pmbox->request, 4)) & cpu_to_be32(0xffff)) {
+	while ((rc = pe_dmem_read(id, (unsigned long)&pmbox->request, 4)) &
+			cpu_to_be32(0xffff)) {
 		if (relax(end) < 0)
 			goto err;
 	}
@@ -239,12 +252,14 @@ err:
 
 /** Control code timer thread.
 *
-* A kernel thread is used so that the timer code can be run under the control path mutex.
-* The thread wakes up regularly and checks if any timer in the timer list as expired.
-* The timers are re-started automatically.
-* The code tries to keep the number of times a timer runs per unit time constant on average,
-* if the thread scheduling is delayed, it's possible for a particular timer to be scheduled in
-* quick succession to make up for the lost time.
+* A kernel thread is used so that the timer code can be run under the control
+* path mutex.The thread wakes up regularly and checks if any timer in the
+* timer list as expired.The timers are re-started automatically.
+*
+* The code tries to keep the number of times a timer runs per unit time constant
+* on average, if the thread scheduling is delayed, it's possible for a
+* particular timer to be scheduled in quick succession to make up for the
+* lost time.
 *
 * @param data	Pointer to the control context structure
 *
@@ -258,16 +273,13 @@ static int pfe_ctrl_timer(void *data)
 
 	printk(KERN_INFO "%s\n", __func__);
 
-	while (1)
-	{
+	while (1) {
 		schedule_timeout_uninterruptible(ctrl->timer_period);
 
 		mutex_lock(&ctrl->mutex);
 
-		list_for_each_entry_safe(timer, next, &ctrl->timer_list, list)
-		{
-			if (time_after(jiffies, timer->timeout))
-			{
+		list_for_each_entry_safe(timer, next, &ctrl->timer_list, list) {
+			if (time_after(jiffies, timer->timeout)) {
 				timer->timeout += timer->period;
 
 				timer->handler();
@@ -306,36 +318,45 @@ int pfe_ctrl_init(struct pfe *pfe)
 	INIT_LIST_HEAD(&ctrl->msg_list);
 
 	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++) {
-		ctrl->sync_mailbox_baseaddr[id] = virt_to_class_dmem(&class_sync_mailbox);
-		ctrl->msg_mailbox_baseaddr[id] = virt_to_class_dmem(&class_msg_mailbox);
+		ctrl->sync_mailbox_baseaddr[id] =
+			virt_to_class_dmem(&class_sync_mailbox);
+		ctrl->msg_mailbox_baseaddr[id] =
+			virt_to_class_dmem(&class_msg_mailbox);
 	}
 
 	for (id = TMU0_ID; id <= TMU_MAX_ID; id++) {
 #if defined(CONFIG_PLATFORM_LS1012A)
-		if(id == TMU2_ID) continue;
+		if (id == TMU2_ID)
+			continue;
 #endif
-		ctrl->sync_mailbox_baseaddr[id] = virt_to_tmu_dmem(&tmu_sync_mailbox);
-		ctrl->msg_mailbox_baseaddr[id] = virt_to_tmu_dmem(&tmu_msg_mailbox);
+		ctrl->sync_mailbox_baseaddr[id] =
+			virt_to_tmu_dmem(&tmu_sync_mailbox);
+		ctrl->msg_mailbox_baseaddr[id] =
+			virt_to_tmu_dmem(&tmu_msg_mailbox);
 	}
 
 #if !defined(CONFIG_UTIL_DISABLED)
-	ctrl->sync_mailbox_baseaddr[UTIL_ID] = virt_to_util_dmem(&util_sync_mailbox);
-	ctrl->msg_mailbox_baseaddr[UTIL_ID] = virt_to_util_dmem(&util_msg_mailbox);
+	ctrl->sync_mailbox_baseaddr[UTIL_ID] =
+			virt_to_util_dmem(&util_sync_mailbox);
+	ctrl->msg_mailbox_baseaddr[UTIL_ID] =
+			virt_to_util_dmem(&util_msg_mailbox);
 #endif
 
 	ctrl->hash_array_baseaddr = pfe->ddr_baseaddr + ROUTE_TABLE_BASEADDR;
-	ctrl->hash_array_phys_baseaddr = pfe->ddr_phys_baseaddr + ROUTE_TABLE_BASEADDR;
-	ctrl->ipsec_lmem_phys_baseaddr =  CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR + IPSEC_LMEM_BASEADDR);
+	ctrl->hash_array_phys_baseaddr = pfe->ddr_phys_baseaddr +
+						ROUTE_TABLE_BASEADDR;
+	ctrl->ipsec_lmem_phys_baseaddr =  CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR +
+						IPSEC_LMEM_BASEADDR);
 	ctrl->ipsec_lmem_baseaddr = (LMEM_BASE_ADDR + IPSEC_LMEM_BASEADDR);
 
-	ctrl->timer_thread = kthread_create(pfe_ctrl_timer, ctrl, "pfe_ctrl_timer");
-	if (IS_ERR(ctrl->timer_thread))
-	{
-		printk (KERN_ERR "%s: kthread_create() failed\n", __func__);
+	ctrl->timer_thread = kthread_create(pfe_ctrl_timer, ctrl,
+						"pfe_ctrl_timer");
+	if (IS_ERR(ctrl->timer_thread)) {
+		printk(KERN_ERR "%s: kthread_create() failed\n", __func__);
 		rc = PTR_ERR(ctrl->timer_thread);
 		goto err0;
 	}
-	
+
 	ctrl->dev = pfe->dev;
 
 	wake_up_process(ctrl->timer_thread);
diff --git a/drivers/staging/fsl_ppfe/pfe_ctrl.h b/drivers/staging/fsl_ppfe/pfe_ctrl.h
index 8e3f95e..062affa 100644
--- a/drivers/staging/fsl_ppfe/pfe_ctrl.h
+++ b/drivers/staging/fsl_ppfe/pfe_ctrl.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_CTRL_H_
 #define _PFE_CTRL_H_
@@ -26,10 +26,13 @@
 #include "pfe/pfe.h"
 
 #define DMA_BUF_SIZE_128	0x80	/* enough for 1 conntracks */
-#define DMA_BUF_SIZE_256	0x100	/* enough for 2 conntracks, 1 bridge entry or 1 multicast entry */
-#define DMA_BUF_SIZE_512	0x200	/* 512bytes dma allocated buffers used by rtp relay feature */
+#define DMA_BUF_SIZE_256	0x100
+/* enough for 2 conntracks, 1 bridge entry or 1 multicast entry */
+#define DMA_BUF_SIZE_512	0x200
+/* 512bytes dma allocated buffers used by rtp relay feature */
 #define DMA_BUF_MIN_ALIGNMENT	8
-#define DMA_BUF_BOUNDARY	(4 * 1024) /* bursts can not cross 4k boundary */
+#define DMA_BUF_BOUNDARY	(4 * 1024)
+/* bursts can not cross 4k boundary */
 
 #define CMD_TX_ENABLE	0x0501
 #define CMD_TX_DISABLE	0x0502
@@ -50,8 +53,14 @@ struct pfe_ctrl {
 
 	struct device *dev;
 
-	void *hash_array_baseaddr;		/** Virtual base address of the conntrack hash array */
-	unsigned long hash_array_phys_baseaddr; /** Physical base address of the conntrack hash array */
+	void *hash_array_baseaddr;		/*
+						* Virtual base address of
+						* the conntrack hash array
+						*/
+	unsigned long hash_array_phys_baseaddr; /*
+						* Physical base address of
+						* the conntrack hash array
+						*/
 
 	struct task_struct *timer_thread;
 	struct list_head timer_list;
@@ -59,8 +68,17 @@ struct pfe_ctrl {
 
 	int (*event_cb)(u16, u16, u16*);
 
-	unsigned long sync_mailbox_baseaddr[MAX_PE]; /* Sync mailbox PFE internal address, initialized when parsing elf images */
-	unsigned long msg_mailbox_baseaddr[MAX_PE]; /* Msg mailbox PFE internal address, initialized when parsing elf images */
+	unsigned long sync_mailbox_baseaddr[MAX_PE]; /*
+						     * Sync mailbox PFE
+						     * internal address,
+						     * initialized
+						     * when parsing elf images
+						     */
+	unsigned long msg_mailbox_baseaddr[MAX_PE]; /*
+						    * Msg mailbox PFE internal
+						    * address, initialized
+						    * when parsing elf images
+						    */
 
 	unsigned long class_dmem_sh;
 	unsigned long class_pe_lmem_sh;
@@ -68,10 +86,10 @@ struct pfe_ctrl {
 	unsigned long util_dmem_sh;
 	unsigned long util_ddr_sh;
 	struct clk *clk_axi;
-	unsigned int sys_clk;			// AXI clock value, in KHz
+	unsigned int sys_clk;			/* AXI clock value, in KHz */
 	void *ipsec_lmem_baseaddr;
 	unsigned long ipsec_lmem_phys_baseaddr;
-	
+
 	/* used for asynchronous message transfer to PFE */
 	struct list_head msg_list;
 	struct work_struct work;
@@ -80,14 +98,19 @@ struct pfe_ctrl {
 int pfe_ctrl_init(struct pfe *pfe);
 void pfe_ctrl_exit(struct pfe *pfe);
 
-int pe_send_cmd(unsigned short cmd_type, unsigned short action, unsigned long param1, unsigned long param2);
+int pe_send_cmd(unsigned short cmd_type, unsigned short action, unsigned long
+param1, unsigned long param2);
 int pe_sync_stop(struct pfe_ctrl *ctrl, int pe_mask);
 void pe_start(struct pfe_ctrl *ctrl, int pe_mask);
-int pe_request(struct pfe_ctrl *ctrl, int id,unsigned short cmd_type, unsigned long dst, unsigned long src, int len);
-int pe_read(struct pfe_ctrl *ctrl, int id, u32 *dst, unsigned long src, int len, int clear_flag);
-int tmu_pe_request(struct pfe_ctrl *ctrl, int id, unsigned int tmu_cmd_bitmask);
-
-int pfe_ctrl_set_eth_state(int id, unsigned int state, unsigned char *mac_addr);
+int pe_request(struct pfe_ctrl *ctrl, int id, unsigned short cmd_type, unsigned
+long dst, unsigned long src, int len);
+int pe_read(struct pfe_ctrl *ctrl, int id, u32 *dst, unsigned long src, int len,
+int clear_flag);
+int tmu_pe_request(struct pfe_ctrl *ctrl, int id, unsigned int
+tmu_cmd_bitmask);
+
+int pfe_ctrl_set_eth_state(int id, unsigned int state, unsigned char
+*mac_addr);
 int pfe_ctrl_set_lro(char enable);
 #ifdef CFG_PCAP
 int pfe_ctrl_set_pcap(char enable);
@@ -100,12 +123,12 @@ int relax(unsigned long end);
 /* used for asynchronous message transfer to PFE */
 #define FPP_MAX_MSG_LENGTH	256 /* expressed in U8 -> 256 bytes*/
 struct fpp_msg {
-        struct list_head list;
-        void (*callback)(unsigned long, int, u16, u16 *);
-        unsigned long data;
-        u16 fcode;
-        u16 length;
-        u16 *payload;
+struct list_head list;
+void (*callback)(unsigned long, int, u16, u16 *);
+unsigned long data;
+u16 fcode;
+u16 length;
+u16 *payload;
 };
 
 #endif /* _PFE_CTRL_H_ */
diff --git a/drivers/staging/fsl_ppfe/pfe_ctrl_hal.c b/drivers/staging/fsl_ppfe/pfe_ctrl_hal.c
index ae4ac72..87be97e 100644
--- a/drivers/staging/fsl_ppfe/pfe_ctrl_hal.c
+++ b/drivers/staging/fsl_ppfe/pfe_ctrl_hal.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* OS abstraction functions used by PFE control code */
 
@@ -33,13 +33,14 @@ extern char *__util_ddr_sh;
 #endif
 
 HostMessage msg_buf;
-static int msg_buf_used = 0;
+static int msg_buf_used;
 unsigned long virt_to_class_dmem(void *p)
 {
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	if (p)
-		return (unsigned long)p - (unsigned long)&__class_dmem_sh + ctrl->class_dmem_sh;
+		return (unsigned long)p - (unsigned long)&__class_dmem_sh +
+				ctrl->class_dmem_sh;
 	else
 		return 0;
 }
@@ -48,7 +49,8 @@ unsigned long virt_to_tmu_dmem(void *p)
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	if (p)
-		return (unsigned long)p - (unsigned long)&__tmu_dmem_sh + ctrl->tmu_dmem_sh;
+		return (unsigned long)p - (unsigned long)&__tmu_dmem_sh +
+				ctrl->tmu_dmem_sh;
 	else
 		return 0;
 }
@@ -60,31 +62,35 @@ unsigned long virt_to_util_dmem(void *p)
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	if (p)
-		return (unsigned long)p - (unsigned long)&__util_dmem_sh + ctrl->util_dmem_sh;
+		return (unsigned long)p - (unsigned long)&__util_dmem_sh +
+				ctrl->util_dmem_sh;
 	else
 		return 0;
 }
 
 /** Returns the DDR physical address of a Util PE shared DDR variable.
- *
- * @param p	pointer (kernel space, virtual) to be converted to a physical address.
- */
+*
+* @param p	pointer (kernel space, virtual) to be converted to a physical
+* address.
+*/
 unsigned long virt_to_util_ddr(void *p)
 {
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	if (p)
-		return (unsigned long)p - (unsigned long)&__util_ddr_sh + ctrl->util_ddr_sh;
+		return (unsigned long)p - (unsigned long)&__util_ddr_sh +
+				ctrl->util_ddr_sh;
 	else
 		return 0;
 }
 /** Returns the virtual address of a Util PE shared DDR variable.
- *
- * @param p pointer (kernel space, virtual) to be converted to a pointer (usable in kernel space)
- * pointing to the actual data.
- */
+*
+* @param p pointer (kernel space, virtual) to be converted to a pointer (usable
+* in kernel space)
+* pointing to the actual data.
+*/
 
-void * virt_to_util_virt(void *p)
+void *virt_to_util_virt(void *p)
 {
 	if (p)
 		return DDR_PHYS_TO_VIRT(virt_to_util_ddr(p));
@@ -105,7 +111,8 @@ unsigned long virt_to_phys_ipsec_lmem(void *p)
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	if (p)
-		return (p - ctrl->ipsec_lmem_baseaddr) + ctrl->ipsec_lmem_phys_baseaddr;
+		return (p - ctrl->ipsec_lmem_baseaddr) +
+				ctrl->ipsec_lmem_phys_baseaddr;
 	else
 		return 0;
 }
@@ -121,8 +128,7 @@ unsigned long virt_to_phys_ipsec_axi(void *p)
 
 HostMessage *msg_alloc(void)
 {
-	if (msg_buf_used)
-	{
+	if (msg_buf_used) {
 		printk(KERN_ERR "%s: failed\n", __func__);
 		return NULL;
 	}
@@ -135,7 +141,8 @@ HostMessage *msg_alloc(void)
 void msg_free(HostMessage *msg)
 {
 	if (!msg_buf_used)
-		printk(KERN_ERR "%s: freing already free msg buffer\n", __func__);
+		printk(KERN_ERR "%s: freing already free msg buffer\n",
+			__func__);
 
 	msg_buf_used = 0;
 }
@@ -175,8 +182,7 @@ void timer_add(TIMER_ENTRY *timer, u16 granularity)
 	timer->period = granularity;
 	timer->timeout = jiffies + timer->period;
 
-	if (!timer->running)
-	{
+	if (!timer->running) {
 		list_add(&timer->list, &ctrl->timer_list);
 		timer->running = 1;
 	}
@@ -186,8 +192,7 @@ void timer_add(TIMER_ENTRY *timer, u16 granularity)
 void timer_del(TIMER_ENTRY *timer)
 {
 
-	if (timer->running)
-	{
+	if (timer->running) {
 		list_del(&timer->list);
 		timer->running = 0;
 	}
diff --git a/drivers/staging/fsl_ppfe/pfe_ctrl_hal.h b/drivers/staging/fsl_ppfe/pfe_ctrl_hal.h
index c88d3cd..44a2da2 100644
--- a/drivers/staging/fsl_ppfe/pfe_ctrl_hal.h
+++ b/drivers/staging/fsl_ppfe/pfe_ctrl_hal.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_CTRL_HAL_H_
 #define _PFE_CTRL_HAL_H_
@@ -30,21 +30,27 @@
 
 #include "pfe_mod.h"
 
-#define CLASS_DMEM_SH(var) __attribute__((section(".class_dmem_sh_" #var))) var
-#define CLASS_PE_LMEM_SH(var) __attribute__((section(".class_pe_lmem_sh_" #var))) var
-#define TMU_DMEM_SH(var) __attribute__((section(".tmu_dmem_sh_" #var))) var
-#define UTIL_DMEM_SH(var) __attribute__((section(".util_dmem_sh_" #var))) var
-#define UTIL_DDR_SH(var) __attribute__((section(".util_ddr_sh_" #var))) var
-
-#define CLASS_DMEM_SH2(var) __attribute__((section(".class_dmem_sh_" #var))) class_##var
-#define CLASS_PE_LMEM_SH2(var) __attribute__((section(".class_pe_lmem_sh_" #var))) class_##var
-#define TMU_DMEM_SH2(var) __attribute__((section(".tmu_dmem_sh_" #var))) tmu_##var
-#define UTIL_DMEM_SH2(var) __attribute__((section(".util_dmem_sh_" #var))) util_##var
-
-/** Translate the name of a shared variable to its PFE counterpart.
+#define CLASS_DMEM_SH(var) (__attribute__((section(".class_dmem_sh_" #var)))\
+				var)
+#define CLASS_PE_LMEM_SH(var)(__attribute__((section(".class_pe_lmem_sh_"\
+				#var))) var)
+#define TMU_DMEM_SH(var) (__attribute__((section(".tmu_dmem_sh_" #var))) var)
+#define UTIL_DMEM_SH(var) (__attribute__((section(".util_dmem_sh_" #var))) var)
+#define UTIL_DDR_SH(var) (__attribute__((section(".util_ddr_sh_" #var))) var)
+
+#define CLASS_DMEM_SH2(var) (__attribute__((section(".class_dmem_sh_" #var))\
+				) class_##var)
+#define CLASS_PE_LMEM_SH2(var) (__attribute__((section(".class_pe_lmem_sh_"\
+				#var))) class_##var)
+#define TMU_DMEM_SH2(var) (__attribute__((section(".tmu_dmem_sh_" #var))\
+				) tmu_##var)
+#define UTIL_DMEM_SH2(var) (__attribute__((section(".util_dmem_sh_" #var))\
+				) util_##var)
+/*
+ * Translate the name of a shared variable to its PFE counterpart.
  * Those macros may be used to determine the address of a shared variable,
- * and will work even if the variable is accessed through a macro, as is the case
- * with most fields of gFppGlobals.
+ * and will work even if the variable is accessed through a macro, as is the
+ * case with most fields of gFppGlobals.
  */
 #define CONCAT(str, var) str##var
 #define CLASS_VARNAME2(var) CONCAT(class_, var)
@@ -68,7 +74,7 @@ unsigned long virt_to_class_pe_lmem(void *p);
 unsigned long virt_to_tmu_dmem(void *p);
 unsigned long virt_to_util_dmem(void *p);
 unsigned long virt_to_util_ddr(void *p);
-void * virt_to_util_virt(void *p);
+void *virt_to_util_virt(void *p);
 unsigned long virt_to_phys_iram(void *p);
 unsigned long virt_to_phys_ipsec_lmem(void *p);
 unsigned long virt_to_phys_ipsec_axi(void *p);
@@ -81,7 +87,7 @@ unsigned long virt_to_phys_ipsec_axi(void *p);
 #endif
 
 
-typedef void (* TIMER_HANDLER)(void);
+typedef void (*TIMER_HANDLER)(void);
 
 typedef struct {
 	struct list_head list;
@@ -103,7 +109,8 @@ typedef struct {
 void timer_init(TIMER_ENTRY *timer, TIMER_HANDLER handler);
 
 /** Adds a timer to the running timer list.
-* It's safe to call even if the timer was already running. In this case we just update the granularity.
+* It's safe to call even if the timer was already running. In this case we just
+update the granularity.
 * The caller must be holding the ctrl->mutex.
 *
 * @param timer		pointer to the timer to be added
diff --git a/drivers/staging/fsl_ppfe/pfe_debugfs.c b/drivers/staging/fsl_ppfe/pfe_debugfs.c
index bfa26a9..8f74450 100644
--- a/drivers/staging/fsl_ppfe/pfe_debugfs.c
+++ b/drivers/staging/fsl_ppfe/pfe_debugfs.c
@@ -1,25 +1,26 @@
 /*
- *  (C) Copyright 2013
- *  Author : Freescale Technologes
- *
- *  See file CREDITS for list of people who contributed to this
- *  project.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License as
- *  published by the Free Software Foundation; either version 2 of
- *  the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA 02111-1307 USA
- * */
+*  (C) Copyright 2013
+*  Author : Freescale Technologes
+*
+*  See file CREDITS for list of people who contributed to this
+*  project.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License as
+*  published by the Free Software Foundation; either version 2 of
+*  the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+*  MA 02111-1307 USA
+*
+*/
 
 #include <linux/module.h>
 #include <linux/debugfs.h>
@@ -38,7 +39,9 @@ static int dmem_show(struct seq_file *s, void *unused)
 
 		for (i = 0; i < 8; i++) {
 			val = pe_dmem_read(id, dmem_addr + i * 4, 4);
-			seq_printf(s, " %02x %02x %02x %02x", val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
+			seq_printf(s, " %02x %02x %02x %02x", val & 0xff,
+					(val >> 8) & 0xff, (val >> 16) & 0xff,
+					(val >> 24) & 0xff);
 		}
 
 		seq_printf(s, "\n");
@@ -69,27 +72,33 @@ int pfe_debugfs_init(struct pfe *pfe)
 	if (IS_ERR_OR_NULL(pfe->dentry))
 		goto err_dir;
 
-	d = debugfs_create_file("pe0_dmem", S_IRUGO, pfe->dentry, (void *)0, &dmem_fops);
+	d = debugfs_create_file("pe0_dmem", S_IRUGO, pfe->dentry, (void *)0,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
-	d = debugfs_create_file("pe1_dmem", S_IRUGO, pfe->dentry, (void *)1, &dmem_fops);
+	d = debugfs_create_file("pe1_dmem", S_IRUGO, pfe->dentry, (void *)1,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
-	d = debugfs_create_file("pe2_dmem", S_IRUGO, pfe->dentry, (void *)2, &dmem_fops);
+	d = debugfs_create_file("pe2_dmem", S_IRUGO, pfe->dentry, (void *)2,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
-	d = debugfs_create_file("pe3_dmem", S_IRUGO, pfe->dentry, (void *)3, &dmem_fops);
+	d = debugfs_create_file("pe3_dmem", S_IRUGO, pfe->dentry, (void *)3,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
-	d = debugfs_create_file("pe4_dmem", S_IRUGO, pfe->dentry, (void *)4, &dmem_fops);
+	d = debugfs_create_file("pe4_dmem", S_IRUGO, pfe->dentry, (void *)4,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
-	d = debugfs_create_file("pe5_dmem", S_IRUGO, pfe->dentry, (void *)5, &dmem_fops);
+	d = debugfs_create_file("pe5_dmem", S_IRUGO, pfe->dentry, (void *)5,
+				&dmem_fops);
 	if (IS_ERR_OR_NULL(d))
 		goto err_pe;
 
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.c b/drivers/staging/fsl_ppfe/pfe_eth.c
index 69de9cf..89d8dc9 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.c
+++ b/drivers/staging/fsl_ppfe/pfe_eth.c
@@ -1,28 +1,28 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /** @pfe_eth.c.
- *  Ethernet driver for to handle exception path for PFE.
- *  - uses HIF functions to send/receive packets.
- *  - uses ctrl function to start/stop interfaces.
- *  - uses direct register accesses to control phy operation.
- */
+*  Ethernet driver for to handle exception path for PFE.
+*  - uses HIF functions to send/receive packets.
+*  - uses ctrl function to start/stop interfaces.
+*  - uses direct register accesses to control phy operation.
+*/
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -53,14 +53,15 @@
 #include "pfe_mod.h"
 #include "pfe_eth.h"
 
-const char comcerto_eth_driver_version[]="1.0";
+const char comcerto_eth_driver_version[] = "1.0";
 static void *cbus_emac_base[3];
 static void *cbus_gpi_base[3];
 
 /* Forward Declaration */
 static void pfe_eth_exit_one(struct pfe_eth_priv_s *priv);
 static void pfe_eth_flush_tx(struct pfe_eth_priv_s *priv, int force);
-static void pfe_eth_flush_txQ(struct pfe_eth_priv_s *priv, int txQ_num, int from_tx, int n_desc);
+static void pfe_eth_flush_txQ(struct pfe_eth_priv_s *priv, int txQ_num, int
+				from_tx, int n_desc);
 
 #if defined(CONFIG_PLATFORM_C2000)
 static void pfe_eth_set_device_wakeup(struct pfe *pfe);
@@ -122,28 +123,35 @@ unsigned int gemac_regs[] = {
 
 #ifdef PFE_ETH_NAPI_STATS
 /*
- * pfe_eth_show_napi_stats
- */
+* pfe_eth_show_napi_stats
+*/
 static ssize_t pfe_eth_show_napi_stats(struct device *dev,
-		struct device_attribute *attr, char *buf)
+					struct device_attribute *attr,
+					char *buf)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	ssize_t len = 0;
 
-	len += sprintf(buf + len, "sched:  %u\n", priv->napi_counters[NAPI_SCHED_COUNT]);
-	len += sprintf(buf + len, "poll:   %u\n", priv->napi_counters[NAPI_POLL_COUNT]);
-	len += sprintf(buf + len, "packet: %u\n", priv->napi_counters[NAPI_PACKET_COUNT]);
-	len += sprintf(buf + len, "budget: %u\n", priv->napi_counters[NAPI_FULL_BUDGET_COUNT]);
-	len += sprintf(buf + len, "desc:   %u\n", priv->napi_counters[NAPI_DESC_COUNT]);
+	len += sprintf(buf + len, "sched:  %u\n",
+			priv->napi_counters[NAPI_SCHED_COUNT]);
+	len += sprintf(buf + len, "poll:   %u\n",
+			priv->napi_counters[NAPI_POLL_COUNT]);
+	len += sprintf(buf + len, "packet: %u\n",
+			priv->napi_counters[NAPI_PACKET_COUNT]);
+	len += sprintf(buf + len, "budget: %u\n",
+			priv->napi_counters[NAPI_FULL_BUDGET_COUNT]);
+	len += sprintf(buf + len, "desc:   %u\n",
+			priv->napi_counters[NAPI_DESC_COUNT]);
 
 	return len;
 }
 
 /*
- * pfe_eth_set_napi_stats
- */
+* pfe_eth_set_napi_stats
+*/
 static ssize_t pfe_eth_set_napi_stats(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+					struct device_attribute *attr,
+					const char *buf, size_t count)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 
@@ -154,10 +162,11 @@ static ssize_t pfe_eth_set_napi_stats(struct device *dev,
 #endif
 #ifdef PFE_ETH_TX_STATS
 /** pfe_eth_show_tx_stats
- *
- */
+*
+*/
 static ssize_t pfe_eth_show_tx_stats(struct device *dev,
-		struct device_attribute *attr, char *buf)
+					struct device_attribute *attr,
+					char *buf)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	ssize_t len = 0;
@@ -166,25 +175,40 @@ static ssize_t pfe_eth_show_tx_stats(struct device *dev,
 	len += sprintf(buf + len, "TX queues stats:\n");
 
 	for (i = 0; i < emac_txq_cnt; i++) {
-		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, i); 
+		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+									i);
 
 		len += sprintf(buf + len, "\n");
 		__netif_tx_lock_bh(tx_queue);
 
 		hif_tx_lock(&pfe->hif);
-		len += sprintf(buf + len, "Queue %2d :  credits               = %10d\n", i, hif_lib_tx_credit_avail(pfe, priv->id, i));
-		len += sprintf(buf + len, "            tx packets            = %10d\n",  pfe->tmu_credit.tx_packets[priv->id][i]);
+		len += sprintf(buf + len,
+				"Queue %2d :  credits               = %10d\n"
+				, i, hif_lib_tx_credit_avail(pfe, priv->id, i));
+		len += sprintf(buf + len,
+				 "            tx packets            = %10d\n"
+				,  pfe->tmu_credit.tx_packets[priv->id][i]);
 		hif_tx_unlock(&pfe->hif);
 
 		/* Don't output additionnal stats if queue never used */
 		if (!pfe->tmu_credit.tx_packets[priv->id][i])
 			goto skip;
 
-		len += sprintf(buf + len, "            clean_fail            = %10d\n", priv->clean_fail[i]);
-		len += sprintf(buf + len, "            stop_queue            = %10d\n", priv->stop_queue_total[i]);
-		len += sprintf(buf + len, "            stop_queue_hif        = %10d\n", priv->stop_queue_hif[i]);
-		len += sprintf(buf + len, "            stop_queue_hif_client = %10d\n", priv->stop_queue_hif_client[i]);
-		len += sprintf(buf + len, "            stop_queue_credit     = %10d\n", priv->stop_queue_credit[i]);
+		len += sprintf(buf + len,
+				 "            clean_fail            = %10d\n"
+				, priv->clean_fail[i]);
+		len += sprintf(buf + len,
+				 "            stop_queue            = %10d\n"
+				, priv->stop_queue_total[i]);
+		len += sprintf(buf + len,
+				 "            stop_queue_hif        = %10d\n"
+				, priv->stop_queue_hif[i]);
+		len += sprintf(buf + len,
+				"            stop_queue_hif_client = %10d\n"
+				, priv->stop_queue_hif_client[i]);
+		len += sprintf(buf + len,
+				 "            stop_queue_credit     = %10d\n"
+				, priv->stop_queue_credit[i]);
 skip:
 		__netif_tx_unlock_bh(tx_queue);
 	}
@@ -192,22 +216,24 @@ skip:
 }
 
 /** pfe_eth_set_tx_stats
- *
- */
+*
+*/
 static ssize_t pfe_eth_set_tx_stats(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+					struct device_attribute *attr,
+					const char *buf, size_t count)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	int i;
 
 	for (i = 0; i < emac_txq_cnt; i++) {
-		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, i); 
+		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+									i);
 
 		__netif_tx_lock_bh(tx_queue);
 		priv->clean_fail[i] = 0;
 		priv->stop_queue_total[i] = 0;
 		priv->stop_queue_hif[i] = 0;
-		priv->stop_queue_hif_client[i]= 0;
+		priv->stop_queue_hif_client[i] = 0;
 		priv->stop_queue_credit[i] = 0;
 		__netif_tx_unlock_bh(tx_queue);
 	}
@@ -216,21 +242,24 @@ static ssize_t pfe_eth_set_tx_stats(struct device *dev,
 }
 #endif
 /** pfe_eth_show_txavail
- *
- */
+*
+*/
 static ssize_t pfe_eth_show_txavail(struct device *dev,
-		struct device_attribute *attr, char *buf)
+					struct device_attribute *attr,
+					char *buf)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	ssize_t len = 0;
 	int i;
 
 	for (i = 0; i < emac_txq_cnt; i++) {
-		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, i); 
+		struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+									i);
 
 		__netif_tx_lock_bh(tx_queue);
 
-		len += sprintf(buf + len, "%d", hif_lib_tx_avail(&priv->client, i));
+		len += sprintf(buf + len, "%d",
+				hif_lib_tx_avail(&priv->client, i));
 
 		__netif_tx_unlock_bh(tx_queue);
 
@@ -245,11 +274,11 @@ static ssize_t pfe_eth_show_txavail(struct device *dev,
 
 
 /** pfe_eth_show_default_priority
- *
- */ 
+*
+*/
 static ssize_t pfe_eth_show_default_priority(struct device *dev,
-		struct device_attribute *attr,
-		char *buf)
+						struct device_attribute *attr,
+						char *buf)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	unsigned long flags;
@@ -263,12 +292,12 @@ static ssize_t pfe_eth_show_default_priority(struct device *dev,
 }
 
 /** pfe_eth_set_default_priority
- *
- */
+*
+*/
 
 static ssize_t pfe_eth_set_default_priority(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t count)
+						struct device_attribute *attr,
+						const char *buf, size_t count)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(to_net_dev(dev));
 	unsigned long flags;
@@ -281,39 +310,48 @@ static ssize_t pfe_eth_set_default_priority(struct device *dev,
 }
 
 static DEVICE_ATTR(txavail, 0444, pfe_eth_show_txavail, NULL);
-static DEVICE_ATTR(default_priority, 0644, pfe_eth_show_default_priority, pfe_eth_set_default_priority);
+static DEVICE_ATTR(default_priority, 0644, pfe_eth_show_default_priority,
+			pfe_eth_set_default_priority);
 
 #ifdef PFE_ETH_NAPI_STATS
-static DEVICE_ATTR(napi_stats, 0644, pfe_eth_show_napi_stats, pfe_eth_set_napi_stats);
+static DEVICE_ATTR(napi_stats, 0644, pfe_eth_show_napi_stats,
+			pfe_eth_set_napi_stats);
 #endif
 
 #ifdef PFE_ETH_TX_STATS
-static DEVICE_ATTR(tx_stats, 0644, pfe_eth_show_tx_stats, pfe_eth_set_tx_stats);
+static DEVICE_ATTR(tx_stats, 0644, pfe_eth_show_tx_stats,
+			pfe_eth_set_tx_stats);
 #endif
 
 
 /** pfe_eth_sysfs_init
- *
- */
+*
+*/
 static int pfe_eth_sysfs_init(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	int err;
 
 	/* Initialize the default values */
-	/* By default, packets without conntrack will use this default high priority queue */
+
+	/*
+	* By default, packets without conntrack will use this default high
+	* priority queue
+	*/
 	priv->default_priority = 15;
 
 	/* Create our sysfs files */
 	err = device_create_file(&dev->dev, &dev_attr_default_priority);
 	if (err) {
-		netdev_err(dev, "failed to create default_priority sysfs files\n");
+		netdev_err(dev,
+			"failed to create default_priority sysfs files\n");
 		goto err_priority;
 	}
 
 	err = device_create_file(&dev->dev, &dev_attr_txavail);
 	if (err) {
-		netdev_err(dev, "failed to create default_priority sysfs files\n");
+		netdev_err(dev,
+			 "failed to create default_priority sysfs files\n");
 		goto err_txavail;
 	}
 
@@ -353,8 +391,8 @@ err_priority:
 }
 
 /** pfe_eth_sysfs_exit
- *
- */
+*
+*/
 void pfe_eth_sysfs_exit(struct net_device *dev)
 {
 #ifdef PFE_ETH_TX_STATS
@@ -421,62 +459,69 @@ static char stat_gstrings[][ETH_GSTRING_LEN] = {
 
 
 /**
- * pfe_eth_gstrings - Fill in a buffer with the strings which correspond to
- *                    the stats.
- *
- */
-static void pfe_eth_gstrings(struct net_device *dev, u32 stringset, u8 * buf)
+* pfe_eth_gstrings - Fill in a buffer with the strings which correspond to
+*                    the stats.
+*
+*/
+static void pfe_eth_gstrings(struct net_device *dev, u32 stringset, u8 *buf)
 {
 	switch (stringset) {
-		case ETH_SS_STATS:
-			memcpy(buf, stat_gstrings, (EMAC_RMON_LEN - 2) * ETH_GSTRING_LEN);
+	case ETH_SS_STATS:
+			memcpy(buf, stat_gstrings, (EMAC_RMON_LEN - 2) *
+			ETH_GSTRING_LEN);
 			break;
 
-		default:
+	default:
 			WARN_ON(1);
 			break;
 	}
 }
 
-/** 
- * pfe_eth_fill_stats - Fill in an array of 64-bit statistics from 
- *			various sources. This array will be appended 
- *			to the end of the ethtool_stats* structure, and 
- *			returned to user space
- */
-static void pfe_eth_fill_stats(struct net_device *dev, struct ethtool_stats *dummy, u64 * buf)
+/**
+* pfe_eth_fill_stats - Fill in an array of 64-bit statistics from
+*			various sources. This array will be appended
+*			to the end of the ethtool_stats* structure, and
+*			returned to user space
+*/
+static void pfe_eth_fill_stats(struct net_device *dev, struct ethtool_stats
+				*dummy, u64 *buf)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	int i;
-	for (i=0;i<EMAC_RMON_LEN;i++, buf++) {
-		*buf = readl(priv->EMAC_baseaddr + EMAC_RMON_BASE_OFST + (i << 2));	
-		if ( ( i == EMAC_RMON_TXBYTES_POS ) || ( i == EMAC_RMON_RXBYTES_POS ) ){
+
+	for (i = 0; i < EMAC_RMON_LEN; i++, buf++) {
+		*buf = readl(priv->EMAC_baseaddr + EMAC_RMON_BASE_OFST + (i <<
+				2));
+		if ((i == EMAC_RMON_TXBYTES_POS) || (i ==
+			EMAC_RMON_RXBYTES_POS)) {
 			i++;
-			*buf |= (u64)readl(priv->EMAC_baseaddr + EMAC_RMON_BASE_OFST + (i << 2)) << 32;
+			*buf |= (u64)readl(priv->EMAC_baseaddr +
+				EMAC_RMON_BASE_OFST + (i << 2)) << 32;
 		}
 	}
 
 }
 
 /**
- * pfe_eth_stats_count - Returns the number of stats (and their corresponding strings) 
- *
- */
+* pfe_eth_stats_count - Returns the number of stats (and their corresponding
+strings)
+*
+*/
 static int pfe_eth_stats_count(struct net_device *dev, int sset)
 {
 	switch (sset) {
-		case ETH_SS_STATS:
-			return EMAC_RMON_LEN - 2;
-		default:
-			return -EOPNOTSUPP;
+	case ETH_SS_STATS:
+		return EMAC_RMON_LEN - 2;
+	default:
+		return -EOPNOTSUPP;
 	}
 }
 
 #if defined(CONFIG_PLATFORM_C2000)
 /**
- * pfe_eth_set_wol - Set the magic packet option, in WoL register.
- *
- */
+* pfe_eth_set_wol - Set the magic packet option, in WoL register.
+*
+*/
 static int pfe_eth_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -487,13 +532,13 @@ static int pfe_eth_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	priv->wol = 0;
 
 	if (wol->wolopts & WAKE_MAGIC)
-		 priv->wol |= EMAC_WOL_MAGIC;
+		priv->wol |= EMAC_WOL_MAGIC;
 	if (wol->wolopts & WAKE_ARP)
-		 priv->wol |= EMAC_WOL_ARP;
+		priv->wol |= EMAC_WOL_ARP;
 	if (wol->wolopts & WAKE_MCAST)
-		 priv->wol |= EMAC_WOL_MULTI;
+		priv->wol |= EMAC_WOL_MULTI;
 	if (wol->wolopts & WAKE_UCAST)
-		 priv->wol |= EMAC_WOL_SPEC_ADDR;
+		priv->wol |= EMAC_WOL_SPEC_ADDR;
 
 	pfe_eth_set_device_wakeup(priv->pfe);
 
@@ -501,58 +546,62 @@ static int pfe_eth_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 }
 
 /**
- *
- * pfe_eth_get_wol - Get the WoL options.
- *
- */
-static void pfe_eth_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+*
+* pfe_eth_get_wol - Get the WoL options.
+*
+*/
+static void pfe_eth_get_wol(struct net_device *dev, struct ethtool_wolinfo
+				*wol)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 
 	wol->supported = (WAKE_MAGIC | WAKE_ARP | WAKE_MCAST | WAKE_UCAST);
 	wol->wolopts = 0;
 
-	if(priv->wol & EMAC_WOL_MAGIC)
+	if (priv->wol & EMAC_WOL_MAGIC)
 		wol->wolopts |= WAKE_MAGIC;
-	if(priv->wol & EMAC_WOL_ARP)
+	if (priv->wol & EMAC_WOL_ARP)
 		wol->wolopts |= WAKE_ARP;
-	if(priv->wol & EMAC_WOL_MULTI)
+	if (priv->wol & EMAC_WOL_MULTI)
 		wol->wolopts |= WAKE_UCAST;
-	if(priv->wol & EMAC_WOL_SPEC_ADDR)
+	if (priv->wol & EMAC_WOL_SPEC_ADDR)
 		wol->wolopts |= WAKE_UCAST;
 
 	memset(&wol->sopass, 0, sizeof(wol->sopass));
 }
 #endif
 /**
- * pfe_eth_gemac_reglen - Return the length of the register structure.
- *
- */
+* pfe_eth_gemac_reglen - Return the length of the register structure.
+*
+*/
 static int pfe_eth_gemac_reglen(struct net_device *dev)
 {
-	return (sizeof (gemac_regs)/ sizeof(u32)) + (( MAX_UC_SPEC_ADDR_REG - 3 ) * 2);
+	return (sizeof(gemac_regs) / sizeof(u32)) + ((MAX_UC_SPEC_ADDR_REG - 3
+			) * 2);
 }
 
 /**
- * pfe_eth_gemac_get_regs - Return the gemac register structure.
- *
- */
-static void  pfe_eth_gemac_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)
+* pfe_eth_gemac_get_regs - Return the gemac register structure.
+*
+*/
+static void  pfe_eth_gemac_get_regs(struct net_device *dev, struct ethtool_regs
+					*regs, void *regbuf)
 {
-	int i,j;
+	int i, j;
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	u32 *buf = (u32 *) regbuf;
 
-	for (i = 0; i < sizeof (gemac_regs) / sizeof (u32); i++)
-		buf[i] = readl( priv->EMAC_baseaddr + gemac_regs[i] );
+	for (i = 0; i < sizeof(gemac_regs) / sizeof(u32); i++)
+		buf[i] = readl(priv->EMAC_baseaddr + gemac_regs[i]);
 
-	for (j = 0; j < (( MAX_UC_SPEC_ADDR_REG - 3 ) * 2); j++,i++)
-		buf[i] = readl( priv->EMAC_baseaddr + EMAC_SPEC5_ADD_BOT + (j<<2) );
+	for (j = 0; j < ((MAX_UC_SPEC_ADDR_REG - 3) * 2); j++, i++)
+		buf[i] = readl(priv->EMAC_baseaddr + EMAC_SPEC5_ADD_BOT +
+				(j<<2));
 
 }
 
 
-#else //if defined(CONFIG_PLATFORM_C2000)
+#else /*if defined(CONFIG_PLATFORM_C2000) */
 /*MTIP GEMAC */
 static const struct fec_stat {
 	char name[ETH_GSTRING_LEN];
@@ -620,7 +669,8 @@ static const struct fec_stat {
 	{ "IEEE_rx_octets_ok", IEEE_R_OCTETS_OK },
 };
 
-static void pfe_eth_fill_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)
+static void pfe_eth_fill_stats(struct net_device *dev, struct ethtool_stats
+				*stats, u64 *data)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	int i;
@@ -630,9 +680,10 @@ static void pfe_eth_fill_stats(struct net_device *dev, struct ethtool_stats *sta
 }
 
 static void pfe_eth_gstrings(struct net_device *netdev,
-	u32 stringset, u8 *data)
+				u32 stringset, u8 *data)
 {
 	int i;
+
 	switch (stringset) {
 	case ETH_SS_STATS:
 		for (i = 0; i < ARRAY_SIZE(fec_stats); i++)
@@ -653,28 +704,30 @@ static int pfe_eth_stats_count(struct net_device *dev, int sset)
 }
 
 /**
- * pfe_eth_gemac_reglen - Return the length of the register structure.
- *
- */
+* pfe_eth_gemac_reglen - Return the length of the register structure.
+*
+*/
 static int pfe_eth_gemac_reglen(struct net_device *dev)
 {
-	printk("%s() \n", __func__);
-	return (sizeof (gemac_regs)/ sizeof(u32)) ;
+	printk("%s()\n", __func__);
+	return (sizeof(gemac_regs) / sizeof(u32));
 }
 
 /**
- * pfe_eth_gemac_get_regs - Return the gemac register structure.
- *
- */
-static void  pfe_eth_gemac_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)
+* pfe_eth_gemac_get_regs - Return the gemac register structure.
+*
+*/
+static void  pfe_eth_gemac_get_regs(struct net_device *dev, struct ethtool_regs
+					*regs, void *regbuf)
 {
 	int i;
+
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	u32 *buf = (u32 *) regbuf;
 
-	printk("%s() \n", __func__);
-	for (i = 0; i < sizeof (gemac_regs) / sizeof (u32); i++)
-		buf[i] = readl( priv->EMAC_baseaddr + gemac_regs[i] );
+	printk("%s()\n", __func__);
+	for (i = 0; i < sizeof(gemac_regs) / sizeof(u32); i++)
+		buf[i] = readl(priv->EMAC_baseaddr + gemac_regs[i]);
 
 }
 
@@ -682,13 +735,15 @@ static void  pfe_eth_gemac_get_regs(struct net_device *dev, struct ethtool_regs
 #endif
 
 /**
- * pfe_eth_get_drvinfo -  Fills in the drvinfo structure with some basic info 
- *
- */
-static void pfe_eth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
+* pfe_eth_get_drvinfo -  Fills in the drvinfo structure with some basic info
+*
+*/
+static void pfe_eth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo
+				*drvinfo)
 {
 	strncpy(drvinfo->driver, DRV_NAME, COMCERTO_INFOSTR_LEN);
-	strncpy(drvinfo->version, comcerto_eth_driver_version, COMCERTO_INFOSTR_LEN);
+	strncpy(drvinfo->version, comcerto_eth_driver_version,
+			COMCERTO_INFOSTR_LEN);
 	strncpy(drvinfo->fw_version, "N/A", COMCERTO_INFOSTR_LEN);
 	strncpy(drvinfo->bus_info, "N/A", COMCERTO_INFOSTR_LEN);
 	drvinfo->testinfo_len = 0;
@@ -697,11 +752,12 @@ static void pfe_eth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *
 }
 
 /**
- * pfe_eth_set_settings - Used to send commands to PHY. 
- *
- */
+* pfe_eth_set_settings - Used to send commands to PHY.
+*
+*/
 
-static int pfe_eth_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int pfe_eth_set_settings(struct net_device *dev, struct ethtool_cmd
+					*cmd)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	struct phy_device *phydev = priv->phydev;
@@ -714,10 +770,12 @@ static int pfe_eth_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 
 /**
- * pfe_eth_getsettings - Return the current settings in the ethtool_cmd structure.
- *
- */
-static int pfe_eth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+* pfe_eth_getsettings - Return the current settings in the ethtool_cmd
+* structure.
+*
+*/
+static int pfe_eth_get_settings(struct net_device *dev, struct ethtool_cmd
+					*cmd)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	struct phy_device *phydev = priv->phydev;
@@ -730,9 +788,9 @@ static int pfe_eth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 
 /**
- * pfe_eth_get_msglevel - Gets the debug message mask.
- *
- */
+* pfe_eth_get_msglevel - Gets the debug message mask.
+*
+*/
 static uint32_t pfe_eth_get_msglevel(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -741,9 +799,9 @@ static uint32_t pfe_eth_get_msglevel(struct net_device *dev)
 }
 
 /**
- * pfe_eth_set_msglevel - Sets the debug message mask.
- *
- */
+* pfe_eth_set_msglevel - Sets the debug message mask.
+*
+*/
 static void pfe_eth_set_msglevel(struct net_device *dev, uint32_t data)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -753,84 +811,89 @@ static void pfe_eth_set_msglevel(struct net_device *dev, uint32_t data)
 
 #define HIF_RX_COAL_MAX_CLKS		(~(1<<31))
 #define HIF_RX_COAL_CLKS_PER_USEC	(pfe->ctrl.sys_clk/1000)
-#define HIF_RX_COAL_MAX_USECS		(HIF_RX_COAL_MAX_CLKS/HIF_RX_COAL_CLKS_PER_USEC)
+#define HIF_RX_COAL_MAX_USECS		(HIF_RX_COAL_MAX_CLKS	/ \
+						HIF_RX_COAL_CLKS_PER_USEC)
 
 /**
- * pfe_eth_set_coalesce - Sets rx interrupt coalescing timer.
- *
- */
+* pfe_eth_set_coalesce - Sets rx interrupt coalescing timer.
+*
+*/
 static int pfe_eth_set_coalesce(struct net_device *dev,
-                              struct ethtool_coalesce *ec)
+				struct ethtool_coalesce *ec)
 {
 	if (ec->rx_coalesce_usecs > HIF_RX_COAL_MAX_USECS)
-		  return -EINVAL;
+		return -EINVAL;
 
 	if (!ec->rx_coalesce_usecs) {
 		writel(0, HIF_INT_COAL);
 		return 0;
 	}
 
-	writel((ec->rx_coalesce_usecs * HIF_RX_COAL_CLKS_PER_USEC) | HIF_INT_COAL_ENABLE, HIF_INT_COAL);
+	writel((ec->rx_coalesce_usecs * HIF_RX_COAL_CLKS_PER_USEC) |
+			HIF_INT_COAL_ENABLE, HIF_INT_COAL);
 
 	return 0;
 }
 
 /**
- * pfe_eth_get_coalesce - Gets rx interrupt coalescing timer value.
- *
- */
+* pfe_eth_get_coalesce - Gets rx interrupt coalescing timer value.
+*
+*/
 static int pfe_eth_get_coalesce(struct net_device *dev,
-                              struct ethtool_coalesce *ec)
+				struct ethtool_coalesce *ec)
 {
 	int reg_val = readl(HIF_INT_COAL);
 
 	if (reg_val & HIF_INT_COAL_ENABLE)
-		ec->rx_coalesce_usecs = (reg_val & HIF_RX_COAL_MAX_CLKS) / HIF_RX_COAL_CLKS_PER_USEC;
+		ec->rx_coalesce_usecs = (reg_val & HIF_RX_COAL_MAX_CLKS) /
+						HIF_RX_COAL_CLKS_PER_USEC;
 	else
 		ec->rx_coalesce_usecs = 0;
 
-        return 0;
+	return 0;
 }
 
 #if defined(CONFIG_PLATFORM_C2000)
 /**
- * pfe_eth_pause_rx_enabled - Tests if pause rx is enabled on GEM
- *
- */
+* pfe_eth_pause_rx_enabled - Tests if pause rx is enabled on GEM
+*
+*/
 static int pfe_eth_pause_rx_enabled(struct pfe_eth_priv_s *priv)
 {
-	return (readl(priv->EMAC_baseaddr + EMAC_NETWORK_CONFIG) & EMAC_ENABLE_PAUSE_RX) != 0;
+	return (readl(priv->EMAC_baseaddr + EMAC_NETWORK_CONFIG) &
+	EMAC_ENABLE_PAUSE_RX) != 0;
 }
 
 /**
- * pfe_eth_set_pauseparam - Sets pause parameters
- *
- */
-static int pfe_eth_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
+* pfe_eth_set_pauseparam - Sets pause parameters
+*
+*/
+static int pfe_eth_set_pauseparam(struct net_device *dev,
+				struct ethtool_pauseparam *epause)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 
-	if (epause->rx_pause)
-	{
+	if (epause->rx_pause) {
 		gemac_enable_pause_rx(priv->EMAC_baseaddr);
 		if (priv->phydev)
-			priv->phydev->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
-	}
-	else
-	{
+			priv->phydev->advertising |= ADVERTISED_Pause |
+							ADVERTISED_Asym_Pause;
+	} else {
 		gemac_disable_pause_rx(priv->EMAC_baseaddr);
 		if (priv->phydev)
-			priv->phydev->advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+			priv->phydev->advertising &= ~(ADVERTISED_Pause |
+							ADVERTISED_Asym_Pause);
 	}
 
 	return 0;
 }
 
 /**
- * pfe_eth_get_pauseparam - Gets pause parameters
- *
- */
-static void pfe_eth_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
+* pfe_eth_get_pauseparam - Gets pause parameters
+*
+*/
+static void pfe_eth_get_pauseparam(struct net_device *dev,
+					struct ethtool_pauseparam *epause)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 
@@ -840,18 +903,19 @@ static void pfe_eth_get_pauseparam(struct net_device *dev, struct ethtool_pausep
 }
 
 /** pfe_eth_get_hash
- */
-static int pfe_eth_get_hash(u8 * addr)
+*/
+static int pfe_eth_get_hash(u8 *addr)
 {
-	u8 temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8;
-	temp1 = addr[0] & 0x3F ;
-	temp2 = ((addr[0] & 0xC0)  >> 6)| ((addr[1] & 0x0F) << 2);
+	u8 temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
+
+	temp1 = addr[0] & 0x3F;
+	temp2 = ((addr[0] & 0xC0)  >> 6) | ((addr[1] & 0x0F) << 2);
 	temp3 = ((addr[1] & 0xF0) >> 4) | ((addr[2] & 0x03) << 4);
 	temp4 = (addr[2] & 0xFC) >> 2;
 	temp5 = addr[3] & 0x3F;
 	temp6 = ((addr[3] & 0xC0) >> 6) | ((addr[4] & 0x0F) << 2);
-	temp7 = ((addr[4] & 0xF0) >>4 ) | ((addr[5] & 0x03) << 4);
-	temp8 = ((addr[5] &0xFC) >> 2);
+	temp7 = ((addr[4] & 0xF0) >> 4) | ((addr[5] & 0x03) << 4);
+	temp8 = ((addr[5] & 0xFC) >> 2);
 	return (temp1 ^ temp2 ^ temp3 ^ temp4 ^ temp5 ^ temp6 ^ temp7 ^ temp8);
 }
 
@@ -859,11 +923,11 @@ static int pfe_eth_get_hash(u8 * addr)
 	/*TODO Add pause frame support for LS1012A */
 
 /** pfe_eth_get_hash
- */
+*/
 #define HASH_BITS	6		/* #bits in hash */
 #define CRC32_POLY	0xEDB88320
 
-static int pfe_eth_get_hash(u8 * addr)
+static int pfe_eth_get_hash(u8 *addr)
 {
 	unsigned int i, bit, data, crc, hash;
 
@@ -878,7 +942,8 @@ static int pfe_eth_get_hash(u8 * addr)
 		}
 	}
 
-	/* only upper 6 bits (HASH_BITS) are used
+	/*
+	 * only upper 6 bits (HASH_BITS) are used
 	 * which point to specific bit in he hash registers
 	 */
 	hash = (crc >> (32 - HASH_BITS)) & 0x3f;
@@ -914,7 +979,7 @@ struct ethtool_ops pfe_ethtool_ops = {
 
 #if defined(CONFIG_PLATFORM_C2000)
 /** pfe_eth_mdio_reset
- */
+*/
 int pfe_eth_mdio_reset(struct mii_bus *bus)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
@@ -929,11 +994,14 @@ int pfe_eth_mdio_reset(struct mii_bus *bus)
 		gemac_set_mdc_div(priv->EMAC_baseaddr, priv->mdc_div);
 
 	/* Reset the management interface */
-	__raw_writel(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_CONTROL) | EMAC_MDIO_EN, 
+	__raw_writel(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_CONTROL) |
+			EMAC_MDIO_EN,
 			priv->EMAC_baseaddr + EMAC_NETWORK_CONTROL);
 
 	/* Wait until the bus is free */
-	while(!(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_STATUS) & EMAC_PHY_IDLE));
+	while (!(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_STATUS) &
+		EMAC_PHY_IDLE))
+			;
 
 	mutex_unlock(&bus->mdio_lock);
 #endif
@@ -943,15 +1011,15 @@ int pfe_eth_mdio_reset(struct mii_bus *bus)
 
 
 /** pfe_eth_gemac_phy_timeout
- *
- */
+*
+*/
 static int pfe_eth_gemac_phy_timeout(struct pfe_eth_priv_s *priv, int timeout)
 {
-	while(!(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_STATUS) & EMAC_PHY_IDLE)) {
+	while (!(__raw_readl(priv->EMAC_baseaddr + EMAC_NETWORK_STATUS) &
+		EMAC_PHY_IDLE)) {
 
-		if (timeout-- <= 0) {
+		if (timeout-- <= 0)
 			return -1;
-		}
 
 		udelay(10);
 	}
@@ -961,8 +1029,9 @@ static int pfe_eth_gemac_phy_timeout(struct pfe_eth_priv_s *priv, int timeout)
 
 
 /** pfe_eth_mdio_write
- */
-static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)
+*/
+static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16
+				value)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
 	u32 write_data;
@@ -971,14 +1040,18 @@ static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 v
 
 	netif_info(priv, hw, priv->dev, "%s: phy %d\n", __func__, mii_id);
 
-//	netif_info(priv, hw, priv->dev, "%s %d %d %x\n", bus->id, mii_id, regnum, value);
+	/*
+	* netif_info(priv, hw, priv->dev, "%s %d %d %x\n", bus->id, mii_id,
+	* regnum, value);
+	*/
 
 	write_data = 0x50020000;
 	write_data |= ((mii_id << 23) | (regnum << 18) | value);
 	__raw_writel(write_data, priv->EMAC_baseaddr + EMAC_PHY_MANAGEMENT);
 
-	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT)){
-		netdev_err(priv->dev, "%s: phy MDIO write timeout\n", __func__);
+	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT)) {
+		netdev_err(priv->dev, "%s: phy MDIO write timeout\n",
+				__func__);
 		return -1;
 	}
 
@@ -989,7 +1062,7 @@ static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 v
 
 
 /** pfe_eth_mdio_read
- */
+*/
 static int pfe_eth_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
@@ -1004,26 +1077,31 @@ static int pfe_eth_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 
 	__raw_writel(write_data, priv->EMAC_baseaddr + EMAC_PHY_MANAGEMENT);
 
-	if (pfe_eth_gemac_phy_timeout( priv, EMAC_MDIO_TIMEOUT))	{
+	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT))	{
 		netdev_err(priv->dev, "%s: phy MDIO read timeout\n", __func__);
-		return -1;	
+		return -1;
 	}
 
-	value = __raw_readl(priv->EMAC_baseaddr + EMAC_PHY_MANAGEMENT) & 0xFFFF;
+	value = __raw_readl(priv->EMAC_baseaddr + EMAC_PHY_MANAGEMENT) &
+				0xFFFF;
 #endif
 
-//	netif_info(priv, hw, priv->dev, "%s %d %d %x\n", bus->id, mii_id, regnum, value);
+/*
+* netif_info(priv, hw, priv->dev, "%s %d %d %x\n", bus->id, mii_id,
+* regnum, value);
+*/
 
 	return value;
 }
 
 #else
 /** pfe_eth_mdio_reset
- */
+*/
 int pfe_eth_mdio_reset(struct mii_bus *bus)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
-	u32 phy_speed, pclk = 250000000; /*TODO this needs to be checked read from the correct source*/
+	/*TODO this needs to be checked read from the correct source*/
+	u32 phy_speed, pclk = 250000000;
 
 	netif_info(priv, hw, priv->dev, "%s\n", __func__);
 
@@ -1045,15 +1123,15 @@ int pfe_eth_mdio_reset(struct mii_bus *bus)
 }
 
 /** pfe_eth_gemac_phy_timeout
- *
- */
+*
+*/
 static int pfe_eth_gemac_phy_timeout(struct pfe_eth_priv_s *priv, int timeout)
 {
-	while(!(__raw_readl(priv->PHY_baseaddr + EMAC_IEVENT_REG) & EMAC_IEVENT_MII)) {
+	while (!(__raw_readl(priv->PHY_baseaddr + EMAC_IEVENT_REG) &
+			EMAC_IEVENT_MII)) {
 
-		if (timeout-- <= 0) {
+		if (timeout-- <= 0)
 			return -1;
-		}
 
 		udelay(10);
 	}
@@ -1070,48 +1148,83 @@ static int pfe_eth_mdio_mux(u8 muxval)
 	int ret;
 
 	a = i2c_get_adapter(0);
-        if (!a)
-                return -ENODEV;
-
-        /* set bit 1 (the second bit) of chip at 0x09, register 0x13 */
-        buf[0] = 0x54; //reg number
-        buf[1] = (muxval << 6)| 0x3; //data
-        msg.addr = 0x66;
-        msg.buf = buf;
-        msg.len = 2;
-        msg.flags = 0;
-        ret = i2c_transfer(a, &msg, 1);
+	if (!a)
+		return -ENODEV;
+
+	/* set bit 1 (the second bit) of chip at 0x09, register 0x13 */
+	buf[0] = 0x54; /*reg number */
+	buf[1] = (muxval << 6) | 0x3; /*data */
+	msg.addr = 0x66;
+	msg.buf = buf;
+	msg.len = 2;
+	msg.flags = 0;
+	ret = i2c_transfer(a, &msg, 1);
 	i2c_put_adapter(a);
-        if (ret != 1)
-                return -ENODEV;
+	if (ret != 1)
+		return -ENODEV;
 	return 0;
 
 
 }
 
-static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)
+static int pfe_eth_mdio_write_addr(struct mii_bus *bus, int mii_id,
+				   int dev_addr, int regnum)
+{
+	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
+
+	__raw_writel(EMAC_MII_DATA_PA(mii_id) |
+		     EMAC_MII_DATA_RA(dev_addr) |
+		     EMAC_MII_DATA_TA | EMAC_MII_DATA(regnum),
+		     priv->PHY_baseaddr + EMAC_MII_DATA_REG);
+
+	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT)) {
+		netdev_err(priv->dev, "%s: phy MDIO address write timeout\n",
+				__func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int pfe_eth_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16
+				value)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)bus->priv;
 
 	/*FIXME Dirty hack to configure mux */
-	if(priv->mdio_muxval) {
-		if(mii_id == 0x1)
-			pfe_eth_mdio_mux(0x1);
-		else
+	if (priv->mdio_muxval) {
+		if (mii_id == 0x1)
 			pfe_eth_mdio_mux(0x2);
+		else
+			pfe_eth_mdio_mux(0x3);
+	}
+
+	if (regnum & MII_ADDR_C45) {
+		pfe_eth_mdio_write_addr(bus, mii_id, (regnum >> 16) & 0x1f,
+					regnum & 0xffff);
+		__raw_writel(EMAC_MII_DATA_OP_CL45_WR |
+			     EMAC_MII_DATA_PA(mii_id) |
+			     EMAC_MII_DATA_RA((regnum >> 16) & 0x1f) |
+			     EMAC_MII_DATA_TA | EMAC_MII_DATA(value),
+			     priv->PHY_baseaddr + EMAC_MII_DATA_REG);
+	} else {
+		/* start a write op */
+		__raw_writel(EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_WR |
+			     EMAC_MII_DATA_PA(mii_id) |
+			     EMAC_MII_DATA_RA(regnum) |
+			     EMAC_MII_DATA_TA | EMAC_MII_DATA(value),
+			     priv->PHY_baseaddr + EMAC_MII_DATA_REG);
 	}
 
-	/* start a write op */
-	__raw_writel(EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_WR |
-			EMAC_MII_DATA_PA(mii_id) | EMAC_MII_DATA_RA(regnum) |
-			EMAC_MII_DATA_TA | EMAC_MII_DATA(value),
-			priv->PHY_baseaddr + EMAC_MII_DATA_REG);
 
-	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT)){
-		netdev_err(priv->dev, "%s: phy MDIO write timeout\n", __func__);
+	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT)) {
+		netdev_err(priv->dev, "%s: phy MDIO write timeout\n",
+				__func__);
 		return -1;
 	}
-	netif_info(priv, hw, priv->dev, "%s: phy %x reg %x val %x\n", __func__, mii_id, regnum, value);
+	netif_info(priv, hw, priv->dev, "%s: phy %x reg %x val %x\n", __func__,
+			mii_id, regnum, value);
 
 	return 0;
 
@@ -1123,37 +1236,52 @@ static int pfe_eth_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 	u16 value = 0;
 
 	/*FIXME Dirty hack to configure mux */
-	if(priv->mdio_muxval){
-		if(mii_id == 0x1)
-			pfe_eth_mdio_mux(0x1);
-		else
+	if (priv->mdio_muxval) {
+		if (mii_id == 0x1)
 			pfe_eth_mdio_mux(0x2);
+		else
+			pfe_eth_mdio_mux(0x3);
 	}
 
-	/* start a read op */
-	__raw_writel(EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_RD |
-			EMAC_MII_DATA_PA(mii_id) | EMAC_MII_DATA_RA(regnum) |
-			EMAC_MII_DATA_TA, priv->PHY_baseaddr + EMAC_MII_DATA_REG);
+	if (regnum & MII_ADDR_C45) {
+		pfe_eth_mdio_write_addr(bus, mii_id, (regnum >> 16) & 0x1f,
+					regnum & 0xffff);
+		__raw_writel(EMAC_MII_DATA_OP_CL45_RD |
+			     EMAC_MII_DATA_PA(mii_id) |
+			     EMAC_MII_DATA_RA((regnum >> 16) & 0x1f) |
+			     EMAC_MII_DATA_TA,
+			     priv->PHY_baseaddr + EMAC_MII_DATA_REG);
+	} else {
+		/* start a read op */
+		__raw_writel(EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_RD |
+			     EMAC_MII_DATA_PA(mii_id) |
+			     EMAC_MII_DATA_RA(regnum) |
+			     EMAC_MII_DATA_TA, priv->PHY_baseaddr +
+			     EMAC_MII_DATA_REG);
+	}
 
-	if (pfe_eth_gemac_phy_timeout( priv, EMAC_MDIO_TIMEOUT))	{
+	if (pfe_eth_gemac_phy_timeout(priv, EMAC_MDIO_TIMEOUT))	{
 		netdev_err(priv->dev, "%s: phy MDIO read timeout\n", __func__);
 		return -1;
 	}
 
-	value = EMAC_MII_DATA(__raw_readl(priv->PHY_baseaddr + EMAC_MII_DATA_REG));
-	netif_info(priv, hw, priv->dev, "%s: phy %x reg %x val %x\n", __func__, mii_id, regnum, value);
+	value = EMAC_MII_DATA(__raw_readl(priv->PHY_baseaddr +
+						EMAC_MII_DATA_REG));
+	netif_info(priv, hw, priv->dev, "%s: phy %x reg %x val %x\n", __func__,
+			mii_id, regnum, value);
 	return value;
 }
 #endif
-static int pfe_eth_mdio_init(struct pfe_eth_priv_s *priv, struct comcerto_mdio_platform_data *minfo)
+static int pfe_eth_mdio_init(struct pfe_eth_priv_s *priv,
+				struct comcerto_mdio_platform_data *minfo)
 {
 	struct mii_bus *bus;
 	int rc;
 
 	netif_info(priv, drv, priv->dev, "%s\n", __func__);
-	printk( "%s\n", __func__);
+	printk("%s\n", __func__);
 
-#if !defined(CONFIG_PLATFORM_EMULATION) 
+#if !defined(CONFIG_PLATFORM_EMULATION)
 	bus = mdiobus_alloc();
 	if (!bus) {
 		netdev_err(priv->dev, "mdiobus_alloc() failed\n");
@@ -1178,10 +1306,12 @@ static int pfe_eth_mdio_init(struct pfe_eth_priv_s *priv, struct comcerto_mdio_p
 
 	bus->parent = priv->pfe->dev;
 
-	netif_info(priv, drv, priv->dev, "%s: mdc_div: %d, phy_mask: %x \n", __func__, priv->mdc_div, bus->phy_mask);
+	netif_info(priv, drv, priv->dev, "%s: mdc_div: %d, phy_mask: %x\n",
+			__func__, priv->mdc_div, bus->phy_mask);
 	rc = mdiobus_register(bus);
 	if (rc) {
-		netdev_err(priv->dev, "mdiobus_register(%s) failed\n", bus->name);
+		netdev_err(priv->dev, "mdiobus_register(%s) failed\n",
+				bus->name);
 		goto err1;
 	}
 
@@ -1201,13 +1331,14 @@ err0:
 }
 
 /** pfe_eth_mdio_exit
- */
+*/
 static void pfe_eth_mdio_exit(struct mii_bus *bus)
 {
 	if (!bus)
 		return;
 
-	netif_info((struct pfe_eth_priv_s *)bus->priv, drv, ((struct pfe_eth_priv_s *)(bus->priv))->dev, "%s\n", __func__);
+	netif_info((struct pfe_eth_priv_s *)bus->priv, drv, ((struct
+			pfe_eth_priv_s *)(bus->priv))->dev, "%s\n", __func__);
 
 	mdiobus_unregister(bus);
 	mdiobus_free(bus);
@@ -1215,7 +1346,7 @@ static void pfe_eth_mdio_exit(struct mii_bus *bus)
 
 #if defined(CONFIG_PLATFORM_C2000)
 /** pfe_get_interface
- */
+*/
 static phy_interface_t pfe_get_interface(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1225,27 +1356,22 @@ static phy_interface_t pfe_get_interface(struct net_device *dev)
 
 	if (priv->einfo->gemac_mode & (GEMAC_SW_CONF)) {
 		switch (mii_mode) {
-			case CONFIG_COMCERTO_USE_GMII:
+		case CONFIG_COMCERTO_USE_GMII:
 				return PHY_INTERFACE_MODE_GMII;
-				break;
-			case CONFIG_COMCERTO_USE_RGMII:
+		case CONFIG_COMCERTO_USE_RGMII:
 				return PHY_INTERFACE_MODE_RGMII;
-				break;
-			case CONFIG_COMCERTO_USE_RMII:
+		case CONFIG_COMCERTO_USE_RMII:
 				return PHY_INTERFACE_MODE_RMII;
-				break;
-			case CONFIG_COMCERTO_USE_SGMII:
+		case CONFIG_COMCERTO_USE_SGMII:
 				return PHY_INTERFACE_MODE_SGMII;
-				break;
 
-			default :
-			case CONFIG_COMCERTO_USE_MII:
+		default:
+		case CONFIG_COMCERTO_USE_MII:
 				return PHY_INTERFACE_MODE_MII;
-				break;
 
 		}
 	} else {
-		// Bootstrap config read from controller
+		/* Bootstrap config read from controller */
 		BUG();
 		return 0;
 	}
@@ -1253,23 +1379,23 @@ static phy_interface_t pfe_get_interface(struct net_device *dev)
 #endif
 
 /** pfe_get_phydev_speed
- */
+*/
 static int pfe_get_phydev_speed(struct phy_device *phydev)
 {
 	switch (phydev->speed) {
-		case 10:
+	case 10:
 			return SPEED_10M;
-		case 100:
+	case 100:
 			return SPEED_100M;
-		case 1000:
-		default:
+	case 1000:
+	default:
 			return SPEED_1000M;
 	}
 
 }
 
 /** pfe_set_rgmii_speed
- */
+*/
 #define RGMIIPCR	0x434
 /* RGMIIPCR bit definitions*/
 #define SCFG_RGMIIPCR_EN_AUTO           (0x00000008)
@@ -1286,14 +1412,14 @@ static void pfe_set_rgmii_speed(struct phy_device *phydev)
 	rgmii_pcr  &= ~(SCFG_RGMIIPCR_SETSP_1000M|SCFG_RGMIIPCR_SETSP_10M);
 
 	switch (phydev->speed) {
-		case 10:
+	case 10:
 			rgmii_pcr |= SCFG_RGMIIPCR_SETSP_10M;
 			break;
-		case 1000:
+	case 1000:
 			rgmii_pcr |= SCFG_RGMIIPCR_SETSP_1000M;
 			break;
-		case 100:
-		default:
+	case 100:
+	default:
 			/* Default is 100M */
 			break;
 	}
@@ -1302,15 +1428,15 @@ static void pfe_set_rgmii_speed(struct phy_device *phydev)
 
 }
 /** pfe_get_phydev_duplex
- */
+*/
 static int pfe_get_phydev_duplex(struct phy_device *phydev)
 {
-	//return ( phydev->duplex == DUPLEX_HALF ) ? DUP_HALF:DUP_FULL ;
+	/*return (phydev->duplex == DUPLEX_HALF) ? DUP_HALF:DUP_FULL ; */
 	return DUPLEX_FULL;
 }
 
 /** pfe_eth_adjust_link
- */
+*/
 static void pfe_eth_adjust_link(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1322,18 +1448,22 @@ static void pfe_eth_adjust_link(struct net_device *dev)
 
 	spin_lock_irqsave(&priv->lock, flags);
 	if (phydev->link) {
-		/* Now we make sure that we can be in full duplex mode.
-		 * If not, we operate in half-duplex mode. */
+		/*
+		 * Now we make sure that we can be in full duplex mode.
+		 * If not, we operate in half-duplex mode.
+		 */
 		if (phydev->duplex != priv->oldduplex) {
 			new_state = 1;
-			gemac_set_duplex(priv->EMAC_baseaddr, pfe_get_phydev_duplex(phydev));
+			gemac_set_duplex(priv->EMAC_baseaddr,
+						pfe_get_phydev_duplex(phydev));
 			priv->oldduplex = phydev->duplex;
 		}
 
 		if (phydev->speed != priv->oldspeed) {
 			new_state = 1;
-			gemac_set_speed(priv->EMAC_baseaddr, pfe_get_phydev_speed(phydev));
-			if(priv->einfo->mii_config == PHY_INTERFACE_MODE_RGMII)
+			gemac_set_speed(priv->EMAC_baseaddr,
+					pfe_get_phydev_speed(phydev));
+			if (priv->einfo->mii_config == PHY_INTERFACE_MODE_RGMII)
 				pfe_set_rgmii_speed(phydev);
 			priv->oldspeed = phydev->speed;
 		}
@@ -1358,7 +1488,7 @@ static void pfe_eth_adjust_link(struct net_device *dev)
 
 
 /** pfe_phy_exit
- */
+*/
 static void pfe_phy_exit(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1370,8 +1500,8 @@ static void pfe_phy_exit(struct net_device *dev)
 }
 
 /** pfe_eth_stop
- */
-static void pfe_eth_stop( struct net_device *dev , int wake)
+*/
+static void pfe_eth_stop(struct net_device *dev, int wake)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 
@@ -1389,8 +1519,8 @@ static void pfe_eth_stop( struct net_device *dev , int wake)
 }
 
 /** pfe_eth_start
- */
-static int pfe_eth_start( struct pfe_eth_priv_s *priv )
+*/
+static int pfe_eth_start(struct pfe_eth_priv_s *priv)
 {
 	netif_info(priv, drv, priv->dev, "%s\n", __func__);
 
@@ -1403,59 +1533,71 @@ static int pfe_eth_start( struct pfe_eth_priv_s *priv )
 	return 0;
 }
 
-/*Configure on chip serdes through mdio
- * Is there any better way to do this? */
+/*
+* Configure on chip serdes through mdio
+* Is there any better way to do this?
+*/
 static void ls1012a_configure_serdes(struct net_device *dev)
 {
-	struct pfe_eth_priv_s *priv = pfe->eth.eth_priv[0];  // FIXME This will not work for EMAC2 as SGMII
-        /*int value,sgmii_2500=0; */
+	struct pfe_eth_priv_s *priv = pfe->eth.eth_priv[0];
+	/* FIXME This will not work for EMAC2 as SGMII */
+	int sgmii_2500 = 0;
 	struct mii_bus *bus = priv->mii_bus;
 
+	if (priv->einfo->mii_config == PHY_INTERFACE_MODE_SGMII_2500)
+		sgmii_2500 = 1;
+
 	netif_info(priv, drv, dev, "%s\n", __func__);
-        /* PCS configuration done with corresponding GEMAC */
+	/* PCS configuration done with corresponding GEMAC */
 
 	pfe_eth_mdio_read(bus, 0, 0);
 	pfe_eth_mdio_read(bus, 0, 1);
 #if 1
-       /*These settings taken from validtion team */
-        pfe_eth_mdio_write(bus, 0, 0x0, 0x8000);
-        pfe_eth_mdio_write(bus, 0, 0x14, 0xb); 
-        pfe_eth_mdio_write(bus, 0, 0x4, 0x1a1);
-        pfe_eth_mdio_write(bus, 0, 0x12, 0x400);
-        pfe_eth_mdio_write(bus, 0, 0x13, 0x0);
-        pfe_eth_mdio_write(bus, 0, 0x0, 0x1140);
-        return;
-#else
-       /*Reset serdes */
-        pfe_eth_mdio_write(bus, 0, 0x0, 0x8000);
-
-        /* SGMII IF mode + AN enable only for 1G SGMII, not for 2.5G */
-        value = PHY_SGMII_IF_MODE_SGMII;
-        if (!sgmii_2500)
-                value |= PHY_SGMII_IF_MODE_AN;
-
-        pfe_eth_mdio_write(bus, 0, 0x14, value);
-
-        /* Dev ability according to SGMII specification */
-        value = PHY_SGMII_DEV_ABILITY_SGMII;
-        pfe_eth_mdio_write(bus, 0, 0x4, value);
-
-        //These values taken from validation team
-        pfe_eth_mdio_write(bus, 0, 0x13, 0x0);
-        pfe_eth_mdio_write(bus, 0, 0x12, 0x400);
+	/*These settings taken from validtion team */
+	pfe_eth_mdio_write(bus, 0, 0x0, 0x8000);
+	if (sgmii_2500) {
+		pfe_eth_mdio_write(bus, 0, 0x14, 0x9);
+		pfe_eth_mdio_write(bus, 0, 0x4, 0x4001);
+		pfe_eth_mdio_write(bus, 0, 0x12, 0xa120);
+		pfe_eth_mdio_write(bus, 0, 0x13, 0x7);
+	} else {
+		pfe_eth_mdio_write(bus, 0, 0x14, 0xb);
+		pfe_eth_mdio_write(bus, 0, 0x4, 0x1a1);
+		pfe_eth_mdio_write(bus, 0, 0x12, 0x400);
+		pfe_eth_mdio_write(bus, 0, 0x13, 0x0);
+	}
 
-        /* Restart AN */
-        value = PHY_SGMII_CR_DEF_VAL;
-        if (!sgmii_2500)
-                value |= PHY_SGMII_CR_RESET_AN;
-        pfe_eth_mdio_write(bus, 0, 0, value);
+	pfe_eth_mdio_write(bus, 0, 0x0, 0x1140);
+	return;
+#else
+	/*Reset serdes */
+	pfe_eth_mdio_write(bus, 0, 0x0, 0x8000);
+
+	/* SGMII IF mode + AN enable only for 1G SGMII, not for 2.5G */
+	value = PHY_SGMII_IF_MODE_SGMII;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_IF_MODE_AN;
+	pfe_eth_mdio_write(bus, 0, 0x14, value);
+	/* Dev ability according to SGMII specification */
+	value = PHY_SGMII_DEV_ABILITY_SGMII;
+	pfe_eth_mdio_write(bus, 0, 0x4, value);
+
+	/*These values taken from validation team */
+	pfe_eth_mdio_write(bus, 0, 0x13, 0x0);
+	pfe_eth_mdio_write(bus, 0, 0x12, 0x400);
+
+	/* Restart AN */
+	value = PHY_SGMII_CR_DEF_VAL;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_CR_RESET_AN;
+	pfe_eth_mdio_write(bus, 0, 0, value);
 
 #endif
 }
 
 /** pfe_phy_init
- *
- */
+*
+*/
 static int pfe_phy_init(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1469,23 +1611,25 @@ static int pfe_phy_init(struct net_device *dev)
 	priv->oldduplex = -1;
 
 	snprintf(bus_id, MII_BUS_ID_SIZE, "comcerto-%d", 0);
-	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id, priv->einfo->phy_id);
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
+			priv->einfo->phy_id);
 
 	netif_info(priv, drv, dev, "%s: %s\n", __func__, phy_id);
 #if defined(CONFIG_PLATFORM_C2000)
 	interface = pfe_get_interface(dev);
 #else
 	interface = priv->einfo->mii_config;
-	if(interface == PHY_INTERFACE_MODE_SGMII) {
+	if ((interface == PHY_INTERFACE_MODE_SGMII) ||
+	    (interface == PHY_INTERFACE_MODE_SGMII_2500)) {
 		/*Configure SGMII PCS */
-		if(pfe->scfg) {
+		if (pfe->scfg) {
 			/*Config MDIO from serdes */
 			regmap_write(pfe->scfg, 0x484, 0x00000000);
 		}
 		ls1012a_configure_serdes(dev);
 	}
 
-	if(pfe->scfg) {
+	if (pfe->scfg) {
 		/*Config MDIO from PAD */
 		regmap_write(pfe->scfg, 0x484, 0x80000000);
 	}
@@ -1496,8 +1640,8 @@ static int pfe_phy_init(struct net_device *dev)
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
 
-	printk("%s interface %x \n", __func__, interface);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	printk("%s interface %x\n", __func__, interface);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	phydev = phy_connect(dev, phy_id, &pfe_eth_adjust_link, interface);
 #else
 	phydev = phy_connect(dev, phy_id, &pfe_eth_adjust_link, 0, interface);
@@ -1515,9 +1659,11 @@ static int pfe_phy_init(struct net_device *dev)
 	/* Pause frame support */
 	phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
 	if (pfe_eth_pause_rx_enabled(priv))
-		phydev->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
+		phydev->advertising |= ADVERTISED_Pause |
+					ADVERTISED_Asym_Pause;
 	else
-		phydev->advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+		phydev->advertising &= ~(ADVERTISED_Pause |
+					ADVERTISED_Asym_Pause);
 #else
 	/*TODO Add pause frame support for LS1012A */
 #endif
@@ -1526,7 +1672,7 @@ static int pfe_phy_init(struct net_device *dev)
 }
 
 /** pfe_gemac_init
- */
+*/
 static int pfe_gemac_init(struct pfe_eth_priv_s *priv)
 {
 	GEMAC_CFG cfg;
@@ -1534,62 +1680,63 @@ static int pfe_gemac_init(struct pfe_eth_priv_s *priv)
 	netif_info(priv, ifup, priv->dev, "%s\n", __func__);
 
 	/* software config */
-	/* MII interface mode selection */ 
+	/* MII interface mode selection */
 	switch (priv->einfo->mii_config) {
-		case CONFIG_COMCERTO_USE_GMII:
+	case CONFIG_COMCERTO_USE_GMII:
 			cfg.mode = GMII;
 			break;
 
-		case CONFIG_COMCERTO_USE_MII:
+	case CONFIG_COMCERTO_USE_MII:
 			cfg.mode = MII;
 			break;
 
-		case CONFIG_COMCERTO_USE_RGMII:
+	case CONFIG_COMCERTO_USE_RGMII:
 			cfg.mode = RGMII;
 			break;
 
-		case CONFIG_COMCERTO_USE_RMII:
+	case CONFIG_COMCERTO_USE_RMII:
 			cfg.mode = RMII;
 			break;
 
-		case CONFIG_COMCERTO_USE_SGMII:
+	case CONFIG_COMCERTO_USE_SGMII:
 			cfg.mode = SGMII;
 			break;
 
-		default:
+	default:
 			cfg.mode = RGMII;
 	}
 
 	/* Speed selection */
-	switch (priv->einfo->gemac_mode & GEMAC_SW_SPEED_1G ) {
-		case GEMAC_SW_SPEED_1G:
+	switch (priv->einfo->gemac_mode & GEMAC_SW_SPEED_1G) {
+	case GEMAC_SW_SPEED_1G:
 			cfg.speed = SPEED_1000M;
 			break;
 
-		case GEMAC_SW_SPEED_100M:
+	case GEMAC_SW_SPEED_100M:
 			cfg.speed = SPEED_100M;
 			break;
 
-		case GEMAC_SW_SPEED_10M:
+	case GEMAC_SW_SPEED_10M:
 			cfg.speed = SPEED_10M;
 			break;
 
-		default:
+	default:
 			cfg.speed = SPEED_1000M;
 	}
 
 	/* Duplex selection */
-	cfg.duplex =  ( priv->einfo->gemac_mode & GEMAC_SW_FULL_DUPLEX ) ? DUPLEX_FULL : DUPLEX_HALF;
-
-	gemac_set_config( priv->EMAC_baseaddr, &cfg);
-	gemac_allow_broadcast( priv->EMAC_baseaddr );
-	gemac_disable_unicast( priv->EMAC_baseaddr );
-	gemac_disable_multicast( priv->EMAC_baseaddr );
-	gemac_disable_fcs_rx( priv->EMAC_baseaddr );
-	gemac_enable_1536_rx( priv->EMAC_baseaddr );
-	gemac_enable_rx_jmb( priv->EMAC_baseaddr );
-	gemac_enable_stacked_vlan( priv->EMAC_baseaddr );
-	gemac_enable_pause_rx( priv->EMAC_baseaddr );
+	cfg.duplex =  (priv->einfo->gemac_mode & GEMAC_SW_FULL_DUPLEX) ?
+			DUPLEX_FULL : DUPLEX_HALF;
+
+	gemac_set_config(priv->EMAC_baseaddr, &cfg);
+	gemac_allow_broadcast(priv->EMAC_baseaddr);
+	gemac_disable_unicast(priv->EMAC_baseaddr);
+	gemac_disable_multicast(priv->EMAC_baseaddr);
+	gemac_disable_fcs_rx(priv->EMAC_baseaddr);
+	gemac_enable_1536_rx(priv->EMAC_baseaddr);
+	gemac_enable_rx_jmb(priv->EMAC_baseaddr);
+	gemac_enable_stacked_vlan(priv->EMAC_baseaddr);
+	gemac_enable_pause_rx(priv->EMAC_baseaddr);
 	gemac_set_bus_width(priv->EMAC_baseaddr, 64);
 	/*TODO just for testing remove it later */
 	gemac_enable_copy_all(priv->EMAC_baseaddr);
@@ -1598,13 +1745,13 @@ static int pfe_gemac_init(struct pfe_eth_priv_s *priv)
 	if (priv->dev->features & NETIF_F_RXCSUM)
 		gemac_enable_rx_checksum_offload(priv->EMAC_baseaddr);
 	else
-		gemac_disable_rx_checksum_offload(priv->EMAC_baseaddr);	
+		gemac_disable_rx_checksum_offload(priv->EMAC_baseaddr);
 
 	return 0;
 }
 
 /** pfe_eth_event_handler
- */
+*/
 static int pfe_eth_event_handler(void *data, int event, int qno)
 {
 	struct pfe_eth_priv_s *priv = data;
@@ -1614,7 +1761,8 @@ static int pfe_eth_event_handler(void *data, int event, int qno)
 
 		if (qno == 0) {
 			if (napi_schedule_prep(&priv->high_napi)) {
-				netif_info(priv, intr, priv->dev, "%s: schedule high prio poll\n", __func__);
+				netif_info(priv, intr, priv->dev,
+				 "%s: schedule high prio poll\n", __func__);
 
 #ifdef PFE_ETH_NAPI_STATS
 				priv->napi_counters[NAPI_SCHED_COUNT]++;
@@ -1622,20 +1770,20 @@ static int pfe_eth_event_handler(void *data, int event, int qno)
 
 				__napi_schedule(&priv->high_napi);
 			}
-		}
-		else if (qno == 1) {
+		} else if (qno == 1) {
 			if (napi_schedule_prep(&priv->low_napi)) {
-				netif_info(priv, intr, priv->dev, "%s: schedule low prio poll\n", __func__);
+				netif_info(priv, intr, priv->dev,
+				"%s: schedule low prio poll\n", __func__);
 
 #ifdef PFE_ETH_NAPI_STATS
 				priv->napi_counters[NAPI_SCHED_COUNT]++;
 #endif
 				__napi_schedule(&priv->low_napi);
 			}
-		}
-		else if (qno == 2) {
+		} else if (qno == 2) {
 			if (napi_schedule_prep(&priv->lro_napi)) {
-				netif_info(priv, intr, priv->dev, "%s: schedule lro prio poll\n", __func__);
+				netif_info(priv, intr, priv->dev,
+				"%s: schedule lro prio poll\n", __func__);
 
 #ifdef PFE_ETH_NAPI_STATS
 				priv->napi_counters[NAPI_SCHED_COUNT]++;
@@ -1656,7 +1804,7 @@ static int pfe_eth_event_handler(void *data, int event, int qno)
 }
 
 /** pfe_eth_open
- */
+*/
 static int pfe_eth_open(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1680,11 +1828,13 @@ static int pfe_eth_open(struct net_device *dev)
 	client->rx_qsize = EMAC_RXQ_DEPTH;
 
 	if ((rc = hif_lib_client_register(client))) {
-		netdev_err(dev, "%s: hif_lib_client_register(%d) failed\n", __func__, client->id);
+		netdev_err(dev, "%s: hif_lib_client_register(%d) failed\n",
+				__func__, client->id);
 		goto err0;
 	}
 
-	netif_info(priv, drv, dev, "%s: registered client: %p\n", __func__,  client);
+	netif_info(priv, drv, dev, "%s: registered client: %p\n", __func__,
+			client);
 
 #if defined(CONFIG_PLATFORM_C2000)
 	/* Enable gemac tx clock */
@@ -1699,7 +1849,7 @@ static int pfe_eth_open(struct net_device *dev)
 		goto err1;
 	}
 
-	gemac_set_laddrN( priv->EMAC_baseaddr, ( MAC_ADDR *)dev->dev_addr, 1 );
+	gemac_set_laddrN(priv->EMAC_baseaddr, (MAC_ADDR *)dev->dev_addr, 1);
 
 	napi_enable(&priv->high_napi);
 	napi_enable(&priv->low_napi);
@@ -1709,9 +1859,10 @@ static int pfe_eth_open(struct net_device *dev)
 
 	netif_tx_wake_all_queues(dev);
 
-	//pfe_ctrl_set_eth_state(priv->id, 1, dev->dev_addr);
+	/*pfe_ctrl_set_eth_state(priv->id, 1, dev->dev_addr); */
 
-	priv->tx_timer.expires = jiffies + ( COMCERTO_TX_RECOVERY_TIMEOUT_MS * HZ )/1000;
+	priv->tx_timer.expires = jiffies + (COMCERTO_TX_RECOVERY_TIMEOUT_MS *
+						HZ)/1000;
 	add_timer(&priv->tx_timer);
 
 	return rc;
@@ -1726,20 +1877,21 @@ err0:
 	return rc;
 }
 /*
- *  pfe_eth_shutdown
- */
-int pfe_eth_shutdown( struct net_device *dev, int wake)
+*  pfe_eth_shutdown
+*/
+int pfe_eth_shutdown(struct net_device *dev, int wake)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	int i, qstatus;
-	unsigned long next_poll = jiffies + 1, end = jiffies + (TX_POLL_TIMEOUT_MS * HZ) / 1000;
+	unsigned long next_poll = jiffies + 1, end = jiffies +
+				(TX_POLL_TIMEOUT_MS * HZ) / 1000;
 	int tx_pkts, prv_tx_pkts;
 
 	netif_info(priv, ifdown, dev, "%s\n", __func__);
 
 	del_timer_sync(&priv->tx_timer);
 
-	for(i = 0; i < emac_txq_cnt; i++)
+	for (i = 0; i < emac_txq_cnt; i++)
 		hrtimer_cancel(&priv->fast_tx_timeout[i].timer);
 
 	netif_tx_stop_all_queues(dev);
@@ -1748,45 +1900,51 @@ int pfe_eth_shutdown( struct net_device *dev, int wake)
 		tx_pkts = 0;
 		pfe_eth_flush_tx(priv, 1);
 
-		for (i = 0; i < emac_txq_cnt; i++) 
+		for (i = 0; i < emac_txq_cnt; i++)
 			tx_pkts += hif_lib_tx_pending(&priv->client, i);
 
 		if (tx_pkts) {
 			/*Don't wait forever, break if we cross max timeout */
 			if (time_after(jiffies, end)) {
-				printk(KERN_ERR "(%s)Tx is not complete after %dmsec\n", dev->name, TX_POLL_TIMEOUT_MS);
+				printk(KERN_ERR
+					"(%s)Tx is not complete after %dmsec\n",
+					 dev->name, TX_POLL_TIMEOUT_MS);
 				break;
 			}
 
-			printk("%s : (%s) Waiting for tx packets to free. Pending tx pkts = %d.\n", __func__, dev->name, tx_pkts);
+			printk("%s : (%s) Waiting for tx packets to free. Pending tx pkts = %d.\n"
+				, __func__, dev->name, tx_pkts);
 			if (need_resched())
 				schedule();
 		}
 
-	} while(tx_pkts);
+	} while (tx_pkts);
 
 	end = jiffies + (TX_POLL_TIMEOUT_MS * HZ) / 1000;
 	/*Disable transmit in PFE before disabling GEMAC */
-	//pfe_ctrl_set_eth_state(priv->id, 0, NULL);
+	/*pfe_ctrl_set_eth_state(priv->id, 0, NULL); */
 
 	prv_tx_pkts = tmu_pkts_processed(priv->id);
-	/*Wait till TMU transmits all pending packets
+	/*
+	* Wait till TMU transmits all pending packets
 	* poll tmu_qstatus and pkts processed by TMU for every 10ms
-	* Consider TMU is busy, If we see TMU qeueu pending or any packets processed by TMU
+	* Consider TMU is busy, If we see TMU qeueu pending or any packets
+	* processed by TMU
 	*/
-	while(1) {
+	while (1) {
 
 		if (time_after(jiffies, next_poll)) {
 
 			tx_pkts = tmu_pkts_processed(priv->id);
 			qstatus = tmu_qstatus(priv->id) & 0x7ffff;
 
-			if(!qstatus && (tx_pkts == prv_tx_pkts)) {
+			if (!qstatus && (tx_pkts == prv_tx_pkts))
 				break;
-			}
-			/*Don't wait forever, break if we cross max timeout(TX_POLL_TIMEOUT_MS) */
+			/*Don't wait forever, break if we cross max
+			timeout(TX_POLL_TIMEOUT_MS) */
 			if (time_after(jiffies, end)) {
-				printk(KERN_ERR "TMU%d is busy after %dmsec\n", priv->id, TX_POLL_TIMEOUT_MS);
+				printk(KERN_ERR "TMU%d is busy after %dmsec\n",
+					 priv->id, TX_POLL_TIMEOUT_MS);
 				break;
 			}
 			prv_tx_pkts = tx_pkts;
@@ -1799,7 +1957,7 @@ int pfe_eth_shutdown( struct net_device *dev, int wake)
 	}
 	/* Wait for some more time to complete transmitting packet if any */
 	next_poll = jiffies + 1;
-	while(1) {
+	while (1) {
 		if (time_after(jiffies, next_poll))
 			break;
 		if (need_resched())
@@ -1823,9 +1981,9 @@ int pfe_eth_shutdown( struct net_device *dev, int wake)
 }
 
 /* pfe_eth_close
- *
- */
-static int pfe_eth_close( struct net_device *dev )
+*
+*/
+static int pfe_eth_close(struct net_device *dev)
 {
 	pfe_eth_shutdown(dev, 0);
 
@@ -1833,10 +1991,10 @@ static int pfe_eth_close( struct net_device *dev )
 }
 
 /* pfe_eth_suspend
- *
- * return value : 1 if netdevice is configured to wakeup system
- *                0 otherwise
- */
+*
+* return value : 1 if netdevice is configured to wakeup system
+*                0 otherwise
+*/
 int pfe_eth_suspend(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1852,8 +2010,8 @@ int pfe_eth_suspend(struct net_device *dev)
 }
 
 /** pfe_eth_resume
- *
- */
+*
+*/
 int pfe_eth_resume(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -1866,43 +2024,49 @@ int pfe_eth_resume(struct net_device *dev)
 
 #if defined(CONFIG_PLATFORM_C2000)
 /** pfe_eth_set_device_wakeup
- *
- *  Called when a netdevice changes its wol status.
- *  Scans state of all interfaces and updae PFE device
- *  wakeable state
- */
+*
+*  Called when a netdevice changes its wol status.
+*  Scans state of all interfaces and updae PFE device
+*  wakeable state
+*/
 static void pfe_eth_set_device_wakeup(struct pfe *pfe)
 {
 	int i;
 	int wake = 0;
 
-	for(i = 0; i < NUM_GEMAC_SUPPORT; i++)
+	for (i = 0; i < NUM_GEMAC_SUPPORT; i++)
 			wake |= pfe->eth.eth_priv[i]->wol;
 
 	device_set_wakeup_enable(pfe->dev, wake);
-	//TODO Find correct IRQ mapping.
-	//TODO interface with PMU
-	//int irq_set_irq_wake(unsigned int irq, unsigned int on)
+	/*TODO Find correct IRQ mapping. */
+	/*TODO interface with PMU */
+	/*int irq_set_irq_wake(unsigned int irq, unsigned int on) */
 }
 #endif
 /** pfe_eth_get_queuenum
- *
- */
-static int pfe_eth_get_queuenum( struct pfe_eth_priv_s *priv, struct sk_buff *skb )
+*
+*/
+static int pfe_eth_get_queuenum(struct pfe_eth_priv_s *priv, struct sk_buff
+					*skb)
 {
 	int queuenum = 0;
 	unsigned long flags;
 
 	/* Get the Fast Path queue number */
-	/* Use conntrack mark (if conntrack exists), then packet mark (if any), then fallback to default */
+	/*
+	* Use conntrack mark (if conntrack exists), then packet mark (if any),
+	* then fallback to default
+	*/
 #if defined(CONFIG_IP_NF_CONNTRACK_MARK) || defined(CONFIG_NF_CONNTRACK_MARK)
 	if (skb->nfct) {
 		enum ip_conntrack_info cinfo;
 		struct nf_conn *ct;
+
 		ct = nf_ct_get(skb, &cinfo);
 
 		if (ct) {
 			u_int32_t connmark;
+
 			connmark = ct->mark;
 
 			if ((connmark & 0x80000000) && priv->id != 0)
@@ -1910,15 +2074,14 @@ static int pfe_eth_get_queuenum( struct pfe_eth_priv_s *priv, struct sk_buff *sk
 
 			queuenum = connmark & EMAC_QUEUENUM_MASK;
 		}
-	}
-	else  /* continued after #endif ... */
+	} else  /* continued after #endif ... */
 #endif
 		if (skb->mark)
 			queuenum = skb->mark & EMAC_QUEUENUM_MASK;
 		else {
-			spin_lock_irqsave(&priv->lock, flags);	
+			spin_lock_irqsave(&priv->lock, flags);
 			queuenum = priv->default_priority & EMAC_QUEUENUM_MASK;
-			spin_unlock_irqrestore(&priv->lock, flags);	
+			spin_unlock_irqrestore(&priv->lock, flags);
 		}
 
 	return queuenum;
@@ -1927,9 +2090,12 @@ static int pfe_eth_get_queuenum( struct pfe_eth_priv_s *priv, struct sk_buff *sk
 
 
 /** pfe_eth_might_stop_tx
- *
- */
-static int pfe_eth_might_stop_tx(struct pfe_eth_priv_s *priv, int queuenum, struct netdev_queue *tx_queue, unsigned int n_desc, unsigned int n_segs)
+*
+*/
+static int pfe_eth_might_stop_tx(struct pfe_eth_priv_s *priv, int queuenum,
+					struct netdev_queue *tx_queue,
+					unsigned int n_desc,
+					unsigned int n_segs)
 {
 	int tried = 0;
 	ktime_t kt;
@@ -1952,29 +2118,31 @@ try_again:
 			priv->stop_queue_hif[queuenum]++;
 		else if (hif_lib_tx_avail(&priv->client, queuenum) < n_desc) {
 			priv->stop_queue_hif_client[queuenum]++;
-		}
-		else if (hif_lib_tx_credit_avail(pfe, priv->id, queuenum) < n_segs) {
+		} else if (hif_lib_tx_credit_avail(pfe, priv->id, queuenum) <
+			n_segs) {
 			priv->stop_queue_credit[queuenum]++;
 		}
 		priv->stop_queue_total[queuenum]++;
 #endif
 		netif_tx_stop_queue(tx_queue);
 
-		kt = ktime_set(0, COMCERTO_TX_FAST_RECOVERY_TIMEOUT_MS * NSEC_PER_MSEC);
-		hrtimer_start(&priv->fast_tx_timeout[queuenum].timer, kt, HRTIMER_MODE_REL);
+		kt = ktime_set(0, COMCERTO_TX_FAST_RECOVERY_TIMEOUT_MS *
+				NSEC_PER_MSEC);
+		hrtimer_start(&priv->fast_tx_timeout[queuenum].timer, kt,
+				HRTIMER_MODE_REL);
 		return -1;
-	}
-	else {
+	} else {
 		return 0;
 	}
 }
 
 #define SA_MAX_OP 2
 /** pfe_hif_send_packet
- *
- * At this level if TX fails we drop the packet
- */
-static void pfe_hif_send_packet( struct sk_buff *skb, struct  pfe_eth_priv_s *priv, int queuenum)
+*
+* At this level if TX fails we drop the packet
+*/
+static void pfe_hif_send_packet(struct sk_buff *skb, struct  pfe_eth_priv_s
+					*priv, int queuenum)
 {
 	struct skb_shared_info *sh = skb_shinfo(skb);
 	unsigned int nr_frags;
@@ -1992,12 +2160,11 @@ static void pfe_hif_send_packet( struct sk_buff *skb, struct  pfe_eth_priv_s *pr
 			skb->ip_summed = 0;
 			ctrl = 0;
 
-			if (pfe_compute_csum(skb)){
+			if (pfe_compute_csum(skb)) {
 				kfree_skb(skb);
 				return;
 			}
-		}
-		else
+		} else
 			ctrl = HIF_CTRL_TX_CHECKSUM;
 	}
 
@@ -2007,22 +2174,35 @@ static void pfe_hif_send_packet( struct sk_buff *skb, struct  pfe_eth_priv_s *pr
 		skb_frag_t *f;
 		int i;
 
-		__hif_lib_xmit_pkt(&priv->client, queuenum, skb->data, skb_headlen(skb), ctrl, HIF_FIRST_BUFFER, skb);
+		__hif_lib_xmit_pkt(&priv->client, queuenum, skb->data,
+				skb_headlen(skb), ctrl, HIF_FIRST_BUFFER, skb);
 
 		for (i = 0; i < nr_frags - 1; i++) {
 			f = &sh->frags[i];
-			__hif_lib_xmit_pkt(&priv->client, queuenum, skb_frag_address(f), skb_frag_size(f), 0x0, 0x0, skb);
+			__hif_lib_xmit_pkt(&priv->client, queuenum,
+						skb_frag_address(f),
+						skb_frag_size(f),
+						0x0, 0x0, skb);
 		}
 
 		f = &sh->frags[i];
 
-		__hif_lib_xmit_pkt(&priv->client, queuenum, skb_frag_address(f), skb_frag_size(f), 0x0, HIF_LAST_BUFFER|HIF_DATA_VALID, skb);
+		__hif_lib_xmit_pkt(&priv->client, queuenum,
+					skb_frag_address(f), skb_frag_size(f),
+					0x0, HIF_LAST_BUFFER | HIF_DATA_VALID,
+					skb);
 
-		netif_info(priv, tx_queued, priv->dev, "%s: pkt sent successfully skb:%p nr_frags:%d len:%d\n", __func__, skb, nr_frags, skb->len);
-	}
-	else {
-		__hif_lib_xmit_pkt(&priv->client, queuenum, skb->data, skb->len, ctrl, HIF_FIRST_BUFFER | HIF_LAST_BUFFER | HIF_DATA_VALID, skb);
-		netif_info(priv, tx_queued, priv->dev, "%s: pkt sent successfully skb:%p len:%d\n", __func__, skb, skb->len);
+		netif_info(priv, tx_queued, priv->dev,
+			 "%s: pkt sent successfully skb:%p nr_frags:%d len:%d\n",
+				 __func__, skb, nr_frags, skb->len);
+	} else {
+		__hif_lib_xmit_pkt(&priv->client, queuenum, skb->data,
+					skb->len, ctrl, HIF_FIRST_BUFFER |
+					HIF_LAST_BUFFER | HIF_DATA_VALID,
+					skb);
+		netif_info(priv, tx_queued, priv->dev,
+			 "%s: pkt sent successfully skb:%p len:%d\n",
+			 __func__, skb, skb->len);
 	}
 	hif_tx_dma_start();
 	priv->stats.tx_packets++;
@@ -2031,11 +2211,13 @@ static void pfe_hif_send_packet( struct sk_buff *skb, struct  pfe_eth_priv_s *pr
 }
 
 /** pfe_eth_flush_txQ
- */
-static void pfe_eth_flush_txQ(struct pfe_eth_priv_s *priv, int txQ_num, int from_tx, int n_desc)
+*/
+static void pfe_eth_flush_txQ(struct pfe_eth_priv_s *priv, int txQ_num, int
+				from_tx, int n_desc)
 {
 	struct sk_buff *skb;
-	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, txQ_num);
+	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+								txQ_num);
 	int count = max(TX_FREE_MAX_COUNT, n_desc);
 	unsigned int flags;
 
@@ -2045,24 +2227,22 @@ static void pfe_eth_flush_txQ(struct pfe_eth_priv_s *priv, int txQ_num, int from
 		__netif_tx_lock_bh(tx_queue);
 
 	/* Clean HIF and client queue */
-	while (count && (skb = hif_lib_tx_get_next_complete(&priv->client, txQ_num, &flags, count))) {
+	while (count && (skb = hif_lib_tx_get_next_complete(&priv->client,
+					txQ_num, &flags, count))) {
 
 		/* FIXME : Invalid data can be skipped in hif_lib itself */
-		if (flags & HIF_DATA_VALID) {
+		if (flags & HIF_DATA_VALID)
 			dev_kfree_skb_any(skb);
-
-		}
-		// When called from the timer, flush all descriptors
+		/* When called from the timer, flush all descriptors */
 		if (from_tx)
 			count--;
 	}
-
 	if (!from_tx)
 		__netif_tx_unlock_bh(tx_queue);
 }
 
 /** pfe_eth_flush_tx
- */
+*/
 static void pfe_eth_flush_tx(struct pfe_eth_priv_s *priv, int force)
 {
 	int ii;
@@ -2070,46 +2250,57 @@ static void pfe_eth_flush_tx(struct pfe_eth_priv_s *priv, int force)
 	netif_info(priv, tx_done, priv->dev, "%s\n", __func__);
 
 	for (ii = 0; ii < emac_txq_cnt; ii++) {
-		if (force || (time_after(jiffies, priv->client.tx_q[ii].jiffies_last_packet + (COMCERTO_TX_RECOVERY_TIMEOUT_MS * HZ)/1000))) {
-			pfe_eth_flush_txQ(priv, ii, 0, 0); //We will release everything we can based on from_tx param, so the count param can be set to any value
+		if (force || (time_after(jiffies,
+			priv->client.tx_q[ii].jiffies_last_packet +
+			(COMCERTO_TX_RECOVERY_TIMEOUT_MS *
+				HZ)/1000))) {
+			/*We will release everything we can based on
+			* from_tx param,so the count param can be set
+			* to any value
+			*/
+			pfe_eth_flush_txQ(priv, ii, 0, 0);
 			hif_lib_update_credit(&priv->client, ii);
 		}
 	}
 }
 
-void pfe_tx_get_req_desc(struct sk_buff *skb, unsigned int *n_desc, unsigned int *n_segs)
+void pfe_tx_get_req_desc(struct sk_buff *skb, unsigned int *n_desc, unsigned int
+				*n_segs)
 {
 	struct skb_shared_info *sh = skb_shinfo(skb);
 
-	// Scattered data
+	/* Scattered data */
 	if (sh->nr_frags) {
 		*n_desc = sh->nr_frags + 1;
 		*n_segs = 1;
 	}
-	// Regular case
+	/* Regular case */
 	else {
 		*n_desc = 1;
 		*n_segs = 1;
 	}
-	return;
 }
 
 /** pfe_eth_send_packet
- */
+*/
 static int pfe_eth_send_packet(struct sk_buff *skb, struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 	int txQ_num = skb_get_queue_mapping(skb);
 	int n_desc, n_segs, count;
-	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, txQ_num);
+	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+								txQ_num);
 
 	netif_info(priv, tx_queued, dev, "%s\n", __func__);
 
-	if ((!skb_is_gso(skb)) && (skb_headroom(skb) < (PFE_PKT_HEADER_SZ + sizeof(unsigned long)))) {
+	if ((!skb_is_gso(skb)) && (skb_headroom(skb) < (PFE_PKT_HEADER_SZ +
+			sizeof(unsigned long)))) {
 
-		netif_warn(priv, tx_err, priv->dev, "%s: copying skb\n", __func__);
+		netif_warn(priv, tx_err, priv->dev, "%s: copying skb\n",
+				__func__);
 
-		if (pskb_expand_head(skb, (PFE_PKT_HEADER_SZ + sizeof(unsigned long)), 0, GFP_ATOMIC)) {
+		if (pskb_expand_head(skb, (PFE_PKT_HEADER_SZ + sizeof(unsigned
+					long)), 0, GFP_ATOMIC)) {
 			/* No need to re-transmit, no way to recover*/
 			kfree_skb(skb);
 			priv->stats.tx_dropped++;
@@ -2120,9 +2311,10 @@ static int pfe_eth_send_packet(struct sk_buff *skb, struct net_device *dev)
 	pfe_tx_get_req_desc(skb, &n_desc, &n_segs);
 
 	hif_tx_lock(&pfe->hif);
-	if(unlikely(pfe_eth_might_stop_tx(priv, txQ_num, tx_queue, n_desc, n_segs))) {
+	if (unlikely(pfe_eth_might_stop_tx(priv, txQ_num, tx_queue, n_desc,
+			n_segs))) {
 #ifdef PFE_ETH_TX_STATS
-		if(priv->was_stopped[txQ_num]) {
+		if (priv->was_stopped[txQ_num]) {
 			priv->clean_fail[txQ_num]++;
 			priv->was_stopped[txQ_num] = 0;
 		}
@@ -2137,9 +2329,14 @@ static int pfe_eth_send_packet(struct sk_buff *skb, struct net_device *dev)
 
 	dev->trans_start = jiffies;
 
-	// Recycle buffers if a socket's send buffer becomes half full or if the HIF client queue starts filling up
-	if (((count = (hif_lib_tx_pending(&priv->client, txQ_num) - HIF_CL_TX_FLUSH_MARK)) > 0)
-		|| (skb->sk && ((sk_wmem_alloc_get(skb->sk) << 1) > skb->sk->sk_sndbuf)))
+	/*
+	* Recycle buffers if a socket's send buffer becomes half full or if
+	* the HIF client queue starts filling up
+	*/
+	if (((count = (hif_lib_tx_pending(&priv->client, txQ_num) -
+			HIF_CL_TX_FLUSH_MARK)) > 0)
+		|| (skb->sk && ((sk_wmem_alloc_get(skb->sk) << 1) >
+			skb->sk->sk_sndbuf)))
 		pfe_eth_flush_txQ(priv, txQ_num, 1, count);
 
 #ifdef PFE_ETH_TX_STATS
@@ -2150,13 +2347,14 @@ static int pfe_eth_send_packet(struct sk_buff *skb, struct net_device *dev)
 }
 
 /** pfe_eth_select_queue
- *
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
-static u16 pfe_eth_select_queue( struct net_device *dev, struct sk_buff *skb,
-		void *accel_priv, select_queue_fallback_t fallback)
+*
+*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+static u16 pfe_eth_select_queue(struct net_device *dev, struct sk_buff *skb,
+				void *accel_priv,
+				select_queue_fallback_t fallback)
 #else
-static u16 pfe_eth_select_queue( struct net_device *dev, struct sk_buff *skb )
+static u16 pfe_eth_select_queue(struct net_device *dev, struct sk_buff *skb)
 #endif
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -2166,7 +2364,7 @@ static u16 pfe_eth_select_queue( struct net_device *dev, struct sk_buff *skb )
 
 
 /** pfe_eth_get_stats
- */
+*/
 static struct net_device_stats *pfe_eth_get_stats(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -2178,12 +2376,12 @@ static struct net_device_stats *pfe_eth_get_stats(struct net_device *dev)
 
 
 /** pfe_eth_change_mtu
- */
+*/
 static int pfe_eth_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
-	int oldsize = dev->mtu ;
-	int frame_size = new_mtu + ETH_HLEN +4;
+	int oldsize = dev->mtu;
+	int frame_size = new_mtu + ETH_HLEN + 4;
 
 	netif_info(priv, drv, dev, "%s\n", __func__);
 
@@ -2192,29 +2390,28 @@ static int pfe_eth_change_mtu(struct net_device *dev, int new_mtu)
 		return -EINVAL;
 	}
 
-	if ((new_mtu > 1500) && (dev->features & NETIF_F_TSO))
-	{
+	if ((new_mtu > 1500) && (dev->features & NETIF_F_TSO)) {
 		priv->usr_features = dev->features;
-		if (dev->features & NETIF_F_TSO)
-		{
-			netdev_err(dev, "MTU cannot be set to more than 1500 while TSO is enabled. disabling TSO.\n");
+		if (dev->features & NETIF_F_TSO) {
+			netdev_err(dev,
+			 "MTU cannot be set to more than 1500 while TSO is enabled. disabling TSO.\n");
 			dev->features &= ~(NETIF_F_TSO);
 		}
-	}
-	else if ((dev->mtu > 1500) && (new_mtu <= 1500))
-	{
-		if (priv->usr_features & NETIF_F_TSO)
-		{
+	} else if ((dev->mtu > 1500) && (new_mtu <= 1500)) {
+		if (priv->usr_features & NETIF_F_TSO) {
 			priv->usr_features &= ~(NETIF_F_TSO);
 			dev->features |= NETIF_F_TSO;
 			netdev_err(dev, "MTU is <= 1500, Enabling TSO feature.\n");
 		}
 	}
 
-	/* Only stop and start the controller if it isn't already
-	 * stopped, and we changed something */
-	if ((oldsize != new_mtu) && (dev->flags & IFF_UP)){
-		netdev_err(dev, "Can not change MTU - fast_path must be disabled and ifconfig down must be issued first\n");
+	/*
+	* Only stop and start the controller if it isn't already
+	* stopped, and we changed something
+	*/
+	if ((oldsize != new_mtu) && (dev->flags & IFF_UP)) {
+		netdev_err(dev,
+		"Can not change MTU - fast_path must be disabled and ifconfig down must be issued first\n");
 
 		return -EINVAL;
 	}
@@ -2225,7 +2422,7 @@ static int pfe_eth_change_mtu(struct net_device *dev, int new_mtu)
 }
 
 /** pfe_eth_set_mac_address
- */
+*/
 static int pfe_eth_set_mac_address(struct net_device *dev, void *addr)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
@@ -2245,15 +2442,13 @@ static int pfe_eth_set_mac_address(struct net_device *dev, void *addr)
 }
 
 /** pfe_eth_enet_addr_byte_mac
- */
-int pfe_eth_enet_addr_byte_mac(u8 * enet_byte_addr, MAC_ADDR *enet_addr)
+*/
+int pfe_eth_enet_addr_byte_mac(u8 *enet_byte_addr, MAC_ADDR *enet_addr)
 {
-	if ((enet_byte_addr == NULL) || (enet_addr == NULL))
-	{
+	if ((enet_byte_addr == NULL) || (enet_addr == NULL)) {
 		return -1;
-	}
-	else
-	{
+
+	} else {
 		enet_addr->bottom = enet_byte_addr[0] |
 			(enet_byte_addr[1] << 8) |
 			(enet_byte_addr[2] << 16) |
@@ -2267,14 +2462,15 @@ int pfe_eth_enet_addr_byte_mac(u8 * enet_byte_addr, MAC_ADDR *enet_addr)
 
 
 /** pfe_eth_set_multi
- */
+*/
 static void pfe_eth_set_multi(struct net_device *dev)
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
-	MAC_ADDR    hash_addr;          /* hash register structure */
-	MAC_ADDR    spec_addr;		/* specific mac address register structure */
-	int         result;          /* index into hash register to set.. */
-	int 	    uc_count = 0;
+	MAC_ADDR    hash_addr; /* hash register structure */
+	/* specific mac address	register structure */
+	MAC_ADDR    spec_addr;
+	int		result; /* index into hash register to set.. */
+	int		uc_count = 0;
 	struct netdev_hw_addr *ha;
 
 	if (dev->flags & IFF_PROMISC) {
@@ -2291,7 +2487,8 @@ static void pfe_eth_set_multi(struct net_device *dev)
 	if (dev->flags & IFF_BROADCAST) {
 		gemac_allow_broadcast(priv->EMAC_baseaddr);
 	} else {
-		netif_info(priv, drv, dev, "disabling broadcast frame reception\n");
+		netif_info(priv, drv, dev,
+		"disabling broadcast frame reception\n");
 
 		gemac_no_broadcast(priv->EMAC_baseaddr);
 	}
@@ -2303,9 +2500,11 @@ static void pfe_eth_set_multi(struct net_device *dev)
 		gemac_set_hash(priv->EMAC_baseaddr, &hash_addr);
 		gemac_enable_multicast(priv->EMAC_baseaddr);
 		netdev_for_each_uc_addr(ha, dev) {
-			if(uc_count >= MAX_UC_SPEC_ADDR_REG) break;
+			if (uc_count >= MAX_UC_SPEC_ADDR_REG)
+				break;
 			pfe_eth_enet_addr_byte_mac(ha->addr, &spec_addr);
-			gemac_set_laddrN(priv->EMAC_baseaddr, &spec_addr, uc_count + 2);
+			gemac_set_laddrN(priv->EMAC_baseaddr, &spec_addr,
+						uc_count + 2);
 			uc_count++;
 		}
 	} else if ((netdev_mc_count(dev) > 0)  || (netdev_uc_count(dev))) {
@@ -2317,19 +2516,21 @@ static void pfe_eth_set_multi(struct net_device *dev)
 		netdev_for_each_mc_addr(ha, dev) {
 			addr = ha->addr;
 
-			netif_info(priv, drv, dev, "adding multicast address %X:%X:%X:%X:%X:%X to gem filter\n",
-						addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+			netif_info(priv, drv, dev,
+			 "adding multicast address %X:%X:%X:%X:%X:%X to gem filter\n",
+				addr[0], addr[1], addr[2],
+				addr[3], addr[4], addr[5]);
 
 			result = pfe_eth_get_hash(addr);
 
-			if (result >= EMAC_HASH_REG_BITS) {
+			if (result >= EMAC_HASH_REG_BITS)
 				break;
-			} else {
-				if (result < 32) {
+
+			else {
+				if (result < 32)
 					hash_addr.bottom |= (1 << result);
-				} else {
+				else
 					hash_addr.top |= (1 << (result - 32));
-				}
 			}
 
 		}
@@ -2338,29 +2539,31 @@ static void pfe_eth_set_multi(struct net_device *dev)
 		netdev_for_each_uc_addr(ha, dev) {
 			addr = ha->addr;
 
-			if(++uc_count < MAX_UC_SPEC_ADDR_REG)  
-			{
-				netdev_info(dev, "adding unicast address %02x:%02x:%02x:%02x:%02x:%02x to gem filter\n",
+			if (++uc_count < MAX_UC_SPEC_ADDR_REG)   {
+				netdev_info(dev,
+			"adding unicast address %02x:%02x:%02x:%02x:%02x:%02x to gem filter\n",
 						addr[0], addr[1], addr[2],
 						addr[3], addr[4], addr[5]);
-
 				pfe_eth_enet_addr_byte_mac(addr, &spec_addr);
-				gemac_set_laddrN(priv->EMAC_baseaddr, &spec_addr, uc_count + 2);
-			}
-			else
-			{
-				netif_info(priv, drv, dev, "adding unicast address %02x:%02x:%02x:%02x:%02x:%02x to gem hash\n",
-							addr[0], addr[1], addr[2],
-							addr[3], addr[4], addr[5]);
+				gemac_set_laddrN(priv->EMAC_baseaddr,
+						&spec_addr, uc_count + 2);
+			} else {
+					netif_info(priv, drv, dev,
+						"adding unicast address %02x:%02x:%02x:%02x:%02x:%02x to gem hash\n",
+						addr[0], addr[1], addr[2],
+						addr[3], addr[4], addr[5]);
 
 				result = pfe_eth_get_hash(addr);
 				if (result >= EMAC_HASH_REG_BITS) {
 					break;
+
 				} else {
 					if (result < 32)
-						hash_addr.bottom |= (1 << result);
+						hash_addr.bottom |= (1 <<
+								result);
 					else
-						hash_addr.top |= (1 << (result - 32));
+						hash_addr.top |= (1 <<
+								(result - 32));
 				}
 
 
@@ -2368,36 +2571,36 @@ static void pfe_eth_set_multi(struct net_device *dev)
 		}
 
 		gemac_set_hash(priv->EMAC_baseaddr, &hash_addr);
-		if(netdev_mc_count(dev))
+		if (netdev_mc_count(dev))
 			gemac_enable_multicast(priv->EMAC_baseaddr);
 		else
-			gemac_disable_multicast(priv->EMAC_baseaddr);		
+			gemac_disable_multicast(priv->EMAC_baseaddr);
 	}
 
-	if(netdev_uc_count(dev) >= MAX_UC_SPEC_ADDR_REG)
+	if (netdev_uc_count(dev) >= MAX_UC_SPEC_ADDR_REG)
 		gemac_enable_unicast(priv->EMAC_baseaddr);
-	else
-	{
-		/* Check if there are any specific address HW registers that need 
-		 *  to be flushed 
-		 *  */
-		for(uc_count = netdev_uc_count(dev); uc_count < MAX_UC_SPEC_ADDR_REG; uc_count++) 
+	else {
+		/*
+		*  Check if there are any specific address HW registers that
+		* need to be flushed
+		*/
+		for (uc_count = netdev_uc_count(dev); uc_count <
+			MAX_UC_SPEC_ADDR_REG; uc_count++)
 			gemac_clear_laddrN(priv->EMAC_baseaddr, uc_count + 2);
 
 		gemac_disable_unicast(priv->EMAC_baseaddr);
 	}
 
-	if (dev->flags & IFF_LOOPBACK) {
+	if (dev->flags & IFF_LOOPBACK)
 		gemac_set_loop(priv->EMAC_baseaddr, LB_LOCAL);
-	}
 
-	return;
 }
 
 /** pfe_eth_set_features
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
-static int pfe_eth_set_features(struct net_device *dev, netdev_features_t features)
+*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int pfe_eth_set_features(struct net_device *dev, netdev_features_t
+					features)
 #else
 static int pfe_eth_set_features(struct net_device *dev, u32 features)
 #endif
@@ -2413,22 +2616,22 @@ static int pfe_eth_set_features(struct net_device *dev, u32 features)
 }
 
 /** pfe_eth_fix_features
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
-static netdev_features_t pfe_eth_fix_features(struct net_device *dev, netdev_features_t features)
+*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static netdev_features_t pfe_eth_fix_features(struct net_device *dev,
+						netdev_features_t features)
 #else
-static unsigned int pfe_eth_fix_features(struct net_device *dev,u32 features)
+static unsigned int pfe_eth_fix_features(struct net_device *dev, u32 features)
 #endif
 {
 	struct pfe_eth_priv_s *priv = netdev_priv(dev);
 
-	if (dev->mtu > 1500)
-	{
-		if (features & (NETIF_F_TSO))
-		{
+	if (dev->mtu > 1500) {
+		if (features & (NETIF_F_TSO)) {
 			priv->usr_features |= NETIF_F_TSO;
 			features &= ~(NETIF_F_TSO);
-			netdev_err(dev, "TSO cannot be enabled when the MTU is larger than 1500. Please set the MTU to 1500 or lower first.\n");
+			netdev_err(dev,
+				 "TSO cannot be enabled when the MTU is larger than 1500. Please set the MTU to 1500 or lower first.\n");
 		}
 	}
 
@@ -2436,8 +2639,8 @@ static unsigned int pfe_eth_fix_features(struct net_device *dev,u32 features)
 }
 
 /** pfe_eth_tx_timeout
- */
-void pfe_eth_tx_timeout(unsigned long data )
+*/
+void pfe_eth_tx_timeout(unsigned long data)
 {
 	struct pfe_eth_priv_s *priv = (struct pfe_eth_priv_s *)data;
 
@@ -2445,19 +2648,25 @@ void pfe_eth_tx_timeout(unsigned long data )
 
 	pfe_eth_flush_tx(priv, 0);
 
-	priv->tx_timer.expires = jiffies + ( COMCERTO_TX_RECOVERY_TIMEOUT_MS * HZ )/1000;
+	priv->tx_timer.expires = jiffies + (COMCERTO_TX_RECOVERY_TIMEOUT_MS *
+					HZ)/1000;
 	add_timer(&priv->tx_timer);
 }
 
 /** pfe_eth_fast_tx_timeout
- */
+*/
 static enum hrtimer_restart pfe_eth_fast_tx_timeout(struct hrtimer *timer)
 {
-	struct pfe_eth_fast_timer *fast_tx_timeout = container_of(timer, struct pfe_eth_fast_timer, timer);
-	struct pfe_eth_priv_s *priv =  container_of(fast_tx_timeout->base, struct pfe_eth_priv_s, fast_tx_timeout);
-	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev, fast_tx_timeout->queuenum);
+	struct pfe_eth_fast_timer *fast_tx_timeout = container_of(timer, struct
+							pfe_eth_fast_timer,
+							timer);
+	struct pfe_eth_priv_s *priv =  container_of(fast_tx_timeout->base,
+							struct pfe_eth_priv_s,
+							fast_tx_timeout);
+	struct netdev_queue *tx_queue = netdev_get_tx_queue(priv->dev,
+						fast_tx_timeout->queuenum);
 
-	if(netif_tx_queue_stopped(tx_queue)) {
+	if (netif_tx_queue_stopped(tx_queue)) {
 #ifdef PFE_ETH_TX_STATS
 		priv->was_stopped[fast_tx_timeout->queuenum] = 1;
 #endif
@@ -2468,19 +2677,24 @@ static enum hrtimer_restart pfe_eth_fast_tx_timeout(struct hrtimer *timer)
 }
 
 /** pfe_eth_fast_tx_timeout_init
- */
+*/
 static void pfe_eth_fast_tx_timeout_init(struct pfe_eth_priv_s *priv)
 {
 	int i;
+
 	for (i = 0; i < emac_txq_cnt; i++) {
 		priv->fast_tx_timeout[i].queuenum = i;
-		hrtimer_init(&priv->fast_tx_timeout[i].timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		priv->fast_tx_timeout[i].timer.function = pfe_eth_fast_tx_timeout;
+		hrtimer_init(&priv->fast_tx_timeout[i].timer, CLOCK_MONOTONIC,
+				HRTIMER_MODE_REL);
+		priv->fast_tx_timeout[i].timer.function =
+				pfe_eth_fast_tx_timeout;
 		priv->fast_tx_timeout[i].base = priv->fast_tx_timeout;
 	}
 }
 
-static struct sk_buff *pfe_eth_rx_skb(struct net_device *dev, struct pfe_eth_priv_s *priv, unsigned int qno)
+static struct sk_buff *pfe_eth_rx_skb(struct net_device *dev,
+					struct	pfe_eth_priv_s *priv,
+					unsigned int qno)
 {
 	void *buf_addr;
 	unsigned int rx_ctrl;
@@ -2499,7 +2713,9 @@ static struct sk_buff *pfe_eth_rx_skb(struct net_device *dev, struct pfe_eth_pri
 
 	while (!(desc_ctrl & CL_DESC_LAST)) {
 
-		buf_addr = hif_lib_receive_pkt(&priv->client, qno, &length, &offset, &rx_ctrl, &desc_ctrl, (void **)&ipsec_hdr);
+		buf_addr = hif_lib_receive_pkt(&priv->client, qno, &length,
+						&offset, &rx_ctrl, &desc_ctrl,
+						(void **)&ipsec_hdr);
 		if (!buf_addr)
 			goto incomplete;
 
@@ -2511,34 +2727,36 @@ static struct sk_buff *pfe_eth_rx_skb(struct net_device *dev, struct pfe_eth_pri
 		if (desc_ctrl & CL_DESC_FIRST) {
 #if defined(CONFIG_PLATFORM_EMULATION) || defined(CONFIG_PLATFORM_PCI)
 			skb = dev_alloc_skb(PFE_BUF_SIZE);
-			if (unlikely(!skb)) {
+			if (unlikely(!skb))
 				goto pkt_drop;
-			}
 
-			skb_copy_to_linear_data(skb, buf_addr, length + offset);
+			skb_copy_to_linear_data(skb, buf_addr, length +
+						offset);
 			kfree(buf_addr);
 #else
 #if defined(CONFIG_COMCERTO_ZONE_DMA_NCNB)
 			skb = alloc_skb(length + offset + 32, GFP_ATOMIC);
 #else
-			skb = alloc_skb_header(PFE_BUF_SIZE, buf_addr, GFP_ATOMIC);
+			skb = alloc_skb_header(PFE_BUF_SIZE, buf_addr,
+						GFP_ATOMIC);
 #endif
-			if (unlikely(!skb)) {
+			if (unlikely(!skb))
 				goto pkt_drop;
-			}
 #endif
 			skb_reserve(skb, offset);
 #if defined(CONFIG_COMCERTO_ZONE_DMA_NCNB)
 			__memcpy(skb->data, buf_addr + offset, length);
 			if (ipsec_hdr) {
-				sah_local = *(unsigned int *)&ipsec_hdr->sa_handle[0];
+				sah_local = *(unsigned int
+						*)&ipsec_hdr->sa_handle[0];
 			}
 			kfree(buf_addr);
 #endif
 			skb_put(skb, length);
 			skb->dev = dev;
 
-			if ((dev->features & NETIF_F_RXCSUM) && (rx_ctrl & HIF_CTRL_RX_CHECKSUMMED))
+			if ((dev->features & NETIF_F_RXCSUM) && (rx_ctrl &
+					HIF_CTRL_RX_CHECKSUMMED))
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
 			else
 				skb_checksum_none_assert(skb);
@@ -2547,14 +2765,16 @@ static struct sk_buff *pfe_eth_rx_skb(struct net_device *dev, struct pfe_eth_pri
 
 			/* Next frags */
 			if (unlikely(!skb)) {
-				printk(KERN_ERR "%s: NULL skb_inflight\n", __func__);
+				printk(KERN_ERR "%s: NULL skb_inflight\n",
+					__func__);
 				goto pkt_drop;
 			}
 
 #if defined(CONFIG_COMCERTO_ZONE_DMA_NCNB)
 			skb_frag = alloc_skb(length + offset + 32, GFP_ATOMIC);
 #else
-			skb_frag = alloc_skb_header(PFE_BUF_SIZE, buf_addr, GFP_ATOMIC);
+			skb_frag = alloc_skb_header(PFE_BUF_SIZE, buf_addr,
+							GFP_ATOMIC);
 #endif
 			if (unlikely(!skb_frag)) {
 				kfree(buf_addr);
@@ -2592,11 +2812,10 @@ incomplete:
 pkt_drop:
 	priv->skb_inflight[qno] = NULL;
 
-	if (skb) {
+	if (skb)
 		kfree_skb(skb);
-	} else {
+	else
 		kfree(buf_addr);
-	}
 
 	priv->stats.rx_errors++;
 
@@ -2605,8 +2824,9 @@ pkt_drop:
 
 
 /** pfe_eth_poll
- */
-static int pfe_eth_poll(struct pfe_eth_priv_s *priv, struct napi_struct *napi, unsigned int qno, int budget)
+*/
+static int pfe_eth_poll(struct pfe_eth_priv_s *priv, struct napi_struct *napi,
+				unsigned int qno, int budget)
 {
 	struct net_device *dev = priv->dev;
 	struct sk_buff *skb;
@@ -2645,14 +2865,16 @@ static int pfe_eth_poll(struct pfe_eth_priv_s *priv, struct napi_struct *napi, u
 
 	} while (work_done < budget);
 
-	/* If no Rx receive nor cleanup work was done, exit polling mode.
-	 * No more netif_running(dev) check is required here , as this is checked in
-	 * net/core/dev.c ( 2.6.33.5 kernel specific).
-	 */
+	/*
+	* If no Rx receive nor cleanup work was done, exit polling mode.
+	* No more netif_running(dev) check is required here , as this is
+	* checked in net/core/dev.c (2.6.33.5 kernel specific).
+	*/
 	if (work_done < budget) {
 		napi_complete(napi);
 
-		hif_lib_event_handler_start(&priv->client, EVENT_RX_PKT_IND, qno);
+		hif_lib_event_handler_start(&priv->client, EVENT_RX_PKT_IND,
+						qno);
 	}
 #ifdef PFE_ETH_NAPI_STATS
 	else
@@ -2663,10 +2885,11 @@ static int pfe_eth_poll(struct pfe_eth_priv_s *priv, struct napi_struct *napi, u
 }
 
 /** pfe_eth_lro_poll
- */
+*/
 static int pfe_eth_lro_poll(struct napi_struct *napi, int budget)
 {
-	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s, lro_napi);
+	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s,
+							lro_napi);
 
 	netif_info(priv, intr, priv->dev, "%s\n", __func__);
 
@@ -2675,10 +2898,11 @@ static int pfe_eth_lro_poll(struct napi_struct *napi, int budget)
 
 
 /** pfe_eth_low_poll
- */
+*/
 static int pfe_eth_low_poll(struct napi_struct *napi, int budget)
 {
-	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s, low_napi);
+	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s,
+							low_napi);
 
 	netif_info(priv, intr, priv->dev, "%s\n", __func__);
 
@@ -2686,10 +2910,11 @@ static int pfe_eth_low_poll(struct napi_struct *napi, int budget)
 }
 
 /** pfe_eth_high_poll
- */
-static int pfe_eth_high_poll(struct napi_struct *napi, int budget )
+*/
+static int pfe_eth_high_poll(struct napi_struct *napi, int budget)
 {
-	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s, high_napi);
+	struct pfe_eth_priv_s *priv = container_of(napi, struct pfe_eth_priv_s,
+							high_napi);
 
 	netif_info(priv, intr, priv->dev, "%s\n", __func__);
 
@@ -2711,10 +2936,10 @@ static const struct net_device_ops pfe_netdev_ops = {
 };
 
 
-/** pfe_eth_init_one 
- */
+/** pfe_eth_init_one
+*/
 
-static int pfe_eth_init_one( struct pfe *pfe, int id )
+static int pfe_eth_init_one(struct pfe *pfe, int id)
 {
 	struct net_device *dev = NULL;
 	struct pfe_eth_priv_s *priv = NULL;
@@ -2727,28 +2952,37 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 #if defined(CONFIG_PLATFORM_EMULATION) || defined(CONFIG_PLATFORM_PCI)
 	pfe_info = (struct comcerto_pfe_platform_data *) &comcerto_pfe_pdata;
 #else
-	pfe_info = (struct comcerto_pfe_platform_data *) pfe->dev->platform_data;
+	pfe_info = (struct comcerto_pfe_platform_data *)
+					pfe->dev->platform_data;
 #endif
 	if (!pfe_info) {
-		printk(KERN_ERR "%s: pfe missing additional platform data\n", __func__);
+		printk(KERN_ERR
+			"%s: pfe missing additional platform data\n"
+			, __func__);
 		err = -ENODEV;
 		goto err0;
 	}
 
-	einfo = (struct comcerto_eth_platform_data *) pfe_info->comcerto_eth_pdata;
+	einfo = (struct comcerto_eth_platform_data *)
+				pfe_info->comcerto_eth_pdata;
 
-	/* einfo never be NULL, but no harm in having this check */ 
+	/* einfo never be NULL, but no harm in having this check */
 	if (!einfo) {
-		printk(KERN_ERR "%s: pfe missing additional gemacs platform data\n", __func__);
+		printk(KERN_ERR
+			"%s: pfe missing additional gemacs platform data\n"
+			, __func__);
 		err = -ENODEV;
 		goto err0;
 	}
 
-	minfo = (struct comcerto_mdio_platform_data *) pfe_info->comcerto_mdio_pdata;
+	minfo = (struct comcerto_mdio_platform_data *)
+				pfe_info->comcerto_mdio_pdata;
 
-	/* einfo never be NULL, but no harm in having this check */ 
+	/* einfo never be NULL, but no harm in having this check */
 	if (!minfo) {
-		printk(KERN_ERR "%s: pfe missing additional mdios platform data\n", __func__);
+		printk(KERN_ERR
+			"%s: pfe missing additional mdios platform data\n",
+			 __func__);
 		err = -ENODEV;
 		goto err0;
 	}
@@ -2759,10 +2993,11 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	 */
 
 	/* Create an ethernet device instance */
-	dev = alloc_etherdev_mq(sizeof (*priv), emac_txq_cnt);
+	dev = alloc_etherdev_mq(sizeof(*priv), emac_txq_cnt);
 
 	if (!dev) {
-		printk(KERN_ERR "%s: gemac %d device allocation failed\n", __func__, einfo[id].gem_id);
+		printk(KERN_ERR "%s: gemac %d device allocation failed\n",
+			__func__, einfo[id].gem_id);
 		err = -ENOMEM;
 		goto err0;
 	}
@@ -2777,9 +3012,10 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	priv->gemtx_clk = clk_get(NULL, "gemtx");
 
 	if (IS_ERR(priv->gemtx_clk)) {
-		printk(KERN_ERR "%s: Unable to get the clock for gemac %d\n", __func__, priv->id);
+		printk(KERN_ERR "%s: Unable to get the clock for gemac %d\n",
+				__func__, priv->id);
 		err = -ENODEV;
-		goto err1; 
+		goto err1;
 	}
 #endif
 
@@ -2792,15 +3028,19 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	priv->mdio_muxval = einfo[id].mdio_muxval;
 	priv->GPI_baseaddr = cbus_gpi_base[id];
 
-	/* FIXME : For now TMU queue numbers hardcoded, later should be taken from pfe.h */	
+	/*
+	* FIXME : For now TMU queue numbers hardcoded, later should be taken
+	* from pfe.h
+	*/
 #define HIF_GEMAC_TMUQ_BASE	6
-	priv->low_tmuQ	=  HIF_GEMAC_TMUQ_BASE + (id * 2);	
-	priv->high_tmuQ	=  priv->low_tmuQ + 1;	
+	priv->low_tmuQ	=  HIF_GEMAC_TMUQ_BASE + (id * 2);
+	priv->high_tmuQ	=  priv->low_tmuQ + 1;
 
 	spin_lock_init(&priv->lock);
 	priv->tx_timer.data = (unsigned long)priv;
 	priv->tx_timer.function = pfe_eth_tx_timeout;
-	priv->tx_timer.expires = jiffies + ( COMCERTO_TX_RECOVERY_TIMEOUT_MS * HZ )/1000;
+	priv->tx_timer.expires = jiffies + (COMCERTO_TX_RECOVERY_TIMEOUT_MS *
+						HZ)/1000;
 	init_timer(&priv->tx_timer);
 
 	pfe_eth_fast_tx_timeout_init(priv);
@@ -2811,7 +3051,8 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	/* Initialize mdio */
 	if (minfo[id].enabled) {
 		if ((err = pfe_eth_mdio_init(priv, &minfo[id]))) {
-			netdev_err(dev, "%s: pfe_eth_mdio_init() failed\n", __func__);
+			netdev_err(dev, "%s: pfe_eth_mdio_init() failed\n",
+					__func__);
 			goto err2;
 		}
 	}
@@ -2820,9 +3061,11 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 
 	/* supported features */
 	dev->hw_features = NETIF_F_SG;
-	/* Enable after checksum offload is validated 
-	dev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM |  NETIF_F_IPV6_CSUM |
-				NETIF_F_SG; */
+
+	/*Enable after checksum offload is validated */
+	dev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
+		NETIF_F_IPV6_CSUM | NETIF_F_SG;
+
 
 	/* enabled by default */
 	dev->features = dev->hw_features;
@@ -2834,11 +3077,15 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	dev->ethtool_ops = &pfe_ethtool_ops;
 
 	/* Enable basic messages by default */
-	priv->msg_enable = NETIF_MSG_IFUP | NETIF_MSG_IFDOWN | NETIF_MSG_LINK | NETIF_MSG_PROBE;
+	priv->msg_enable = NETIF_MSG_IFUP | NETIF_MSG_IFDOWN | NETIF_MSG_LINK |
+				NETIF_MSG_PROBE;
 
-	netif_napi_add(dev, &priv->low_napi, pfe_eth_low_poll, HIF_RX_POLL_WEIGHT - 16);
-	netif_napi_add(dev, &priv->high_napi, pfe_eth_high_poll, HIF_RX_POLL_WEIGHT - 16);
-	netif_napi_add(dev, &priv->lro_napi, pfe_eth_lro_poll, HIF_RX_POLL_WEIGHT - 16);
+	netif_napi_add(dev, &priv->low_napi, pfe_eth_low_poll,
+			HIF_RX_POLL_WEIGHT - 16);
+	netif_napi_add(dev, &priv->high_napi, pfe_eth_high_poll,
+			HIF_RX_POLL_WEIGHT - 16);
+	netif_napi_add(dev, &priv->lro_napi, pfe_eth_lro_poll,
+			HIF_RX_POLL_WEIGHT - 16);
 
 	err = register_netdev(dev);
 
@@ -2850,17 +3097,19 @@ static int pfe_eth_init_one( struct pfe *pfe, int id )
 	if (!(priv->einfo->phy_flags & GEMAC_NO_PHY)) {
 		err = pfe_phy_init(dev);
 		if (err) {
-			netdev_err(dev, "%s: pfe_phy_init() failed\n", __func__);
+			netdev_err(dev, "%s: pfe_phy_init() failed\n",
+					__func__);
 			goto err4;
 		}
 	}
 
 
 	/* Create all the sysfs files */
-	if(pfe_eth_sysfs_init(dev))
+	if (pfe_eth_sysfs_init(dev))
 		goto err4;
 
-	netif_info(priv, probe, dev, "%s: created interface, baseaddr: %p\n", __func__, priv->EMAC_baseaddr);
+	netif_info(priv, probe, dev, "%s: created interface, baseaddr: %p\n",
+			__func__, priv->EMAC_baseaddr);
 
 	return 0;
 err4:
@@ -2879,7 +3128,7 @@ err0:
 }
 
 /** pfe_eth_init
- */
+*/
 int pfe_eth_init(struct pfe *pfe)
 {
 	int ii = 0;
@@ -2906,16 +3155,15 @@ int pfe_eth_init(struct pfe *pfe)
 	return 0;
 
 err0:
-	while(ii--){
-		pfe_eth_exit_one( pfe->eth.eth_priv[ii] );
-	} 
+	while (ii--)
+		pfe_eth_exit_one(pfe->eth.eth_priv[ii]);
 
 	/* Register three network devices in the kernel */
 	return err;
 }
 
 /** pfe_eth_exit_one
- */
+*/
 static void pfe_eth_exit_one(struct pfe_eth_priv_s *priv)
 {
 	netif_info(priv, probe, priv->dev, "%s\n", __func__);
@@ -2937,14 +3185,14 @@ static void pfe_eth_exit_one(struct pfe_eth_priv_s *priv)
 }
 
 /** pfe_eth_exit
- */
+*/
 void pfe_eth_exit(struct pfe *pfe)
 {
 	int ii;
 
 	printk(KERN_INFO "%s\n", __func__);
 
-	for(ii = 0; ii < NUM_GEMAC_SUPPORT; ii++ ) {
+	for (ii = 0; ii < NUM_GEMAC_SUPPORT; ii++) {
 		/*
 		 * FIXME: Need to check some flag in "einfo" to know whether
 		 *        GEMAC is enabled Or not.
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.h b/drivers/staging/fsl_ppfe/pfe_eth.h
index 626a7d7..7deca3f 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.h
+++ b/drivers/staging/fsl_ppfe/pfe_eth.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_ETH_H_
 #define _PFE_ETH_H_
@@ -36,7 +36,8 @@
 #define LRO_LEN_COUNT_MAX	32
 #define LRO_NB_COUNT_MAX	32
 
-#if defined(CONFIG_PLATFORM_PCI) || defined(CONFIG_PLATFORM_EMULATION) || defined(CONFIG_PLATFORM_LS1012A)
+#if defined(CONFIG_PLATFORM_PCI) || defined(CONFIG_PLATFORM_EMULATION) ||\
+		defined(CONFIG_PLATFORM_LS1012A)
 
 #define CONFIG_COMCERTO_GEMAC           1
 
@@ -46,14 +47,21 @@
 #define CONFIG_COMCERTO_USE_RGMII       8
 #define CONFIG_COMCERTO_USE_SGMII       16
 
-#define GEMAC_SW_CONF                   (1 << 8) | (1 << 11)    // GEMAC configured by SW
-#define GEMAC_PHY_CONF          0                       // GEMAC configured by phy lines (not for MII/GMII)
+#define GEMAC_SW_CONF                   ((1 << 8) | (1 << 11))
+/* GEMAC configured by SW */
+#define GEMAC_PHY_CONF          0
+/* GEMAC configured by phy lines (not for MII/GMII) */
+
 #define GEMAC_SW_FULL_DUPLEX    (1 << 9)
 #define GEMAC_SW_SPEED_10M      (0 << 12)
 #define GEMAC_SW_SPEED_100M     (1 << 12)
 #define GEMAC_SW_SPEED_1G               (2 << 12)
 
-#define GEMAC_NO_PHY                    (1 << 0)                // set if no phy connected to MAC (ex ethernet switch). In this case use MAC fixed configuration
+#define GEMAC_NO_PHY                    (1 << 0)
+/*
+* set if no phy connected to MAC (ex ethernet switch).
+* In this case use MAC fixed configuration
+*/
 #define GEMAC_PHY_RGMII_ADD_DELAY       (1 << 1)
 
 /* gemac to interface name assignment */
@@ -88,86 +96,89 @@ struct comcerto_mdio_platform_data {
 	int mdc_div;
 };
 
-struct comcerto_pfe_platform_data
-{
+struct comcerto_pfe_platform_data {
 	struct comcerto_eth_platform_data comcerto_eth_pdata[3];
 	struct comcerto_mdio_platform_data comcerto_mdio_pdata[3];
 };
 #if !defined(CONFIG_PLATFORM_LS1012A)
 static struct comcerto_pfe_platform_data comcerto_pfe_pdata = {
 	.comcerto_eth_pdata[0] = {
-		.name = GEMAC0_ITF_NAME,
-		.device_flags = CONFIG_COMCERTO_GEMAC,
-		.mii_config = CONFIG_COMCERTO_USE_MII,
-		.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX | GEMAC_SW_SPEED_100M,
-#if defined(CONFIG_PLATFORM_EMULATION) || defined(CONFIG_PLATFORM_PCI) 
-		.phy_flags = GEMAC_NO_PHY,
+	.name = GEMAC0_ITF_NAME,
+	.device_flags = CONFIG_COMCERTO_GEMAC,
+	.mii_config = CONFIG_COMCERTO_USE_MII,
+	.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX |
+			GEMAC_SW_SPEED_100M,
+#if defined(CONFIG_PLATFORM_EMULATION) || defined(CONFIG_PLATFORM_PCI)
+	.phy_flags = GEMAC_NO_PHY,
 #else
-		.phy_flags = GEMAC_PHY_RGMII_ADD_DELAY,
+	.phy_flags = GEMAC_PHY_RGMII_ADD_DELAY,
 #endif
-		.bus_id = 0,
-		.phy_id = 0,
-		.gem_id = 0,
-		.mac_addr = (u8[])GEMAC0_MAC,
+	.bus_id = 0,
+	.phy_id = 0,
+	.gem_id = 0,
+	.mac_addr = (u8[])GEMAC0_MAC,
 	},
 
 	.comcerto_eth_pdata[1] = {
-		.name = GEMAC1_ITF_NAME,
-		.device_flags = CONFIG_COMCERTO_GEMAC,
-		.mii_config = CONFIG_COMCERTO_USE_RGMII,
-		.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX | GEMAC_SW_SPEED_1G,
-		.phy_flags = GEMAC_NO_PHY,
-		.gem_id = 1,
-		.mac_addr = (u8[])GEMAC1_MAC,
+	.name = GEMAC1_ITF_NAME,
+	.device_flags = CONFIG_COMCERTO_GEMAC,
+	.mii_config = CONFIG_COMCERTO_USE_RGMII,
+	.gemac_mode = GEMAC_SW_CONF | GEMAC_SW_FULL_DUPLEX |
+			GEMAC_SW_SPEED_1G,
+	.phy_flags = GEMAC_NO_PHY,
+	.gem_id = 1,
+	.mac_addr = (u8[])GEMAC1_MAC,
 	},
 
 	.comcerto_eth_pdata[2] = {
-		.name = GEMAC2_ITF_NAME,
+	.name = GEMAC2_ITF_NAME,
 	},
 
 	.comcerto_mdio_pdata[0] = {
-		.enabled = 1,
-		.phy_mask = 0xFFFFFFFE,
-		.mdc_div = 96,
-		.irq = {
-			[0] = PHY_POLL,
-		},
+	.enabled = 1,
+	.phy_mask = 0xFFFFFFFE,
+	.mdc_div = 96,
+	.irq = {
+		[0] = PHY_POLL,
+	},
 	},
 };
 #endif
 #endif
 
 #if defined(CONFIG_PLATFORM_LS1012A)
-#define NUM_GEMAC_SUPPORT		2
-#define DRV_NAME			"ls1012a-geth"
+#define NUM_GEMAC_SUPPORT	2
+#define DRV_NAME		"ls1012a-geth"
 #else
-#define NUM_GEMAC_SUPPORT		3
-#define DRV_NAME			"c2000-geth"
+#define NUM_GEMAC_SUPPORT	3
+#define DRV_NAME		"c2000-geth"
 #endif
-#define COMCERTO_INFOSTR_LEN		32
+#define COMCERTO_INFOSTR_LEN	32
 #define COMCERTO_TX_RECOVERY_TIMEOUT_MS	500
 #define COMCERTO_TX_FAST_RECOVERY_TIMEOUT_MS	3
-#define TX_POLL_TIMEOUT_MS		1000
+#define TX_POLL_TIMEOUT_MS	1000
 
 #define EMAC_TXQ_CNT	16
 #define EMAC_TXQ_DEPTH	(HIF_TX_DESC_NT)
 
 #define JUMBO_FRAME_SIZE	10258
-/**
- * Client Tx queue threshold, for txQ flush condition.
- * It must be smaller than the queue size (in case we ever change it in the future).
- */
+/*
+* Client Tx queue threshold, for txQ flush condition.
+* It must be smaller than the queue size (in case we ever change it in the
+* future).
+*/
 #define HIF_CL_TX_FLUSH_MARK	32
 
-/**
- * Max number of TX resources (HIF descriptors or skbs) that will be released
- * in a single go during batch recycling.
- * Should be lower than the flush mark so the SW can provide the HW with a
- * continuous stream of packets instead of bursts.
- */
+/*
+* Max number of TX resources (HIF descriptors or skbs) that will be released
+* in a single go during batch recycling.
+* Should be lower than the flush mark so the SW can provide the HW with a
+* continuous stream of packets instead of bursts.
+*/
 #define TX_FREE_MAX_COUNT 16
 #define EMAC_RXQ_CNT	3
-#define EMAC_RXQ_DEPTH	HIF_RX_DESC_NT /* make sure clients can receive a full burst of packets */
+#define EMAC_RXQ_DEPTH	HIF_RX_DESC_NT
+/* make sure clients can receive a full burst of packets */
 #define EMAC_RMON_TXBYTES_POS	0x00
 #define EMAC_RMON_RXBYTES_POS	0x14
 
@@ -176,13 +187,14 @@ static struct comcerto_pfe_platform_data comcerto_pfe_pdata = {
 #define MAX_UC_SPEC_ADDR_REG 31
 
 
-/* The set of statistics registers implemented in the Cadence MAC.
- * The statistics registers implemented are a subset of all the statistics
- * available, but contains all the compulsory ones.
- * For full descriptions on the registers, refer to the Cadence MAC programmers
- * guide or the IEEE 802.3 specifications.
- */
-struct gemac_stats{
+/*
+* The set of statistics registers implemented in the Cadence MAC.
+* The statistics registers implemented are a subset of all the statistics
+* available, but contains all the compulsory ones.
+* For full descriptions on the registers, refer to the Cadence MAC programmers
+* guide or the IEEE 802.3 specifications.
+*/
+struct gemac_stats {
 	u32 octets_tx_bot;      /* Lower 32-bits for number of octets tx'd */
 	u32 octets_tx_top;      /* Upper 16-bits for number of octets tx'd */
 	u32 frames_tx;          /* Number of frames transmitted OK */
@@ -193,9 +205,16 @@ struct gemac_stats{
 	u32 frame65_127_tx;     /* Number of 65-127 byte frames transmitted */
 	u32 frame128_255_tx;    /* Number of 128-255 byte frames transmitted */
 	u32 frame256_511_tx;    /* Number of 256-511 byte frames transmitted */
-	u32 frame512_1023_tx;   /* Number of 512-1023 byte frames transmitted */
-	u32 frame1024_1518_tx;  /* Number of 1024-1518 byte frames transmitted*/
-	u32 frame1519_tx;       /* Number of frames greater than 1518 bytes tx*/
+	u32 frame512_1023_tx;   /* Number of 512-1023 byte frames transmitted
+				 */
+	u32 frame1024_1518_tx;  /*
+				* Number of 1024-1518 byte frames
+				* transmitted
+				*/
+	u32 frame1519_tx;       /*
+				* Number of frames greater than 1518 bytes
+				* tx
+				*/
 	u32 tx_urun;            /* Transmit underrun errors due to DMA */
 	u32 single_col;         /* Number of single collision frames */
 	u32 multi_col;          /* Number of multi collision frames */
@@ -215,7 +234,10 @@ struct gemac_stats{
 	u32 frame256_511_rx;    /* Number of 256-511 byte frames received */
 	u32 frame512_1023_rx;   /* Number of 512-1023 byte frames received */
 	u32 frame1024_1518_rx;  /* Number of 1024-1518 byte frames received*/
-	u32 frame1519_rx;       /* Number of frames greater than 1518 bytes rx*/
+	u32 frame1519_rx;       /*
+				* Number of frames greater than 1518 bytes
+				* rx
+				*/
 	u32 usize_frames;       /* Frames received less than min of 64 bytes */
 	u32 excess_length;      /* Number of excessive length frames rx */
 	u32 jabbers;            /* Excessive length + crc or align errors. */
@@ -237,44 +259,44 @@ struct gemac_stats{
 struct pfe_eth_fast_timer {
 	int queuenum;
 	struct hrtimer timer;
-	void * base;
+	void *base;
 };
 
-typedef struct  pfe_eth_priv_s
-{
-	struct pfe 		*pfe;
+typedef struct  pfe_eth_priv_s {
+	struct pfe		*pfe;
 	struct hif_client_s	client;
 	struct napi_struct	lro_napi;
-	struct napi_struct   	low_napi;
-	struct napi_struct   	high_napi;
+	struct napi_struct	low_napi;
+	struct napi_struct	high_napi;
 	int			low_tmuQ;
 	int			high_tmuQ;
 	struct net_device_stats stats;
-	struct net_device 	*dev;
-	int 			id;
-	int 			promisc;
+	struct net_device	*dev;
+	int			id;
+	int			promisc;
 	unsigned int		msg_enable;
-	unsigned int 		usr_features;
-
-	spinlock_t 		lock;
-	unsigned int 		event_status;
-	int 			irq;
-	void*   		EMAC_baseaddr;
-	void*			PHY_baseaddr; /* This points to the EMAC base from where we access PHY */
-	void*   		GPI_baseaddr;
+	unsigned int		usr_features;
+
+	spinlock_t		lock;
+	unsigned int		event_status;
+	int			irq;
+	void			*EMAC_baseaddr;
+	/* This points to the EMAC base from where we access PHY */
+	void			*PHY_baseaddr;
+	void			*GPI_baseaddr;
 	int			mdio_muxval;
 	/* PHY stuff */
-	struct phy_device 	*phydev;
-	int 			oldspeed;
-	int 			oldduplex;
-	int 			oldlink;
+	struct phy_device	*phydev;
+	int			oldspeed;
+	int			oldduplex;
+	int			oldlink;
 	/* mdio info */
-	int 			mdc_div;
-	struct mii_bus 		*mii_bus;
+	int			mdc_div;
+	struct mii_bus		*mii_bus;
 	struct clk		*gemtx_clk;
-	int				wol;
+	int			wol;
 
-	int 			default_priority;
+	int			default_priority;
 	struct timer_list	tx_timer;
 	struct pfe_eth_fast_timer fast_tx_timeout[EMAC_TXQ_CNT];
 
@@ -283,7 +305,8 @@ typedef struct  pfe_eth_priv_s
 
 #ifdef PFE_ETH_LRO_STATS
 	unsigned int lro_len_counters[LRO_LEN_COUNT_MAX];
-	unsigned int lro_nb_counters[LRO_NB_COUNT_MAX]; //TODO change to exact max number when RX scatter done
+	/*TODO change to exact max number when RX scatter done */
+	unsigned int lro_nb_counters[LRO_NB_COUNT_MAX];
 #endif
 
 
@@ -301,7 +324,7 @@ typedef struct  pfe_eth_priv_s
 #endif
 	unsigned int frags_inflight[EMAC_RXQ_CNT + 6];
 
-}pfe_eth_priv_t;
+} pfe_eth_priv_t;
 
 struct pfe_eth {
 	struct pfe_eth_priv_s *eth_priv[3];
@@ -313,10 +336,8 @@ int pfe_eth_suspend(struct net_device *dev);
 int pfe_eth_resume(struct net_device *dev);
 int pfe_eth_mdio_reset(struct mii_bus *bus);
 
-/** pfe_compute_csum
- *
- */
-static int inline pfe_compute_csum(struct sk_buff *skb)
+/* pfe_compute_csum */
+static inline int pfe_compute_csum(struct sk_buff *skb)
 {
 	struct skb_shared_info *sh;
 	unsigned int nr_frags;
@@ -324,8 +345,10 @@ static int inline pfe_compute_csum(struct sk_buff *skb)
 	u32 csum = 0;
 	int i;
 	int len;
-
-	/* Make sure that no intermediate buffers/fragments are odd byte aligned */
+	/*
+	* Make sure that no intermediate buffers/fragments are odd byte
+	* aligned
+	*/
 	if (skb_is_nonlinear(skb)) {
 		int linearize = 0;
 
@@ -334,17 +357,14 @@ static int inline pfe_compute_csum(struct sk_buff *skb)
 		len = skb_headlen(skb) -  skb_transport_offset(skb);
 
 		if (len & 0x1) {
-			linearize = 1;
-			//printk("#1 Odd length %d\n", len);
-		}
-		else {
+				linearize = 1;
+		} else {
 			for (i = 0; i < nr_frags - 1; i++) {
 				f = &sh->frags[i];
 				len = skb_frag_size(f);
 
 				if (len & 0x1) {
 					linearize = 1;
-					//printk("#2 %d Odd length %d\n", i, len);
 					break;
 				}
 			}
@@ -357,22 +377,27 @@ static int inline pfe_compute_csum(struct sk_buff *skb)
 
 	/* Compute checksum */
 	if (!skb_is_nonlinear(skb)) {
-		*(u16*)(skb_transport_header(skb) + skb->csum_offset) = csum_fold(csum_partial(skb_transport_header(skb), skb->len - skb_transport_offset(skb), 0));
-	}
-	else {
+		*(u16 *)(skb_transport_header(skb) + skb->csum_offset) =
+		csum_fold(csum_partial(skb_transport_header(skb), skb->len -
+				skb_transport_offset(skb), 0));
+	} else {
 		sh = skb_shinfo(skb);
 		nr_frags = sh->nr_frags;
 
 		if (nr_frags) {
-			csum = csum_partial(skb_transport_header(skb), skb_headlen(skb) -  skb_transport_offset(skb), 0);
+			csum = csum_partial(skb_transport_header(skb),
+			skb_headlen(skb) -  skb_transport_offset(skb), 0);
 
 			for (i = 0; i < nr_frags - 1; i++) {
 				f = &sh->frags[i];
-				csum = csum_partial(skb_frag_address(f),  skb_frag_size(f), csum);
+				csum = csum_partial(skb_frag_address(f),
+					skb_frag_size(f), csum);
 			}
 
 			f = &sh->frags[i];
-			*(u16*)(skb_transport_header(skb) + skb->csum_offset) = csum_fold(csum_partial(skb_frag_address(f), skb_frag_size(f), csum));
+			*(u16 *)(skb_transport_header(skb) + skb->csum_offset)
+			= csum_fold(csum_partial(skb_frag_address(f),
+				skb_frag_size(f), csum));
 		}
 	}
 
diff --git a/drivers/staging/fsl_ppfe/pfe_firmware.c b/drivers/staging/fsl_ppfe/pfe_firmware.c
index 06479af..28d9239 100644
--- a/drivers/staging/fsl_ppfe/pfe_firmware.c
+++ b/drivers/staging/fsl_ppfe/pfe_firmware.c
@@ -1,32 +1,34 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /** @file
- *  Contains all the functions to handle parsing and loading of PE firmware files.
- */
+* Contains all the functions to handle parsing and loading of PE firmware
+* files.
+*/
 #include <linux/firmware.h>
 
 #include "pfe_mod.h"
 #include "pfe_firmware.h"
 #include "pfe/pfe.h"
 
-static Elf32_Shdr * get_elf_section_header(const struct firmware *fw, const char *section)
+static Elf32_Shdr *get_elf_section_header(const struct firmware *fw, const char
+						*section)
 {
 	Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)fw->data;
 	Elf32_Shdr *shdr, *shdr_shstr;
@@ -40,7 +42,8 @@ static Elf32_Shdr * get_elf_section_header(const struct firmware *fw, const char
 	int i;
 
 	/* Section header strings */
-	shdr_shstr = (Elf32_Shdr *)(fw->data + e_shoff + e_shstrndx * e_shentsize);
+	shdr_shstr = (Elf32_Shdr *)(fw->data + e_shoff + e_shstrndx *
+					e_shentsize);
 	shstr_offset = be32_to_cpu(shdr_shstr->sh_offset);
 
 	for (i = 0; i < e_shnum; i++) {
@@ -59,7 +62,8 @@ static Elf32_Shdr * get_elf_section_header(const struct firmware *fw, const char
 	return NULL;
 }
 
-static unsigned long get_elf_section(const struct firmware *fw, const char *section)
+static unsigned long get_elf_section(const struct firmware *fw, const char
+					*section)
 {
 	Elf32_Shdr *shdr = get_elf_section_header(fw, section);
 
@@ -70,14 +74,14 @@ static unsigned long get_elf_section(const struct firmware *fw, const char *sect
 }
 
 #if defined(CFG_DIAGS)
-static int pfe_get_diags_info(const struct firmware *fw, struct pfe_diags_info *diags_info)
+static int pfe_get_diags_info(const struct firmware *fw, struct pfe_diags_info
+				*diags_info)
 {
 	Elf32_Shdr *shdr;
 	unsigned long offset, size;
 
 	shdr = get_elf_section_header(fw, ".pfe_diags_str");
-	if (shdr)
-	{
+	if (shdr) {
 		offset = be32_to_cpu(shdr->sh_offset);
 		size = be32_to_cpu(shdr->sh_size);
 		diags_info->diags_str_base = be32_to_cpu(shdr->sh_addr);
@@ -86,8 +90,7 @@ static int pfe_get_diags_info(const struct firmware *fw, struct pfe_diags_info *
 		memcpy(diags_info->diags_str_array, fw->data+offset, size);
 
 		return 0;
-	} else
-	{
+	} else {
 		return -1;
 	}
 }
@@ -95,32 +98,39 @@ static int pfe_get_diags_info(const struct firmware *fw, struct pfe_diags_info *
 
 static void pfe_check_version_info(const struct firmware *fw)
 {
-	static char *version = NULL;
+	/*static char *version = NULL;*/
+	static char *version;
 
 	Elf32_Shdr *shdr = get_elf_section_header(fw, ".version");
 
-	if (shdr)
-	{
-		if(!version)
-		{
-			/* this is the first fw we load, use its version string as reference (whatever it is) */
-			version = (char *)(fw->data + be32_to_cpu(shdr->sh_offset));
+	if (shdr) {
+		if (!version) {
+			/*
+			* this is the first fw we load, use its version
+			* string as reference (whatever it is)
+			*/
+			version = (char *)(fw->data +
+					be32_to_cpu(shdr->sh_offset));
 
 			printk(KERN_INFO "PFE binary version: %s\n", version);
-		}
-		else
-		{
-			/* already have loaded at least one firmware, check sequence can start now */
-			if(strcmp(version, (char *)(fw->data + be32_to_cpu(shdr->sh_offset))))
-			{
-				printk(KERN_INFO "WARNING: PFE firmware binaries from incompatible version\n");
+		} else {
+			/*
+			* already have loaded at least one firmware, check
+			* sequence can start now
+			*/
+			if (strcmp(version, (char *)(fw->data +
+				be32_to_cpu(shdr->sh_offset)))) {
+				printk(KERN_INFO
+				"WARNING: PFE firmware binaries from incompatible version\n");
 			}
 		}
-	}
-	else
-	{
-		/* version cannot be verified, a potential issue that should be reported */
-		printk(KERN_INFO "WARNING: PFE firmware binaries from incompatible version\n");
+	} else {
+		/*
+		* version cannot be verified, a potential issue that should
+		* be reported
+		*/
+		printk(KERN_INFO
+			 "WARNING: PFE firmware binaries from incompatible version\n");
 	}
 }
 
@@ -137,46 +147,46 @@ int pfe_load_elf(int pe_mask, const struct firmware *fw, struct pfe *pfe)
 {
 	Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)fw->data;
 	Elf32_Half sections = be16_to_cpu(elf_hdr->e_shnum);
-	Elf32_Shdr *shdr = (Elf32_Shdr *) (fw->data + be32_to_cpu(elf_hdr->e_shoff));
+	Elf32_Shdr *shdr = (Elf32_Shdr *) (fw->data +
+					be32_to_cpu(elf_hdr->e_shoff));
 	int id, section;
 	int rc;
 
 	printk(KERN_INFO "%s\n", __func__);
 
 	/* Some sanity checks */
-	if (strncmp(&elf_hdr->e_ident[EI_MAG0], ELFMAG, SELFMAG))
-	{
+	if (strncmp(&elf_hdr->e_ident[EI_MAG0], ELFMAG, SELFMAG)) {
 		printk(KERN_ERR "%s: incorrect elf magic number\n", __func__);
 		return -EINVAL;
 	}
 
-	if (elf_hdr->e_ident[EI_CLASS] != ELFCLASS32)
-	{
-		printk(KERN_ERR "%s: incorrect elf class(%x)\n", __func__, elf_hdr->e_ident[EI_CLASS]);
+	if (elf_hdr->e_ident[EI_CLASS] != ELFCLASS32) {
+		printk(KERN_ERR "%s: incorrect elf class(%x)\n", __func__,
+			elf_hdr->e_ident[EI_CLASS]);
 		return -EINVAL;
 	}
 
-	if (elf_hdr->e_ident[EI_DATA] != ELFDATA2MSB)
-	{
-		printk(KERN_ERR "%s: incorrect elf data(%x)\n", __func__, elf_hdr->e_ident[EI_DATA]);
+	if (elf_hdr->e_ident[EI_DATA] != ELFDATA2MSB) {
+		printk(KERN_ERR "%s: incorrect elf data(%x)\n", __func__,
+			elf_hdr->e_ident[EI_DATA]);
 		return -EINVAL;
 	}
 
-	if (be16_to_cpu(elf_hdr->e_type) != ET_EXEC)
-	{
-		printk(KERN_ERR "%s: incorrect elf file type(%x)\n", __func__, be16_to_cpu(elf_hdr->e_type));
+	if (be16_to_cpu(elf_hdr->e_type) != ET_EXEC) {
+		printk(KERN_ERR "%s: incorrect elf file type(%x)\n", __func__,
+			be16_to_cpu(elf_hdr->e_type));
 		return -EINVAL;
-	}	
+	}
+
+	for (section = 0; section < sections; section++, shdr++) {
+		if (!(be32_to_cpu(shdr->sh_flags) & (SHF_WRITE | SHF_ALLOC |
+			SHF_EXECINSTR)))
+			continue;
 
-	for (section = 0; section < sections; section++, shdr++)
-	{
-		if (!(be32_to_cpu(shdr->sh_flags) & (SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR)))
-                        continue;
-		
 		for (id = 0; id < MAX_PE; id++)
-			if (pe_mask & (1 << id))
-			{
-				rc = pe_load_elf_section(id, fw->data, shdr, pfe->dev);
+			if (pe_mask & (1 << id)) {
+				rc = pe_load_elf_section(id, fw->data, shdr,
+					pfe->dev);
 				if (rc < 0)
 					goto err;
 			}
@@ -194,7 +204,8 @@ err:
 /** PFE firmware initialization.
 * Loads different firmware files from filesystem.
 * Initializes PE IMEM/DMEM and UTIL-PE DDR
-* Initializes control path symbol addresses (by looking them up in the elf firmware files
+* Initializes control path symbol addresses (by looking them up in the elf
+* firmware files
 * Takes PE's out of reset
 *
 * @return	0 on sucess, a negative value on error
@@ -205,32 +216,36 @@ int pfe_firmware_init(struct pfe *pfe)
 	const struct firmware *class_fw, *tmu_fw;
 	int rc = 0;
 #if !defined(CONFIG_UTIL_DISABLED)
-	const char* util_fw_name;
+	const char *util_fw_name;
 	const struct firmware *util_fw;
 #endif
 
 	printk(KERN_INFO "%s\n", __func__);
 
 	if (request_firmware(&class_fw, CLASS_FIRMWARE_FILENAME, pfe->dev)) {
-		printk(KERN_ERR "%s: request firmware %s failed\n", __func__, CLASS_FIRMWARE_FILENAME);
+		printk(KERN_ERR "%s: request firmware %s failed\n", __func__,
+			CLASS_FIRMWARE_FILENAME);
 		rc = -ETIMEDOUT;
 		goto err0;
 	}
 
 	if (request_firmware(&tmu_fw, TMU_FIRMWARE_FILENAME, pfe->dev)) {
-		printk(KERN_ERR "%s: request firmware %s failed\n", __func__,  TMU_FIRMWARE_FILENAME);
+		printk(KERN_ERR "%s: request firmware %s failed\n", __func__,
+			TMU_FIRMWARE_FILENAME);
 		rc = -ETIMEDOUT;
 		goto err1;
-        }
+}
 #if !defined(CONFIG_UTIL_DISABLED)
 #if defined(CONFIG_PLATFORM_C2000)
-	util_fw_name = (system_rev == 0) ? UTIL_REVA0_FIRMWARE_FILENAME : UTIL_FIRMWARE_FILENAME;
+	util_fw_name = (system_rev == 0) ? UTIL_REVA0_FIRMWARE_FILENAME :
+			UTIL_FIRMWARE_FILENAME;
 #else
 	util_fw_name = UTIL_FIRMWARE_FILENAME;
 #endif
 
 	if (request_firmware(&util_fw, util_fw_name, pfe->dev)) {
-		printk(KERN_ERR "%s: request firmware %s failed\n", __func__,  util_fw_name);
+		printk(KERN_ERR "%s: request firmware %s failed\n", __func__,
+			util_fw_name);
 		rc = -ETIMEDOUT;
 		goto err2;
 	}
@@ -247,12 +262,14 @@ int pfe_firmware_init(struct pfe *pfe)
 #if defined(CFG_DIAGS)
 	rc = pfe_get_diags_info(class_fw, &pfe->diags.class_diags_info);
 	if (rc < 0) {
-		printk (KERN_WARNING "PFE diags won't be available for class PEs\n");
+		printk(KERN_WARNING
+			"PFE diags won't be available for class PEs\n");
 		rc = 0;
 	}
 #endif
 
-	printk(KERN_INFO "%s: class firmware loaded %#lx %#lx\n", __func__, pfe->ctrl.class_dmem_sh, pfe->ctrl.class_pe_lmem_sh);
+	printk(KERN_INFO "%s: class firmware loaded %#lx %#lx\n", __func__,
+		pfe->ctrl.class_dmem_sh, pfe->ctrl.class_pe_lmem_sh);
 
 	rc = pfe_load_elf(TMU_MASK, tmu_fw, pfe);
 	if (rc < 0) {
@@ -262,7 +279,8 @@ int pfe_firmware_init(struct pfe *pfe)
 
 	pfe->ctrl.tmu_dmem_sh = get_elf_section(tmu_fw, ".dmem_sh");
 
-	printk(KERN_INFO "%s: tmu firmware loaded %#lx\n", __func__, pfe->ctrl.tmu_dmem_sh);
+	printk(KERN_INFO "%s: tmu firmware loaded %#lx\n", __func__,
+			pfe->ctrl.tmu_dmem_sh);
 
 #if !defined(CONFIG_UTIL_DISABLED)
 	rc = pfe_load_elf(UTIL_MASK, util_fw, pfe);
@@ -277,12 +295,14 @@ int pfe_firmware_init(struct pfe *pfe)
 #if defined(CFG_DIAGS)
 	rc = pfe_get_diags_info(util_fw, &pfe->diags.util_diags_info);
 	if (rc < 0) {
-		printk(KERN_WARNING "PFE diags won't be available for util PE\n");
+		printk(KERN_WARNING
+			"PFE diags won't be available for util PE\n");
 		rc = 0;
 	}
 #endif
 
-	printk(KERN_INFO "%s: util firmware loaded %#lx\n", __func__, pfe->ctrl.util_dmem_sh);
+	printk(KERN_INFO "%s: util firmware loaded %#lx\n", __func__,
+		pfe->ctrl.util_dmem_sh);
 
 	util_enable();
 #endif
diff --git a/drivers/staging/fsl_ppfe/pfe_firmware.h b/drivers/staging/fsl_ppfe/pfe_firmware.h
index 273d8ea..02209fb 100644
--- a/drivers/staging/fsl_ppfe/pfe_firmware.h
+++ b/drivers/staging/fsl_ppfe/pfe_firmware.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_FIRMWARE_H_
 #define _PFE_FIRMWARE_H_
diff --git a/drivers/staging/fsl_ppfe/pfe_hal.c b/drivers/staging/fsl_ppfe/pfe_hal.c
index 02bbf33..80295aa 100644
--- a/drivers/staging/fsl_ppfe/pfe_hal.c
+++ b/drivers/staging/fsl_ppfe/pfe_hal.c
@@ -1,24 +1,24 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-
-#include "pfe_ctrl_hal.h" 
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+
+#include "pfe_ctrl_hal.h"
 #include "pfe/pfe.h"
 
 void *cbus_base_addr;
@@ -31,12 +31,17 @@ static struct pe_info pe[MAX_PE];
 /** Initializes the PFE library.
 * Must be called before using any of the library functions.
 *
-* @param[in] cbus_base		CBUS virtual base address (as mapped in the host CPU address space)
-* @param[in] ddr_base		PFE DDR range virtual base address (as mapped in the host CPU address space)
-* @param[in] ddr_phys_base	PFE DDR range physical base address (as mapped in platform)
-* @param[in] size		PFE DDR range size (as defined by the host software)
-*/
-void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base, unsigned int size)
+* @param[in] cbus_base		CBUS virtual base address (as mapped in
+* the host CPU address space)
+* @param[in] ddr_base		PFE DDR range virtual base address (as
+* mapped in the host CPU address space)
+* @param[in] ddr_phys_base	PFE DDR range physical base address (as
+* mapped in platform)
+* @param[in] size		PFE DDR range size (as defined by the host
+* software)
+*/
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base,
+unsigned int size)
 {
 	cbus_base_addr = cbus_base;
 	ddr_base_addr = ddr_base;
@@ -128,20 +133,24 @@ void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base,
 
 
 /** Writes a buffer to PE internal memory from the host
- * through indirect access registers.
- *
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] src		Buffer source address
- * @param[in] mem_access_addr	DMEM destination address (must be 32bit aligned)
- * @param[in] len		Number of bytes to copy
- */
-void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned int len)
+* through indirect access registers.
+*
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] src		Buffer source address
+* @param[in] mem_access_addr	DMEM destination address (must be 32bit
+* aligned)
+* @param[in] len		Number of bytes to copy
+*/
+void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned
+int len)
 {
 	u32 offset = 0, val, addr;
 	unsigned int len32 = len >> 2;
 	int i;
 
-	addr = mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, 4);
+	addr = mem_access_addr | PE_MEM_ACCESS_WRITE |
+		PE_MEM_ACCESS_BYTE_ENABLE(0, 4);
 
 	for (i = 0; i < len32; i++, offset += 4, src += 4) {
 		val = *(u32 *)src;
@@ -152,7 +161,8 @@ void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned i
 	if ((len = (len & 0x3))) {
 		val = 0;
 
-		addr = (mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, len)) + offset;
+		addr = (mem_access_addr | PE_MEM_ACCESS_WRITE |
+			PE_MEM_ACCESS_BYTE_ENABLE(0, len)) + offset;
 
 		for (i = 0; i < len; i++, src++)
 			val |= (*(u8 *)src) << (8 * i);
@@ -163,45 +173,54 @@ void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned i
 }
 
 /** Writes a buffer to PE internal data memory (DMEM) from the host
- * through indirect access registers.
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] src		Buffer source address
- * @param[in] dst		DMEM destination address (must be 32bit aligned)
- * @param[in] len		Number of bytes to copy
- */
+* through indirect access registers.
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] src		Buffer source address
+* @param[in] dst		DMEM destination address (must be 32bit
+* aligned)
+* @param[in] len		Number of bytes to copy
+*/
 void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
 {
-	pe_mem_memcpy_to32(id, pe[id].dmem_base_addr | dst | PE_MEM_ACCESS_DMEM, src, len);
+	pe_mem_memcpy_to32(id, pe[id].dmem_base_addr | dst |
+				PE_MEM_ACCESS_DMEM, src, len);
 }
 
 
 /** Writes a buffer to PE internal program memory (PMEM) from the host
- * through indirect access registers.
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
- * @param[in] src		Buffer source address
- * @param[in] dst		PMEM destination address (must be 32bit aligned)
- * @param[in] len		Number of bytes to copy
- */
+* through indirect access registers.
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., TMU3_ID)
+* @param[in] src		Buffer source address
+* @param[in] dst		PMEM destination address (must be 32bit
+* aligned)
+* @param[in] len		Number of bytes to copy
+*/
 void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
 {
-	pe_mem_memcpy_to32(id, pe[id].pmem_base_addr | (dst & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_IMEM, src, len);
+	pe_mem_memcpy_to32(id, pe[id].pmem_base_addr | (dst & (pe[id].pmem_size
+				- 1)) | PE_MEM_ACCESS_IMEM, src, len);
 }
 
 
 /** Reads PE internal program memory (IMEM) from the host
- * through indirect access registers.
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
- * @param[in] addr		PMEM read address (must be aligned on size)
- * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
- * @return			the data read (in PE endianess, i.e BE).
- */
+* through indirect access registers.
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., TMU3_ID)
+* @param[in] addr		PMEM read address (must be aligned on size)
+* @param[in] size		Number of bytes to read (maximum 4, must not
+* cross 32bit boundaries)
+* @return			the data read (in PE endianess, i.e BE).
+*/
 u32 pe_pmem_read(int id, u32 addr, u8 size)
 {
 	u32 offset = addr & 0x3;
 	u32 mask = 0xffffffff >> ((4 - size) << 3);
 	u32 val;
 
-	addr = pe[id].pmem_base_addr | ((addr & ~0x3) & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_IMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+	addr = pe[id].pmem_base_addr | ((addr & ~0x3) & (pe[id].pmem_size - 1))
+		| PE_MEM_ACCESS_IMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
 
 	writel(addr, pe[id].mem_access_addr);
 	val = be32_to_cpu(readl(pe[id].mem_access_rdata));
@@ -211,17 +230,20 @@ u32 pe_pmem_read(int id, u32 addr, u8 size)
 
 
 /** Writes PE internal data memory (DMEM) from the host
- * through indirect access registers.
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] addr		DMEM write address (must be aligned on size)
- * @param[in] val		Value to write (in PE endianess, i.e BE)
- * @param[in] size		Number of bytes to write (maximum 4, must not cross 32bit boundaries)
- */
+* through indirect access registers.
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] addr		DMEM write address (must be aligned on size)
+* @param[in] val		Value to write (in PE endianess, i.e BE)
+* @param[in] size		Number of bytes to write (maximum 4, must not
+* cross 32bit boundaries)
+*/
 void pe_dmem_write(int id, u32 val, u32 addr, u8 size)
 {
 	u32 offset = addr & 0x3;
 
-	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_WRITE |
+		PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
 
 	/* Indirect access interface is byte swapping data being written */
 	writel(cpu_to_be32(val << (offset << 3)), pe[id].mem_access_wdata);
@@ -230,19 +252,22 @@ void pe_dmem_write(int id, u32 val, u32 addr, u8 size)
 
 
 /** Reads PE internal data memory (DMEM) from the host
- * through indirect access registers.
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] addr		DMEM read address (must be aligned on size)
- * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
- * @return			the data read (in PE endianess, i.e BE).
- */
+* through indirect access registers.
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] addr		DMEM read address (must be aligned on size)
+* @param[in] size		Number of bytes to read (maximum 4, must not
+* cross 32bit boundaries)
+* @return			the data read (in PE endianess, i.e BE).
+*/
 u32 pe_dmem_read(int id, u32 addr, u8 size)
 {
 	u32 offset = addr & 0x3;
 	u32 mask = 0xffffffff >> ((4 - size) << 3);
 	u32 val;
 
-	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_DMEM |
+			PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
 
 	writel(addr, pe[id].mem_access_addr);
 
@@ -253,7 +278,8 @@ u32 pe_dmem_read(int id, u32 addr, u8 size)
 }
 
 
-/** This function is used to write to CLASS internal bus peripherals (ccu, pe-lem) from the host
+/** This function is used to write to CLASS internal bus peripherals (ccu,
+* pe-lem) from the host
 * through indirect access registers.
 * @param[in]	val	value to write
 * @param[in]	addr	Address to write to (must be aligned on size)
@@ -266,7 +292,8 @@ void class_bus_write(u32 val, u32 addr, u8 size)
 
 	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
 
-	addr = (addr & ~CLASS_BUS_ACCESS_BASE_MASK) | PE_MEM_ACCESS_WRITE | (size << 24);
+	addr = (addr & ~CLASS_BUS_ACCESS_BASE_MASK) | PE_MEM_ACCESS_WRITE |
+			(size << 24);
 
 	writel(cpu_to_be32(val << (offset << 3)), CLASS_BUS_ACCESS_WDATA);
 	writel(addr, CLASS_BUS_ACCESS_ADDR);
@@ -310,15 +337,13 @@ void class_pe_lmem_memcpy_to32(u32 dst, const void *src, unsigned int len)
 	for (i = 0; i < len32; i++, src += 4, dst += 4)
 		class_bus_write(*(u32 *)src, dst, 4);
 
-	if (len & 0x2)
-	{
+	if (len & 0x2) {
 		class_bus_write(*(u16 *)src, dst, 2);
 		src += 2;
 		dst += 2;
 	}
 
-	if (len & 0x1)
-	{
+	if (len & 0x1) {
 		class_bus_write(*(u8 *)src, dst, 1);
 		src++;
 		dst++;
@@ -336,18 +361,16 @@ void class_pe_lmem_memset(u32 dst, int val, unsigned int len)
 	int i;
 
 	val = val | (val << 8) | (val << 16) | (val << 24);
-	
+
 	for (i = 0; i < len32; i++, dst += 4)
 		class_bus_write(val, dst, 4);
 
-	if (len & 0x2)
-	{
+	if (len & 0x2) {
 		class_bus_write(val, dst, 2);
 		dst += 2;
 	}
 
-	if (len & 0x1)
-	{
+	if (len & 0x1) {
 		class_bus_write(val, dst, 1);
 		dst++;
 	}
@@ -356,17 +379,20 @@ void class_pe_lmem_memset(u32 dst, int val, unsigned int len)
 #if !defined(CONFIG_UTIL_DISABLED)
 
 /** Writes UTIL program memory (DDR) from the host.
- *
- * @param[in] addr	Address to write (virtual, must be aligned on size)
- * @param[in] val		Value to write (in PE endianess, i.e BE)
- * @param[in] size		Number of bytes to write (2 or 4)
- */
+*
+* @param[in] addr	Address to write (virtual, must be aligned on size)
+* @param[in] val		Value to write (in PE endianess, i.e BE)
+* @param[in] size		Number of bytes to write (2 or 4)
+*/
 static void util_pmem_write(u32 val, void *addr, u8 size)
 {
 	void *addr64 = (void *)((unsigned long)addr & ~0x7);
 	unsigned long off = 8 - ((unsigned long)addr & 0x7) - size;
-	
-	//IMEM should  be loaded as a 64bit swapped value in a 64bit aligned location
+
+	/*
+	* IMEM should  be loaded as a 64bit swapped value in a 64bit aligned
+	* location
+	*/
 	if (size == 4)
 		writel(be32_to_cpu(val), addr64 + off);
 	else
@@ -375,11 +401,14 @@ static void util_pmem_write(u32 val, void *addr, u8 size)
 
 
 /** Writes a buffer to UTIL program memory (DDR) from the host.
- *
- * @param[in] dst	Address to write (virtual, must be at least 16bit aligned)
- * @param[in] src	Buffer to write (in PE endianess, i.e BE, must have same alignment as dst)
- * @param[in] len	Number of bytes to write (must be at least 16bit aligned)
- */
+*
+* @param[in] dst	Address to write (virtual, must be at least 16bit
+* aligned)
+* @param[in] src	Buffer to write (in PE endianess, i.e BE, must have
+* same alignment as dst)
+* @param[in] len	Number of bytes to write (must be at least 16bit
+* aligned)
+*/
 static void util_pmem_memcpy(void *dst, const void *src, unsigned int len)
 {
 	unsigned int len32;
@@ -403,13 +432,15 @@ static void util_pmem_memcpy(void *dst, const void *src, unsigned int len)
 #endif
 
 /** Loads an elf section into pmem
- * Code needs to be at least 16bit aligned and only PROGBITS sections are supported
- *
- * @param[in] id	PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
- * @param[in] data	pointer to the elf firmware
- * @param[in] shdr	pointer to the elf section header
- *
- */
+* Code needs to be at least 16bit aligned and only PROGBITS sections are
+* supported
+*
+* @param[in] id	PE identification (CLASS0_ID, ..., TMU0_ID, ...,
+* TMU3_ID)
+* @param[in] data	pointer to the elf firmware
+* @param[in] shdr	pointer to the elf section header
+*
+*/
 static int pe_load_pmem_section(int id, const void *data, Elf32_Shdr *shdr)
 {
 	u32 offset = be32_to_cpu(shdr->sh_offset);
@@ -418,44 +449,43 @@ static int pe_load_pmem_section(int id, const void *data, Elf32_Shdr *shdr)
 	u32 type = be32_to_cpu(shdr->sh_type);
 
 #if !defined(CONFIG_UTIL_DISABLED)
-	if (id == UTIL_ID)
-	{
-		printk(KERN_ERR "%s: unsuported pmem section for UTIL\n", __func__);
+	if (id == UTIL_ID) {
+		printk(KERN_ERR "%s: unsuported pmem section for UTIL\n",
+			__func__);
 		return -EINVAL;
 	}
 #endif
 
-	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
-	{
-		printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
-			__func__, addr, (unsigned long) data + offset);
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3)) {
+		printk(KERN_ERR
+			"%s: load address(%x) and elf file address(%lx) don't have the same alignment\n"
+			, __func__, addr, (unsigned long) data + offset);
 
 		return -EINVAL;
 	}
 
-	if (addr & 0x1)
-	{
-		printk(KERN_ERR "%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+	if (addr & 0x1) {
+		printk(KERN_ERR "%s: load address(%x) is not 16bit aligned\n",
+			__func__, addr);
 		return -EINVAL;
 	}
 
-	if (size & 0x1)
-	{
-		printk(KERN_ERR "%s: load size(%x) is not 16bit aligned\n", __func__, size);
+	if (size & 0x1) {
+		printk(KERN_ERR "%s: load size(%x) is not 16bit aligned\n",
+			__func__, size);
 		return -EINVAL;
 	}
 
-	switch (type)
-        {
-        case SHT_PROGBITS:
+	switch (type) {
+	case SHT_PROGBITS:
 		pe_pmem_memcpy_to32(id, addr, data + offset, size);
 
 		break;
 
 	default:
-		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__, type);
+		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__,
+			type);
 		return -EINVAL;
-		break;
 	}
 
 	return 0;
@@ -463,13 +493,15 @@ static int pe_load_pmem_section(int id, const void *data, Elf32_Shdr *shdr)
 
 
 /** Loads an elf section into dmem
- * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
- *
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] data		pointer to the elf firmware
- * @param[in] shdr		pointer to the elf section header
- *
- */
+* Data needs to be at least 32bit aligned, NOBITS sections are correctly
+* initialized to 0
+*
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] data		pointer to the elf firmware
+* @param[in] shdr		pointer to the elf section header
+*
+*/
 static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
 {
 	u32 offset = be32_to_cpu(shdr->sh_offset);
@@ -479,23 +511,22 @@ static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
 	u32 size32 = size >> 2;
 	int i;
 
-	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
-	{
-		printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3)) {
+		printk(KERN_ERR
+			"%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
 			__func__, addr, (unsigned long)data + offset);
 
 		return -EINVAL;
 	}
 
-	if (addr & 0x3)
-	{
-		printk(KERN_ERR "%s: load address(%x) is not 32bit aligned\n", __func__, addr);
+	if (addr & 0x3) {
+		printk(KERN_ERR "%s: load address(%x) is not 32bit aligned\n",
+			__func__, addr);
 		return -EINVAL;
 	}
 
-	switch (type)
-        {
-        case SHT_PROGBITS:
+	switch (type) {
+	case SHT_PROGBITS:
 		pe_dmem_memcpy_to32(id, addr, data + offset, size);
 		break;
 
@@ -509,9 +540,9 @@ static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
 		break;
 
 	default:
-		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__, type);
+		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__,
+				type);
 		return -EINVAL;
-		break;
 	}
 
 	return 0;
@@ -519,90 +550,102 @@ static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
 
 
 /** Loads an elf section into DDR
- * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
- *
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] data		pointer to the elf firmware
- * @param[in] shdr		pointer to the elf section header
- *
- */
-static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr, struct device *dev)
-{
+* Data needs to be at least 32bit aligned, NOBITS sections are correctly
+* initialized to 0
+*
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] data		pointer to the elf firmware
+* @param[in] shdr		pointer to the elf section header
+*
+*/
+static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr,
+struct device *dev) {
 	u32 offset = be32_to_cpu(shdr->sh_offset);
 	u32 addr = be32_to_cpu(shdr->sh_addr);
 	u32 size = be32_to_cpu(shdr->sh_size);
 	u32 type = be32_to_cpu(shdr->sh_type);
 	u32 flags = be32_to_cpu(shdr->sh_flags);
 
-	switch (type)
-	{
+	switch (type) {
 	case SHT_PROGBITS:
-		if (flags & SHF_EXECINSTR)
-		{
-			if (id <= CLASS_MAX_ID)
-			{
+		if (flags & SHF_EXECINSTR) {
+			if (id <= CLASS_MAX_ID) {
 				/* DO the loading only once in DDR */
-				if (id == CLASS0_ID)
-				{
-					printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) rcvd\n", __func__, addr, (unsigned long)data + offset);
-					if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
-					{
-						printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
-								__func__, addr, (unsigned long)data + offset);
+				if (id == CLASS0_ID) {
+					printk(KERN_ERR
+						"%s: load address(%x) and elf file address(%lx) rcvd\n",
+						__func__, addr,
+						(unsigned long)data + offset);
+					if (((unsigned long)(data + offset)
+						& 0x3) != (addr & 0x3)) {
+						printk(KERN_ERR
+							"%s: load address(%x) and elf file address(%lx) don't have the same alignment\n"
+							, __func__, addr,
+						(unsigned long)data + offset);
 
 						return -EINVAL;
 					}
 
-					if (addr & 0x1)
-					{
-						printk(KERN_ERR "%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+					if (addr & 0x1) {
+						printk(KERN_ERR
+							"%s: load address(%x) is not 16bit aligned\n"
+							, __func__, addr);
 						return -EINVAL;
 					}
 
-					if (size & 0x1)
-					{
-						printk(KERN_ERR "%s: load length(%x) is not 16bit aligned\n", __func__, size);
+					if (size & 0x1) {
+						printk(KERN_ERR
+							"%s: load length(%x) is not 16bit aligned\n"
+							, __func__, size);
 						return -EINVAL;
 					}
-					memcpy(DDR_PHYS_TO_VIRT(DDR_PFE_TO_PHYS(addr)), data + offset, size);
+					memcpy(DDR_PHYS_TO_VIRT(
+						DDR_PFE_TO_PHYS(addr)),
+						data + offset, size);
 				}
 			}
 #if !defined(CONFIG_UTIL_DISABLED)
-			else if (id == UTIL_ID)
-			{
-				if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
-				{
-					printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
-							__func__, addr, (unsigned long)data + offset);
+			else if (id == UTIL_ID) {
+				if (((unsigned long)(data + offset) & 0x3)
+					!= (addr & 0x3)) {
+					printk(KERN_ERR
+						"%s: load address(%x) and elf file address(%lx) don't have the same alignment\n"
+						, __func__, addr,
+						(unsigned long)data + offset);
 
 					return -EINVAL;
 				}
 
-				if (addr & 0x1)
-				{
-					printk(KERN_ERR "%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+				if (addr & 0x1) {
+					printk(KERN_ERR
+						"%s: load address(%x) is not 16bit aligned\n"
+						, __func__, addr);
 					return -EINVAL;
 				}
 
-				if (size & 0x1)
-				{
-					printk(KERN_ERR "%s: load length(%x) is not 16bit aligned\n", __func__, size);
+				if (size & 0x1) {
+					printk(KERN_ERR
+						"%s: load length(%x) is not 16bit aligned\n"
+						, __func__, size);
 					return -EINVAL;
 				}
 
-				util_pmem_memcpy(DDR_PHYS_TO_VIRT(DDR_PFE_TO_PHYS(addr)), data + offset, size);
+				util_pmem_memcpy(DDR_PHYS_TO_VIRT(
+							DDR_PFE_TO_PHYS(addr)),
+							data + offset, size);
 			}
 #endif
-			else
-			{
-				printk(KERN_ERR "%s: unsuported ddr section type(%x) for PE(%d)\n", __func__, type, id);
+			else {
+				printk(KERN_ERR
+					"%s: unsuported ddr section type(%x) for PE(%d)\n"
+						, __func__, type, id);
 				return -EINVAL;
 			}
 
-		}
-		else
-		{
-			memcpy(DDR_PHYS_TO_VIRT(DDR_PFE_TO_PHYS(addr)), data + offset, size);
+		} else {
+			memcpy(DDR_PHYS_TO_VIRT(DDR_PFE_TO_PHYS(addr)), data
+				+ offset, size);
 		}
 
 		break;
@@ -613,9 +656,9 @@ static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr, struc
 		break;
 
 	default:
-		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__, type);
+		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__,
+			type);
 		return -EINVAL;
-		break;
 	}
 
 	return 0;
@@ -623,13 +666,14 @@ static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr, struc
 
 
 /** Loads an elf section into pe lmem
- * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
- *
- * @param[in] id		PE identification (CLASS0_ID,..., CLASS5_ID)
- * @param[in] data		pointer to the elf firmware
- * @param[in] shdr		pointer to the elf section header
- *
- */
+* Data needs to be at least 32bit aligned, NOBITS sections are correctly
+* initialized to 0
+*
+* @param[in] id		PE identification (CLASS0_ID,..., CLASS5_ID)
+* @param[in] data		pointer to the elf firmware
+* @param[in] shdr		pointer to the elf section header
+*
+*/
 static int pe_load_pe_lmem_section(int id, const void *data, Elf32_Shdr *shdr)
 {
 	u32 offset = be32_to_cpu(shdr->sh_offset);
@@ -637,28 +681,28 @@ static int pe_load_pe_lmem_section(int id, const void *data, Elf32_Shdr *shdr)
 	u32 size = be32_to_cpu(shdr->sh_size);
 	u32 type = be32_to_cpu(shdr->sh_type);
 
-	if (id > CLASS_MAX_ID)
-	{
-		printk(KERN_ERR "%s: unsuported pe-lmem section type(%x) for PE(%d)\n", __func__, type, id);
+	if (id > CLASS_MAX_ID) {
+		printk(KERN_ERR
+			"%s: unsuported pe-lmem section type(%x) for PE(%d)\n",
+			 __func__, type, id);
 		return -EINVAL;
 	}
-	
-	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
-	{
-		printk(KERN_ERR "%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3)) {
+		printk(KERN_ERR
+			"%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
 			__func__, addr, (unsigned long)data + offset);
 
 		return -EINVAL;
 	}
 
-	if (addr & 0x3)
-	{
-		printk(KERN_ERR "%s: load address(%x) is not 32bit aligned\n", __func__, addr);
+	if (addr & 0x3) {
+		printk(KERN_ERR "%s: load address(%x) is not 32bit aligned\n",
+			__func__, addr);
 		return -EINVAL;
 	}
 
-	switch (type)
-	{
+	switch (type) {
 	case SHT_PROGBITS:
 		class_pe_lmem_memcpy_to32(addr, data + offset, size);
 		break;
@@ -668,9 +712,9 @@ static int pe_load_pe_lmem_section(int id, const void *data, Elf32_Shdr *shdr)
 		break;
 
 	default:
-		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__, type);
+		printk(KERN_ERR "%s: unsuported section type(%x)\n", __func__,
+			type);
 		return -EINVAL;
-		break;
 	}
 
 	return 0;
@@ -678,16 +722,18 @@ static int pe_load_pe_lmem_section(int id, const void *data, Elf32_Shdr *shdr)
 
 
 /** Loads an elf section into a PE
- * For now only supports loading a section to dmem (all PE's), pmem (class and tmu PE's),
- * DDDR (util PE code)
- *
- * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
- * @param[in] data		pointer to the elf firmware
- * @param[in] shdr		pointer to the elf section header
- *
- */
-int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr, struct device *dev)
-{
+* For now only supports loading a section to dmem (all PE's), pmem (class and
+* tmu PE's),
+* DDDR (util PE code)
+*
+* @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID,
+* ..., UTIL_ID)
+* @param[in] data		pointer to the elf firmware
+* @param[in] shdr		pointer to the elf section header
+*
+*/
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr, struct
+device *dev) {
 	u32 addr = be32_to_cpu(shdr->sh_addr);
 	u32 size = be32_to_cpu(shdr->sh_size);
 
@@ -699,11 +745,13 @@ int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr, struct devic
 		return 0; /* FIXME */
 	else if (IS_PHYS_DDR(addr, size))
 		return pe_load_ddr_section(id, data, shdr, dev);
-	else if (IS_PE_LMEM(addr, size))
-		return pe_load_pe_lmem_section(id, data, shdr); 
-	else {
-		printk(KERN_ERR "%s: unsuported memory range(%x)\n", __func__, addr);
-//		return -EINVAL;
+	else if (IS_PE_LMEM(addr, size)) {
+		return pe_load_pe_lmem_section(id, data, shdr);
+
+	} else {
+		printk(KERN_ERR "%s: unsuported memory range(%x)\n", __func__,
+		addr);
+	/*		return -EINVAL; */
 	}
 
 	return 0;
@@ -733,7 +781,8 @@ void bmu_reset(void *base)
 	writel(CORE_SW_RESET, base + BMU_CTRL);
 
 	/* Wait for self clear */
-	while (readl(base + BMU_CTRL) & CORE_SW_RESET) ;
+	while (readl(base + BMU_CTRL) & CORE_SW_RESET)
+		;
 }
 
 /** Enabled a BMU block.
@@ -741,7 +790,7 @@ void bmu_reset(void *base)
 */
 void bmu_enable(void *base)
 {
-	writel (CORE_ENABLE, base + BMU_CTRL);
+	writel(CORE_ENABLE, base + BMU_CTRL);
 }
 
 /** Disables a BMU block.
@@ -749,7 +798,7 @@ void bmu_enable(void *base)
 */
 void bmu_disable(void *base)
 {
-	writel (CORE_DISABLE, base + BMU_CTRL);
+	writel(CORE_DISABLE, base + BMU_CTRL);
 }
 
 /** Sets the configuration of a BMU block.
@@ -757,87 +806,91 @@ void bmu_disable(void *base)
 * @param[in] cfg	BMU configuration
 */
 void bmu_set_config(void *base, BMU_CFG *cfg)
-{	
-	writel (cfg->baseaddr, base + BMU_UCAST_BASE_ADDR);
-	writel (cfg->count & 0xffff, base + BMU_UCAST_CONFIG);
-	writel (cfg->size & 0xffff, base + BMU_BUF_SIZE);
-//	writel (BMU1_THRES_CNT, base + BMU_THRES);
+{
+	writel(cfg->baseaddr, base + BMU_UCAST_BASE_ADDR);
+	writel(cfg->count & 0xffff, base + BMU_UCAST_CONFIG);
+	writel(cfg->size & 0xffff, base + BMU_BUF_SIZE);
+/*	writel(BMU1_THRES_CNT, base + BMU_THRES); */
 
 	/* Interrupts are never used */
-//	writel (0x0, base + BMU_INT_SRC);
-	writel (0x0, base + BMU_INT_ENABLE);
+/*	writel(0x0, base + BMU_INT_SRC); */
+	writel(0x0, base + BMU_INT_ENABLE);
 }
 #if defined(CONFIG_PLATFORM_C2000)
 /**************************** GEMAC ***************************/
 
-/** Enable Rx Checksum Engine. With this enabled, Frame with bad IP, 
- *   TCP or UDP checksums are discarded
- *
- * @param[in] base	GEMAC base address. 
- */
+/** Enable Rx Checksum Engine. With this enabled, Frame with bad IP,
+*   TCP or UDP checksums are discarded
+*
+* @param[in] base	GEMAC base address.
+*/
 void gemac_enable_rx_checksum_offload(void *base)
 {
-	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
-	writel(readl(CLASS_L4_CHKSUM_ADDR) | IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_CHKSUM_RX, base
+		+ EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) | IPV4_CHKSUM_DROP,
+		CLASS_L4_CHKSUM_ADDR);
 }
 
 /** Disable Rx Checksum Engine.
- *
- * @param[in] base	GEMAC base address. 
- */
+*
+* @param[in] base	GEMAC base address.
+*/
 void gemac_disable_rx_checksum_offload(void *base)
 {
-	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
-	writel(readl(CLASS_L4_CHKSUM_ADDR) & ~IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_CHKSUM_RX, base
+		+ EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) & ~IPV4_CHKSUM_DROP,
+		CLASS_L4_CHKSUM_ADDR);
 }
 
 /** Setup the MII Mgmt clock speed.
- * @param[in] base	GEMAC base address (GEMAC0, GEMAC1, GEMAC2)
- * @param[in] mdc_div	MII clock dividor
- */
+* @param[in] base	GEMAC base address (GEMAC0, GEMAC1, GEMAC2)
+* @param[in] mdc_div	MII clock dividor
+*/
 void gemac_set_mdc_div(void *base, int mdc_div)
 {
 	u32 val = readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_MDC_DIV_MASK;
 	u32 div;
 
-        switch (mdc_div) {
-        case 8:
-                div = 0;
-                break;
+	switch (mdc_div) {
+	case 8:
+		div = 0;
+		break;
 
-        case 16:
-                div = 1;
-                break;
+	case 16:
+		div = 1;
+		break;
 
-        case 32:
-                div = 2;
-                break;
+	case 32:
+		div = 2;
+		break;
 
-        case 48:
-                div = 3;
-                break;
+	case 48:
+		div = 3;
+		break;
 
-        default:
-        case 64:
-                div = 4;
-                break;
+	default:
+	case 64:
+		div = 4;
+		break;
 
-        case 96:
-                div = 5;
-                break;
+	case 96:
+		div = 5;
+		break;
 
-        case 128:
-                div = 6;
-                break;
+	case 128:
+		div = 6;
+		break;
 
-        case 224:
-                div = 7;
-                break;
-        }
+	case 224:
+		div = 7;
+		break;
+	}
 
-        val |= div << 18;
+	val |= div << 18;
 
-        writel(val, base + EMAC_NETWORK_CONFIG);
+	writel(val, base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC set speed.
@@ -850,34 +903,33 @@ void gemac_set_speed(void *base, MAC_SPEED gem_speed)
 
 	val = val & ~EMAC_SPEED_MASK;
 
-	switch (gem_speed)
-	{
-		case SPEED_10M:
+	switch (gem_speed) {
+	case SPEED_10M:
 			val &= (~EMAC_PCS_ENABLE);
 			break;
 
-		case SPEED_100M:
+	case SPEED_100M:
 			val = val | EMAC_SPEED_100;
 			val &= (~EMAC_PCS_ENABLE);
 			break;
 
-		case SPEED_1000M:
+	case SPEED_1000M:
 			val = val | EMAC_SPEED_1000;
 			val &= (~EMAC_PCS_ENABLE);
 			break;
 
-		case SPEED_1000M_PCS:
+	case SPEED_1000M_PCS:
 			val = val | EMAC_SPEED_1000;
 			val |= EMAC_PCS_ENABLE;
 			break;
 
-		default:
+	default:
 			val = val | EMAC_SPEED_100;
 			val &= (~EMAC_PCS_ENABLE);
 		break;
 	}
-	
-	writel (val, base + EMAC_NETWORK_CONFIG);
+
+	writel(val, base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC set duplex.
@@ -892,8 +944,8 @@ void gemac_set_duplex(void *base, int duplex)
 		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_HALF_DUP;
 	else
 		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_FULL_DUP;
-  
-	writel (val, base + EMAC_NETWORK_CONFIG);
+
+	writel(val, base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC set mode.
@@ -909,61 +961,78 @@ void gemac_set_duplex(void *base, int duplex)
 
 void gemac_set_mode(void *base, int mode)
 {
-	switch (mode)
-	{
+	switch (mode) {
 	case GMII:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_GMII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		EMAC_GMII_MODE_ENABLE | IP_ALIGNED_BITVAL,
+		base + EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) &
+		(~EMAC_SGMII_MODE_ENABLE),
+		base + EMAC_NETWORK_CONFIG);
 		break;
 
 	case RGMII:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RGMII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		EMAC_RGMII_MODE_ENABLE | IP_ALIGNED_BITVAL, base +
+		EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) &
+		(~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
 		break;
 
 	case RMII:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RMII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		EMAC_RMII_MODE_ENABLE | IP_ALIGNED_BITVAL, base +
+		EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) &
+		(~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
 		break;
 
 	case MII:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		EMAC_MII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) &
+		(~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
 		break;
 
 	case SGMII:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | (EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE) | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_SGMII_MODE_ENABLE, base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		(EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE) |
+		IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) |
+		EMAC_SGMII_MODE_ENABLE, base + EMAC_NETWORK_CONFIG);
 		break;
 
 	default:
-		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
-		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		writel((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) |
+		EMAC_MII_MODE_ENABLE | IP_ALIGNED_BITVAL, base + EMAC_CONTROL);
+		writel(readl(base + EMAC_NETWORK_CONFIG) &
+		(~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
 		break;
 	}
 }
-/** GEMAC Enable MDIO: Activate the Management interface.  This is required to program the PHY
- * @param[in] base       GEMAC base address
- */
+/** GEMAC Enable MDIO: Activate the Management interface.  This is required to
+* program the PHY
+* @param[in] base       GEMAC base address
+*/
 void gemac_enable_mdio(void *base)
 {
-        u32 data;
+	u32 data;
 
-        data = readl(base + EMAC_NETWORK_CONTROL);
-        data |= EMAC_MDIO_EN;
-        writel(data, base + EMAC_NETWORK_CONTROL);
+	data = readl(base + EMAC_NETWORK_CONTROL);
+	data |= EMAC_MDIO_EN;
+	writel(data, base + EMAC_NETWORK_CONTROL);
 }
 
 /** GEMAC Disable MDIO: Disable the Management interface.
- * @param[in] base       GEMAC base address
- */
+* @param[in] base       GEMAC base address
+*/
 void gemac_disable_mdio(void *base)
 {
-        u32 data;
+	u32 data;
 
-        data = readl(base + EMAC_NETWORK_CONTROL);
-        data &= ~EMAC_MDIO_EN;
-        writel(data, base + EMAC_NETWORK_CONTROL);
+	data = readl(base + EMAC_NETWORK_CONTROL);
+	data &= ~EMAC_MDIO_EN;
+	writel(data, base + EMAC_NETWORK_CONTROL);
 }
 
 
@@ -971,15 +1040,16 @@ void gemac_disable_mdio(void *base)
 * @param[in] base	GEMAC base address
 */
 void gemac_reset(void *base)
-{  
+{
 }
 
 /** GEMAC enable function.
 * @param[in] base	GEMAC base address
 */
 void gemac_enable(void *base)
-{  
-	writel (readl(base + EMAC_NETWORK_CONTROL) | EMAC_TX_ENABLE | EMAC_RX_ENABLE, base + EMAC_NETWORK_CONTROL);
+{
+	writel(readl(base + EMAC_NETWORK_CONTROL) | EMAC_TX_ENABLE |
+		EMAC_RX_ENABLE, base + EMAC_NETWORK_CONTROL);
 }
 
 /** GEMAC disable function.
@@ -987,7 +1057,8 @@ void gemac_enable(void *base)
 */
 void gemac_disable(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE | EMAC_RX_ENABLE), base + EMAC_NETWORK_CONTROL);
+	writel(readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE |
+		EMAC_RX_ENABLE), base + EMAC_NETWORK_CONTROL);
 }
 
 /** GEMAC TX disable function.
@@ -995,7 +1066,8 @@ void gemac_disable(void *base)
 */
 void gemac_tx_disable(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE), base + EMAC_NETWORK_CONTROL);
+	writel(readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE), base +
+		EMAC_NETWORK_CONTROL);
 }
 
 /** GEMAC set mac address configuration.
@@ -1003,16 +1075,16 @@ void gemac_tx_disable(void *base)
 * @param[in] addr	MAC address to be configured
 */
 void gemac_set_address(void *base, SPEC_ADDR *addr)
-{ 
+{
 	writel(addr->one.bottom,	base + EMAC_SPEC1_ADD_BOT);
-	writel(addr->one.top,		base + EMAC_SPEC1_ADD_TOP); 
+	writel(addr->one.top,		base + EMAC_SPEC1_ADD_TOP);
 	writel(addr->two.bottom,	base + EMAC_SPEC2_ADD_BOT);
 	writel(addr->two.top,		base + EMAC_SPEC2_ADD_TOP);
 	writel(addr->three.bottom,	base + EMAC_SPEC3_ADD_BOT);
 	writel(addr->three.top,		base + EMAC_SPEC3_ADD_TOP);
 	writel(addr->four.bottom,	base + EMAC_SPEC4_ADD_BOT);
 	writel(addr->four.top,		base + EMAC_SPEC4_ADD_TOP);
-} 
+}
 
 /** GEMAC get mac address configuration.
 * @param[in] base	GEMAC base address
@@ -1022,39 +1094,39 @@ void gemac_set_address(void *base, SPEC_ADDR *addr)
 SPEC_ADDR gemac_get_address(void *base)
 {
 	SPEC_ADDR addr;
-	
-	addr.one.bottom = 	readl(base + EMAC_SPEC1_ADD_BOT);
-	addr.one.top = 		readl(base + EMAC_SPEC1_ADD_TOP); 
+
+	addr.one.bottom =	readl(base + EMAC_SPEC1_ADD_BOT);
+	addr.one.top =		readl(base + EMAC_SPEC1_ADD_TOP);
 	addr.two.bottom =	readl(base + EMAC_SPEC2_ADD_BOT);
 	addr.two.top =		readl(base + EMAC_SPEC2_ADD_TOP);
 	addr.three.bottom =	readl(base + EMAC_SPEC3_ADD_BOT);
 	addr.three.top =	readl(base + EMAC_SPEC3_ADD_TOP);
 	addr.four.bottom =	readl(base + EMAC_SPEC4_ADD_BOT);
 	addr.four.top =		readl(base + EMAC_SPEC4_ADD_TOP);
-	
+
 	return addr;
 }
 
-/** Sets the hash register of the MAC. 
- * This register is used for matching unicast and multicast frames.
- *
- * @param[in] base	GEMAC base address.
- * @param[in] hash	64-bit hash to be configured.	
- */
-void gemac_set_hash( void *base, MAC_ADDR *hash )
+/** Sets the hash register of the MAC.
+* This register is used for matching unicast and multicast frames.
+*
+* @param[in] base	GEMAC base address.
+* @param[in] hash	64-bit hash to be configured.
+*/
+void gemac_set_hash(void *base, MAC_ADDR *hash)
 {
 	writel(hash->bottom,		base + EMAC_HASH_BOT);
-	writel(hash->top,		base + EMAC_HASH_TOP); 
+	writel(hash->top,		base + EMAC_HASH_TOP);
 }
 
-/** Get the current value hash register of the MAC. 
- * This register is used for matching unicast and multicast frames.
- *
- * @param[in] base	GEMAC base address
+/** Get the current value hash register of the MAC.
+* This register is used for matching unicast and multicast frames.
+*
+* @param[in] base	GEMAC base address
 
- * @returns		64-bit hash.	
- */
-MAC_ADDR gemac_get_hash( void *base )
+* @returns		64-bit hash.
+*/
+MAC_ADDR gemac_get_hash(void *base)
 {
 	MAC_ADDR hash;
 
@@ -1065,7 +1137,8 @@ MAC_ADDR gemac_get_hash( void *base )
 }
 
 /** GEMAC set specific local addresses of the MAC.
-* Rather than setting up all four specific addresses, this function sets them up individually.
+* Rather than setting up all four specific addresses, this function sets them up
+* individually.
 *
 * @param[in] base	GEMAC base address
 * @param[in] addr	MAC address to be configured
@@ -1073,46 +1146,47 @@ MAC_ADDR gemac_get_hash( void *base )
 void gemac_set_laddr1(void *base, MAC_ADDR *address)
 {
 	writel(address->bottom,		base + EMAC_SPEC1_ADD_BOT);
-	writel(address->top,		base + EMAC_SPEC1_ADD_TOP); 
+	writel(address->top,		base + EMAC_SPEC1_ADD_TOP);
 }
 
 
 void gemac_set_laddr2(void *base, MAC_ADDR *address)
 {
 	writel(address->bottom,		base + EMAC_SPEC2_ADD_BOT);
-	writel(address->top,		base + EMAC_SPEC2_ADD_TOP); 
+	writel(address->top,		base + EMAC_SPEC2_ADD_TOP);
 }
 
 
 void gemac_set_laddr3(void *base, MAC_ADDR *address)
 {
 	writel(address->bottom,		base + EMAC_SPEC3_ADD_BOT);
-	writel(address->top,		base + EMAC_SPEC3_ADD_TOP); 
+	writel(address->top,		base + EMAC_SPEC3_ADD_TOP);
 }
 
 
 void gemac_set_laddr4(void *base, MAC_ADDR *address)
 {
 	writel(address->bottom,		base + EMAC_SPEC4_ADD_BOT);
-	writel(address->top,		base + EMAC_SPEC4_ADD_TOP); 
+	writel(address->top,		base + EMAC_SPEC4_ADD_TOP);
 }
 
 void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
 {
-	if( (entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX) )
+	if ((entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX))
 		return;
 
 	entry_index = entry_index - 1;
 
-	if (entry_index < 4)
-	{	
-		writel(address->bottom,		base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
-		writel(address->top,		base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
-	} 
-	else 
-	{
-		writel(address->bottom,		base + ((entry_index - 4) * 8) + EMAC_SPEC5_ADD_BOT);
-		writel(address->top,		base + ((entry_index - 4) * 8) + EMAC_SPEC5_ADD_TOP);
+	if (entry_index < 4) {
+		writel(address->bottom,		base + (entry_index *
+			8) + EMAC_SPEC1_ADD_BOT);
+		writel(address->top,		base + (entry_index * 8)
+			+ EMAC_SPEC1_ADD_TOP);
+	} else  {
+		writel(address->bottom,		base + ((entry_index
+			- 4) * 8) + EMAC_SPEC5_ADD_BOT);
+		writel(address->top,		base + ((entry_index -
+			4) * 8) + EMAC_SPEC5_ADD_TOP);
 	}
 }
 
@@ -1121,11 +1195,12 @@ void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
 * @param[in] base	GEMAC base address
 *
 * @return		Specific MAC address 1
-* 
+*
 */
 MAC_ADDR gem_get_laddr1(void *base)
 {
 	MAC_ADDR addr;
+
 	addr.bottom = readl(base + EMAC_SPEC1_ADD_BOT);
 	addr.top = readl(base + EMAC_SPEC1_ADD_TOP);
 	return addr;
@@ -1135,6 +1210,7 @@ MAC_ADDR gem_get_laddr1(void *base)
 MAC_ADDR gem_get_laddr2(void *base)
 {
 	MAC_ADDR addr;
+
 	addr.bottom = readl(base + EMAC_SPEC2_ADD_BOT);
 	addr.top = readl(base + EMAC_SPEC2_ADD_TOP);
 	return addr;
@@ -1144,6 +1220,7 @@ MAC_ADDR gem_get_laddr2(void *base)
 MAC_ADDR gem_get_laddr3(void *base)
 {
 	MAC_ADDR addr;
+
 	addr.bottom = readl(base + EMAC_SPEC3_ADD_BOT);
 	addr.top = readl(base + EMAC_SPEC3_ADD_TOP);
 	return addr;
@@ -1153,6 +1230,7 @@ MAC_ADDR gem_get_laddr3(void *base)
 MAC_ADDR gem_get_laddr4(void *base)
 {
 	MAC_ADDR addr;
+
 	addr.bottom = readl(base + EMAC_SPEC4_ADD_BOT);
 	addr.top = readl(base + EMAC_SPEC4_ADD_TOP);
 	return addr;
@@ -1162,28 +1240,29 @@ MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index)
 {
 	MAC_ADDR addr = {0xffffffff, 0xffffffff};
 
-	if( (entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX) )
+	if ((entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX))
 		return addr;
 
 	entry_index = entry_index - 1;
 
-	if (entry_index < 4)
-	{
-		addr.bottom = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
-		addr.top = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
-	}
-	else
-	{
-		addr.bottom = readl(base + ((entry_index - 4) * 8) + EMAC_SPEC5_ADD_BOT);
-		addr.top = readl(base + ((entry_index - 4) * 8) + EMAC_SPEC5_ADD_TOP);
+	if (entry_index < 4) {
+		addr.bottom = readl(base + (entry_index * 8) +
+				EMAC_SPEC1_ADD_BOT);
+		addr.top = readl(base + (entry_index * 8) +
+				EMAC_SPEC1_ADD_TOP);
+	} else {
+		addr.bottom = readl(base + ((entry_index - 4) * 8) +
+				EMAC_SPEC5_ADD_BOT);
+		addr.top = readl(base + ((entry_index - 4) * 8) +
+				EMAC_SPEC5_ADD_TOP);
 	}
 
 	return addr;
 }
 
 /** Clear specific local addresses of the MAC.
- * @param[in] base       GEMAC base address
- */
+* @param[in] base       GEMAC base address
+*/
 
 void gemac_clear_laddr1(void *base)
 {
@@ -1207,61 +1286,69 @@ void gemac_clear_laddr4(void *base)
 
 void gemac_clear_laddrN(void *base, unsigned int entry_index)
 {
-	if( (entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX) )
+	if ((entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX))
 		return;
 
 	entry_index = entry_index - 1;
 
-	if ( entry_index < 4 )
+	if (entry_index < 4)
 		writel(0, base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
 	else
 		writel(0, base + ((entry_index - 4) * 8) + EMAC_SPEC5_ADD_BOT);
 }
 
-/** Set the loopback mode of the MAC.  This can be either no loopback for normal
- *   operation, local loopback through MAC internal loopback module or PHY
- *   loopback for external loopback through a PHY.  This asserts the external loop
- *   pin.
- * 
- * @param[in] base	GEMAC base address.
- * @param[in] gem_loop	Loopback mode to be enabled. LB_LOCAL - MAC Loopback, 
- *			LB_EXT - PHY Loopback.  
- */
-void gemac_set_loop( void *base, MAC_LOOP gem_loop )
+/** Set the loopback mode of the MAC.  This can be either no loopback for
+* normal operation, local loopback through MAC internal loopback module or PHY
+*   loopback for external loopback through a PHY.  This asserts the external
+* loop pin.
+*
+* @param[in] base	GEMAC base address.
+* @param[in] gem_loop	Loopback mode to be enabled. LB_LOCAL - MAC
+* Loopback,
+*			LB_EXT - PHY Loopback.
+*/
+void gemac_set_loop(void *base, MAC_LOOP gem_loop)
 {
 	switch (gem_loop) {
-		case LB_LOCAL:
-			writel(readl(base + EMAC_NETWORK_CONTROL) & (~EMAC_LB_PHY),
-							base + EMAC_NETWORK_CONTROL);
-			writel(readl(base + EMAC_NETWORK_CONTROL) | (EMAC_LB_MAC),
-							base + EMAC_NETWORK_CONTROL);
+	case LB_LOCAL:
+			writel(readl(base + EMAC_NETWORK_CONTROL) &
+				(~EMAC_LB_PHY),	base +
+				EMAC_NETWORK_CONTROL);
+			writel(readl(base + EMAC_NETWORK_CONTROL) |
+				(EMAC_LB_MAC), base +
+				EMAC_NETWORK_CONTROL);
 			break;
-		case LB_EXT:
-			writel(readl(base + EMAC_NETWORK_CONTROL) & (~EMAC_LB_MAC),
-							base + EMAC_NETWORK_CONTROL);
-			writel(readl(base + EMAC_NETWORK_CONTROL) | (EMAC_LB_PHY),
-							base + EMAC_NETWORK_CONTROL);
+	case LB_EXT:
+			writel(readl(base + EMAC_NETWORK_CONTROL) &
+				(~EMAC_LB_MAC), base +
+				EMAC_NETWORK_CONTROL);
+			writel(readl(base + EMAC_NETWORK_CONTROL) |
+				(EMAC_LB_PHY), base +
+				EMAC_NETWORK_CONTROL);
 			break;
-		default:
-			writel(readl(base + EMAC_NETWORK_CONTROL) & (~(EMAC_LB_MAC | EMAC_LB_PHY)),
-									base + EMAC_NETWORK_CONTROL);
+	default:
+			writel(readl(base + EMAC_NETWORK_CONTROL) &
+			(~(EMAC_LB_MAC | EMAC_LB_PHY)),
+			base + EMAC_NETWORK_CONTROL);
 	}
 }
 
 /** GEMAC allow frames
- * @param[in] base	GEMAC base address
- */
+* @param[in] base	GEMAC base address
+*/
 void gemac_enable_copy_all(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_COPY_ALL, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC do not allow frames
- * @param[in] base	GEMAC base address
+* @param[in] base	GEMAC base address
 */
 void gemac_disable_copy_all(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_COPY_ALL, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC allow broadcast function.
@@ -1269,7 +1356,8 @@ void gemac_disable_copy_all(void *base)
 */
 void gemac_allow_broadcast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_NO_BROADCAST, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC no broadcast function.
@@ -1277,7 +1365,8 @@ void gemac_allow_broadcast(void *base)
 */
 void gemac_no_broadcast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_NO_BROADCAST, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable unicast function.
@@ -1285,7 +1374,8 @@ void gemac_no_broadcast(void *base)
 */
 void gemac_enable_unicast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_UNICAST, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable unicast function.
@@ -1293,7 +1383,8 @@ void gemac_enable_unicast(void *base)
 */
 void gemac_disable_unicast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_UNICAST, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable multicast function.
@@ -1301,7 +1392,8 @@ void gemac_disable_unicast(void *base)
 */
 void gemac_enable_multicast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_MULTICAST, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable multicast function.
@@ -1309,7 +1401,8 @@ void gemac_enable_multicast(void *base)
 */
 void gemac_disable_multicast(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_MULTICAST,
+		base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable fcs rx function.
@@ -1317,7 +1410,8 @@ void gemac_disable_multicast(void *base)
 */
 void gemac_enable_fcs_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_FCS_RX, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable fcs rx function.
@@ -1325,7 +1419,8 @@ void gemac_enable_fcs_rx(void *base)
 */
 void gemac_disable_fcs_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_FCS_RX, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable 1536 rx function.
@@ -1333,7 +1428,8 @@ void gemac_disable_fcs_rx(void *base)
 */
 void gemac_enable_1536_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_1536_RX, base +
+		EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable 1536 rx function.
@@ -1341,7 +1437,8 @@ void gemac_enable_1536_rx(void *base)
 */
 void gemac_disable_1536_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_1536_RX, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable jumbo function.
@@ -1349,7 +1446,8 @@ void gemac_disable_1536_rx(void *base)
 */
 void gemac_enable_rx_jmb(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_JUMBO_FRAME, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_JUMBO_FRAME,
+		base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable jumbo function.
@@ -1357,7 +1455,8 @@ void gemac_enable_rx_jmb(void *base)
 */
 void gemac_disable_rx_jmb(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_JUMBO_FRAME, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_JUMBO_FRAME,
+		base + EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC enable stacked vlan function.
@@ -1365,7 +1464,8 @@ void gemac_disable_rx_jmb(void *base)
 */
 void gemac_enable_stacked_vlan(void *base)
 {
-	writel (readl(base + EMAC_STACKED_VLAN_REG) | EMAC_ENABLE_STACKED_VLAN, base + EMAC_STACKED_VLAN_REG);
+	writel(readl(base + EMAC_STACKED_VLAN_REG) | EMAC_ENABLE_STACKED_VLAN,
+		base + EMAC_STACKED_VLAN_REG);
 }
 
 /** GEMAC enable stacked vlan function.
@@ -1373,7 +1473,8 @@ void gemac_enable_stacked_vlan(void *base)
 */
 void gemac_disable_stacked_vlan(void *base)
 {
-	writel (readl(base + EMAC_STACKED_VLAN_REG) & ~EMAC_ENABLE_STACKED_VLAN, base + EMAC_STACKED_VLAN_REG);
+	writel(readl(base + EMAC_STACKED_VLAN_REG) &
+		~EMAC_ENABLE_STACKED_VLAN, base + EMAC_STACKED_VLAN_REG);
 }
 
 /** GEMAC enable pause rx function.
@@ -1381,7 +1482,8 @@ void gemac_disable_stacked_vlan(void *base)
 */
 void gemac_enable_pause_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_PAUSE_RX, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC disable pause rx function.
@@ -1389,7 +1491,8 @@ void gemac_enable_pause_rx(void *base)
 */
 void gemac_disable_pause_rx(void *base)
 {
-	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_PAUSE_RX, base
+		+ EMAC_NETWORK_CONFIG);
 }
 
 /** GEMAC wol configuration
@@ -1402,24 +1505,28 @@ void gemac_set_wol(void *base, u32 wol_conf)
 }
 
 /** Sets Gemac bus width to 64bit
- * @param[in] base       GEMAC base address
- * @param[in] width     gemac bus width to be set possible values are 32/64/128
- * */
+* @param[in] base       GEMAC base address
+* @param[in] width     gemac bus width to be set possible values are 32/64/128
+*
+*/
 void gemac_set_bus_width(void *base, int width)
 {
 	u32 val = readl(base + EMAC_NETWORK_CONFIG);
-	switch(width)
-	{
-		case 32:
-			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_32;
-		case 128:
-			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_128;
-		case 64:
-		default:
-			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_64;
+
+	switch (width) {
+	case 32:
+			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) |
+				EMAC_DATA_BUS_WIDTH_32;
+	case 128:
+			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) |
+				EMAC_DATA_BUS_WIDTH_128;
+	case 64:
+	default:
+			val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) |
+				EMAC_DATA_BUS_WIDTH_64;
 
 	}
-	writel (val, base + EMAC_NETWORK_CONFIG);
+	writel(val, base + EMAC_NETWORK_CONFIG);
 }
 
 /** Sets Gemac configuration.
@@ -1432,25 +1539,25 @@ void gemac_set_config(void *base, GEMAC_CFG *cfg)
 
 	gemac_set_speed(base, cfg->speed);
 
-	gemac_set_duplex(base,cfg->duplex);
+	gemac_set_duplex(base, cfg->duplex);
 }
 #elif defined(CONFIG_PLATFORM_LS1012A)
 /**************************** MTIP GEMAC ***************************/
 
-/** Enable Rx Checksum Engine. With this enabled, Frame with bad IP, 
- *   TCP or UDP checksums are discarded
- *
- * @param[in] base	GEMAC base address. 
- */
+/** Enable Rx Checksum Engine. With this enabled, Frame with bad IP,
+*   TCP or UDP checksums are discarded
+*
+* @param[in] base	GEMAC base address.
+*/
 void gemac_enable_rx_checksum_offload(void *base)
 {
 	/*Do not find configuration to do this */
 }
 
 /** Disable Rx Checksum Engine.
- *
- * @param[in] base	GEMAC base address. 
- */
+*
+* @param[in] base	GEMAC base address.
+*/
 void gemac_disable_rx_checksum_offload(void *base)
 {
 	/*Do not find configuration to do this */
@@ -1465,19 +1572,18 @@ void gemac_set_speed(void *base, MAC_SPEED gem_speed)
 	u32 ecr = readl(base + EMAC_ECNTRL_REG) & ~EMAC_ECNTRL_SPEED;
 	u32 rcr = readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_RMII_10T;
 
-	switch (gem_speed)
-	{
-		case SPEED_10M:
+	switch (gem_speed) {
+	case SPEED_10M:
 			rcr |= EMAC_RCNTRL_RMII_10T;
 			break;
 
 
-		case SPEED_1000M:
+	case SPEED_1000M:
 			ecr |= EMAC_ECNTRL_SPEED;
 			break;
 
-		case SPEED_100M:
-		default:
+	case SPEED_100M:
+	default:
 			/*It is in 100M mode */
 			break;
 	}
@@ -1494,11 +1600,15 @@ void gemac_set_duplex(void *base, int duplex)
 
 	if (duplex == DUPLEX_HALF) {
 		printk("%s() TODO\n", __func__);
-		writel(readl(base + EMAC_TCNTRL_REG) & ~EMAC_TCNTRL_FDEN, base + EMAC_TCNTRL_REG);
-		writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_DRT, (base + EMAC_RCNTRL_REG));
-	}else{
-		writel(readl(base + EMAC_TCNTRL_REG) | EMAC_TCNTRL_FDEN, base + EMAC_TCNTRL_REG);
-		writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_DRT, (base + EMAC_RCNTRL_REG));
+		writel(readl(base + EMAC_TCNTRL_REG) & ~EMAC_TCNTRL_FDEN, base
+			+ EMAC_TCNTRL_REG);
+		writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_DRT, (base
+			+ EMAC_RCNTRL_REG));
+	} else{
+		writel(readl(base + EMAC_TCNTRL_REG) | EMAC_TCNTRL_FDEN, base
+			+ EMAC_TCNTRL_REG);
+		writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_DRT, (base
+			+ EMAC_RCNTRL_REG));
 	}
 }
 
@@ -1523,8 +1633,9 @@ void gemac_set_mode(void *base, int mode)
 * @param[in] base	GEMAC base address
 */
 void gemac_enable(void *base)
-{ 
-	writel(readl(base + EMAC_ECNTRL_REG) | EMAC_ECNTRL_ETHER_EN, base + EMAC_ECNTRL_REG);
+{
+	writel(readl(base + EMAC_ECNTRL_REG) | EMAC_ECNTRL_ETHER_EN, base +
+		EMAC_ECNTRL_REG);
 }
 
 /** GEMAC disable function.
@@ -1532,7 +1643,8 @@ void gemac_enable(void *base)
 */
 void gemac_disable(void *base)
 {
-	writel(readl(base + EMAC_ECNTRL_REG) & ~EMAC_ECNTRL_ETHER_EN, base + EMAC_ECNTRL_REG);
+	writel(readl(base + EMAC_ECNTRL_REG) & ~EMAC_ECNTRL_ETHER_EN, base +
+		EMAC_ECNTRL_REG);
 }
 
 /** GEMAC TX disable function.
@@ -1540,16 +1652,17 @@ void gemac_disable(void *base)
 */
 void gemac_tx_disable(void *base)
 {
-	writel(readl(base + EMAC_TCNTRL_REG) | EMAC_TCNTRL_GTS, base + EMAC_TCNTRL_REG);
+	writel(readl(base + EMAC_TCNTRL_REG) | EMAC_TCNTRL_GTS, base +
+		EMAC_TCNTRL_REG);
 }
 
-/** Sets the hash register of the MAC. 
- * This register is used for matching unicast and multicast frames.
- *
- * @param[in] base	GEMAC base address.
- * @param[in] hash	64-bit hash to be configured.	
- */
-void gemac_set_hash( void *base, MAC_ADDR *hash )
+/** Sets the hash register of the MAC.
+* This register is used for matching unicast and multicast frames.
+*
+* @param[in] base	GEMAC base address.
+* @param[in] hash	64-bit hash to be configured.
+*/
+void gemac_set_hash(void *base, MAC_ADDR *hash)
 {
 	writel(hash->bottom,  base + EMAC_GALR);
 	writel(hash->top, base + EMAC_GAUR);
@@ -1557,36 +1670,34 @@ void gemac_set_hash( void *base, MAC_ADDR *hash )
 
 void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
 {
-	if( (entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX) )
+	if ((entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX))
 		return;
 
 	entry_index = entry_index - 1;
 	if (entry_index < 1) {
 		writel(htonl(address->bottom),  base + EMAC_PHY_ADDR_LOW);
-		writel((htonl(address->top) | 0x8808), base + EMAC_PHY_ADDR_HIGH);
-	}
-	else
-	{
+		writel((htonl(address->top) | 0x8808), base +
+			EMAC_PHY_ADDR_HIGH);
+	} else {
 		/* TODO for other entry_index */
-		/*printk("%s  for entry_index %d \n",__func__, entry_index); */
-		writel(htonl(address->bottom),  base + ((entry_index - 1) * 8) + EMAC_SMAC_0_0);
-		writel((htonl(address->top) | 0x8808), base + ((entry_index - 1) * 8) + EMAC_SMAC_0_1);
+		writel(htonl(address->bottom),  base + ((entry_index - 1) * 8)
+			+ EMAC_SMAC_0_0);
+		writel((htonl(address->top) | 0x8808), base + ((entry_index -
+			1) * 8) + EMAC_SMAC_0_1);
 	}
 
 }
 
 void gemac_clear_laddrN(void *base, unsigned int entry_index)
 {
-	if( (entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX) )
+	if ((entry_index < 1) || (entry_index > EMAC_SPEC_ADDR_MAX))
 		return;
 
 	entry_index = entry_index - 1;
 	if (entry_index < 1) {
 		writel(0, base + EMAC_PHY_ADDR_LOW);
 		writel(0, base + EMAC_PHY_ADDR_HIGH);
-	}
-	else
-	{
+	} else {
 		writel(0,  base + ((entry_index - 1) * 8) + EMAC_SMAC_0_0);
 		writel(0, base + ((entry_index - 1) * 8) + EMAC_SMAC_0_1);
 	}
@@ -1594,36 +1705,40 @@ void gemac_clear_laddrN(void *base, unsigned int entry_index)
 
 }
 
-/** Set the loopback mode of the MAC.  This can be either no loopback for normal
- *   operation, local loopback through MAC internal loopback module or PHY
- *   loopback for external loopback through a PHY.  This asserts the external loop
- *   pin.
- * 
- * @param[in] base	GEMAC base address.
- * @param[in] gem_loop	Loopback mode to be enabled. LB_LOCAL - MAC Loopback, 
- *			LB_EXT - PHY Loopback.  
- */
-void gemac_set_loop( void *base, MAC_LOOP gem_loop )
+/** Set the loopback mode of the MAC.  This can be either no loopback for
+* normal operation, local loopback through MAC internal loopback module or PHY
+*   loopback for external loopback through a PHY.  This asserts the external
+* loop pin.
+*
+* @param[in] base	GEMAC base address.
+* @param[in] gem_loop	Loopback mode to be enabled. LB_LOCAL - MAC
+* Loopback,
+*			LB_EXT - PHY Loopback.
+*/
+void gemac_set_loop(void *base, MAC_LOOP gem_loop)
 {
 	printk("%s()\n", __func__);
-	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_LOOP, (base + EMAC_RCNTRL_REG));
+	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_LOOP, (base +
+		EMAC_RCNTRL_REG));
 }
 
 
 /** GEMAC allow frames
- * @param[in] base	GEMAC base address
- */
+* @param[in] base	GEMAC base address
+*/
 void gemac_enable_copy_all(void *base)
 {
-	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_PROM, (base + EMAC_RCNTRL_REG));
+	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_PROM, (base +
+		EMAC_RCNTRL_REG));
 }
 
 /** GEMAC do not allow frames
- * @param[in] base	GEMAC base address
+* @param[in] base	GEMAC base address
 */
 void gemac_disable_copy_all(void *base)
 {
-	writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_PROM, (base + EMAC_RCNTRL_REG));
+	writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_PROM, (base +
+		EMAC_RCNTRL_REG));
 }
 
 /** GEMAC allow broadcast function.
@@ -1631,7 +1746,8 @@ void gemac_disable_copy_all(void *base)
 */
 void gemac_allow_broadcast(void *base)
 {
-	writel (readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_BC_REJ, base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_BC_REJ, base +
+		EMAC_RCNTRL_REG);
 }
 
 /** GEMAC no broadcast function.
@@ -1639,7 +1755,8 @@ void gemac_allow_broadcast(void *base)
 */
 void gemac_no_broadcast(void *base)
 {
-	writel (readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_BC_REJ, base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_BC_REJ, base +
+		EMAC_RCNTRL_REG);
 }
 
 /** GEMAC enable unicast function.
@@ -1647,7 +1764,6 @@ void gemac_no_broadcast(void *base)
 */
 void gemac_enable_unicast(void *base)
 {
-	return;
 }
 
 /** GEMAC disable unicast function.
@@ -1655,7 +1771,6 @@ void gemac_enable_unicast(void *base)
 */
 void gemac_disable_unicast(void *base)
 {
-	return;
 }
 
 /** GEMAC enable multicast function.
@@ -1663,7 +1778,6 @@ void gemac_disable_unicast(void *base)
 */
 void gemac_enable_multicast(void *base)
 {
-	return;
 }
 
 /** GEMAC disable multicast function.
@@ -1672,7 +1786,6 @@ void gemac_enable_multicast(void *base)
 void gemac_disable_multicast(void *base)
 {
 	/* TODO how to disable multicast? */
-	return;
 }
 
 /** GEMAC enable fcs rx function.
@@ -1698,7 +1811,8 @@ void gemac_disable_fcs_rx(void *base)
 void gemac_enable_1536_rx(void *base)
 {
 	/* Set 1536 as Maximum frame length */
-	writel (readl(base + EMAC_RCNTRL_REG) | (1536 << 16), base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) | (1536 << 16), base +
+		EMAC_RCNTRL_REG);
 }
 
 /** GEMAC enable jumbo function.
@@ -1707,7 +1821,8 @@ void gemac_enable_1536_rx(void *base)
 void gemac_enable_rx_jmb(void *base)
 {
 	/*TODO what is the jumbo size supported by MTIP */
-	writel (readl(base + EMAC_RCNTRL_REG) | (JUMBO_FRAME_SIZE << 16), base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) | (JUMBO_FRAME_SIZE << 16), base
+		+ EMAC_RCNTRL_REG);
 }
 
 /** GEMAC enable stacked vlan function.
@@ -1716,7 +1831,6 @@ void gemac_enable_rx_jmb(void *base)
 void gemac_enable_stacked_vlan(void *base)
 {
 	/* MTIP doesn't support stacked vlan */
-	return;
 }
 
 /** GEMAC enable pause rx function.
@@ -1724,7 +1838,8 @@ void gemac_enable_stacked_vlan(void *base)
 */
 void gemac_enable_pause_rx(void *base)
 {
-	writel (readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_FCE, base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) | EMAC_RCNTRL_FCE, base +
+		EMAC_RCNTRL_REG);
 }
 
 /** GEMAC disable pause rx function.
@@ -1732,7 +1847,8 @@ void gemac_enable_pause_rx(void *base)
 */
 void gemac_disable_pause_rx(void *base)
 {
-	writel (readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_FCE, base + EMAC_RCNTRL_REG);
+	writel(readl(base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_FCE, base +
+		EMAC_RCNTRL_REG);
 }
 
 /** GEMAC wol configuration
@@ -1745,9 +1861,9 @@ void gemac_set_wol(void *base, u32 wol_conf)
 }
 
 /** Sets Gemac bus width to 64bit
- * @param[in] base       GEMAC base address
- * @param[in] width     gemac bus width to be set possible values are 32/64/128
- * */
+* @param[in] base       GEMAC base address
+* @param[in] width     gemac bus width to be set possible values are 32/64/128
+* */
 void gemac_set_bus_width(void *base, int width)
 {
 }
@@ -1770,11 +1886,11 @@ void gemac_set_config(void *base, GEMAC_CFG *cfg)
 
 	gemac_set_speed(base, cfg->speed);
 
-	gemac_set_duplex(base,cfg->duplex);
+	gemac_set_duplex(base, cfg->duplex);
 }
 
 
-#endif //CONFIG_PLATFORM_LS1012A)
+#endif /*CONFIG_PLATFORM_LS1012A) */
 
 
 
@@ -1785,7 +1901,7 @@ void gemac_set_config(void *base, GEMAC_CFG *cfg)
 * @param[in] cfg	GPI configuration
 */
 void gpi_init(void *base, GPI_CFG *cfg)
-{ 
+{
 	gpi_reset(base);
 
 	gpi_disable(base);
@@ -1798,7 +1914,7 @@ void gpi_init(void *base, GPI_CFG *cfg)
 */
 void gpi_reset(void *base)
 {
-	writel (CORE_SW_RESET, base + GPI_CTRL);
+	writel(CORE_SW_RESET, base + GPI_CTRL);
 }
 
 /** Enables a GPI block.
@@ -1806,7 +1922,7 @@ void gpi_reset(void *base)
 */
 void gpi_enable(void *base)
 {
-	writel (CORE_ENABLE, base + GPI_CTRL);
+	writel(CORE_ENABLE, base + GPI_CTRL);
 }
 
 /** Disables a GPI block.
@@ -1814,7 +1930,7 @@ void gpi_enable(void *base)
 */
 void gpi_disable(void *base)
 {
-	writel (CORE_DISABLE, base + GPI_CTRL);
+	writel(CORE_DISABLE, base + GPI_CTRL);
 }
 
 
@@ -1823,23 +1939,28 @@ void gpi_disable(void *base)
 * @param[in] cfg	GPI configuration
 */
 void gpi_set_config(void *base, GPI_CFG *cfg)
-{  
-	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_LMEM_ALLOC_ADDR);
-	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_LMEM_FREE_ADDR);
-	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_DDR_ALLOC_ADDR);
-	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_DDR_FREE_ADDR);
-	writel (CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),			base + GPI_CLASS_ADDR);
- 	writel (DDR_HDR_SIZE,						base + GPI_DDR_DATA_OFFSET);
-	writel (LMEM_HDR_SIZE,						base + GPI_LMEM_DATA_OFFSET);
-	writel (0,							base + GPI_LMEM_SEC_BUF_DATA_OFFSET);
-	writel (0,							base + GPI_DDR_SEC_BUF_DATA_OFFSET);
-	writel ((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,			base + GPI_HDR_SIZE);
-	writel ((DDR_BUF_SIZE << 16) | LMEM_BUF_SIZE,			base + GPI_BUF_SIZE);
-	
-	writel (((cfg->lmem_rtry_cnt << 16) | (GPI_DDR_BUF_EN << 1) | GPI_LMEM_BUF_EN),	base + GPI_RX_CONFIG);
-	writel (cfg->tmlf_txthres,					base + GPI_TMLF_TX);
-	writel (cfg->aseq_len,						base + GPI_DTX_ASEQ);
-	writel (1,							base + GPI_TOE_CHKSUM_EN);
+{
+	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),	base
+		+ GPI_LMEM_ALLOC_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_FREE_CTRL),	base
+		+ GPI_LMEM_FREE_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_ALLOC_CTRL),	base
+		+ GPI_DDR_ALLOC_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL),	base
+		+ GPI_DDR_FREE_ADDR);
+	writel(CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR), base + GPI_CLASS_ADDR);
+	writel(DDR_HDR_SIZE, base + GPI_DDR_DATA_OFFSET);
+	writel(LMEM_HDR_SIZE, base + GPI_LMEM_DATA_OFFSET);
+	writel(0, base + GPI_LMEM_SEC_BUF_DATA_OFFSET);
+	writel(0, base + GPI_DDR_SEC_BUF_DATA_OFFSET);
+	writel((DDR_HDR_SIZE << 16) |	LMEM_HDR_SIZE,	base + GPI_HDR_SIZE);
+	writel((DDR_BUF_SIZE << 16) |	LMEM_BUF_SIZE,	base + GPI_BUF_SIZE);
+
+	writel(((cfg->lmem_rtry_cnt << 16) | (GPI_DDR_BUF_EN << 1) |
+		GPI_LMEM_BUF_EN), base + GPI_RX_CONFIG);
+	writel(cfg->tmlf_txthres, base + GPI_TMLF_TX);
+	writel(cfg->aseq_len,	base + GPI_DTX_ASEQ);
+	writel(1, base + GPI_TOE_CHKSUM_EN);
 }
 
 /**************************** CLASSIFIER ***************************/
@@ -1850,9 +1971,9 @@ void gpi_set_config(void *base, GPI_CFG *cfg)
 void class_init(CLASS_CFG *cfg)
 {
 	class_reset();
-	
+
 	class_disable();
-	
+
 	class_set_config(cfg);
 }
 
@@ -1877,7 +1998,7 @@ void class_enable(void)
 */
 void class_disable(void)
 {
-	writel(CORE_DISABLE, CLASS_TX_CTRL); 
+	writel(CORE_DISABLE, CLASS_TX_CTRL);
 }
 
 /** Sets the configuration of the CLASSIFIER block.
@@ -1889,7 +2010,8 @@ void class_set_config(CLASS_CFG *cfg)
 
 	/* Initialize route table */
 	if (!cfg->resume)
-		memset(DDR_PHYS_TO_VIRT(cfg->route_table_baseaddr), 0, (1 << cfg->route_table_hash_bits) * CLASS_ROUTE_SIZE);
+		memset(DDR_PHYS_TO_VIRT(cfg->route_table_baseaddr), 0, (1 <<
+		cfg->route_table_hash_bits) * CLASS_ROUTE_SIZE);
 
 #if !defined(LS1012A_PFE_RESET_WA)
 	writel(cfg->pe_sys_clk_ratio,	CLASS_PE_SYS_CLK_RATIO);
@@ -1897,8 +2019,11 @@ void class_set_config(CLASS_CFG *cfg)
 
 	writel((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,	CLASS_HDR_SIZE);
 	writel(LMEM_BUF_SIZE,				CLASS_LMEM_BUF_SIZE);
-	writel(CLASS_ROUTE_ENTRY_SIZE(CLASS_ROUTE_SIZE) | CLASS_ROUTE_HASH_SIZE(cfg->route_table_hash_bits),	CLASS_ROUTE_HASH_ENTRY_SIZE);
-	writel(HIF_PKT_CLASS_EN| HIF_PKT_OFFSET(sizeof(struct hif_hdr)),     CLASS_HIF_PARSE);
+	writel(CLASS_ROUTE_ENTRY_SIZE(CLASS_ROUTE_SIZE) |
+		CLASS_ROUTE_HASH_SIZE(cfg->route_table_hash_bits),
+		CLASS_ROUTE_HASH_ENTRY_SIZE);
+	writel(HIF_PKT_CLASS_EN | HIF_PKT_OFFSET(sizeof(struct hif_hdr)),
+		CLASS_HIF_PARSE);
 
 	val = HASH_CRC_PORT_IP | QB2BUS_LE;
 
@@ -1906,21 +2031,23 @@ void class_set_config(CLASS_CFG *cfg)
 	val |= IP_ALIGNED;
 #endif
 
-	/* Class PE packet steering will only work if TOE mode, bridge fetch or
-	 * route fetch are enabled (see class/qb_fet.v). Route fetch would trigger
-	 * additional memory copies (likely from DDR because of hash table size, which
-	 * cannot be reduced because PE software still relies on hash value computed
-	 *  in HW), so when not in TOE mode we simply enable HW bridge fetch even
-	 * though we don't use it.
-	 */
+	/*
+	*  Class PE packet steering will only work if TOE mode, bridge fetch or
+	* route fetch are enabled (see class/qb_fet.v). Route fetch would
+	* trigger additional memory copies (likely from DDR because of hash
+	* table size, which cannot be reduced because PE software still
+	* relies on hash value computed in HW), so when not in TOE mode we
+	* simply enable HW bridge fetch even though we don't use it.
+	*/
 	if (cfg->toe_mode)
 		val |= CLASS_TOE;
 	else
-	        val |= HW_BRIDGE_FETCH;
+		val |= HW_BRIDGE_FETCH;
 
 	writel(val, CLASS_ROUTE_MULTI);
 
-	writel(DDR_PHYS_TO_PFE(cfg->route_table_baseaddr),		CLASS_ROUTE_TABLE_BASE);
+	writel(DDR_PHYS_TO_PFE(cfg->route_table_baseaddr),
+			CLASS_ROUTE_TABLE_BASE);
 	writel(CLASS_PE0_RO_DM_ADDR0_VAL,		CLASS_PE0_RO_DM_ADDR0);
 	writel(CLASS_PE0_RO_DM_ADDR1_VAL,		CLASS_PE0_RO_DM_ADDR1);
 	writel(CLASS_PE0_QB_DM_ADDR0_VAL,		CLASS_PE0_QB_DM_ADDR0);
@@ -1953,21 +2080,29 @@ void tmu_init(TMU_CFG *cfg)
 
 #if !defined(LS1012A_PFE_RESET_WA)
 	/* keep in soft reset */
-	writel(SW_RESET,                     TMU_CTRL);
+	writel(SW_RESET, TMU_CTRL);
 #endif
-	writel(0x3,						TMU_SYS_GENERIC_CONTROL);
-	writel(750,						TMU_INQ_WATERMARK);
-	writel(CBUS_VIRT_TO_PFE(EGPI1_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY0_INQ_ADDR);
-	writel(CBUS_VIRT_TO_PFE(EGPI2_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY1_INQ_ADDR);
+	writel(0x3, TMU_SYS_GENERIC_CONTROL);
+	writel(750, TMU_INQ_WATERMARK);
+	writel(CBUS_VIRT_TO_PFE(EGPI1_BASE_ADDR +
+		GPI_INQ_PKTPTR),	TMU_PHY0_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(EGPI2_BASE_ADDR +
+		GPI_INQ_PKTPTR),	TMU_PHY1_INQ_ADDR);
 #if !defined(CONFIG_PLATFORM_LS1012A)
-	writel(CBUS_VIRT_TO_PFE(EGPI3_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY2_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(EGPI3_BASE_ADDR +
+		GPI_INQ_PKTPTR),	TMU_PHY2_INQ_ADDR);
 #endif
-	writel(CBUS_VIRT_TO_PFE(HGPI_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY3_INQ_ADDR);
-	writel(CBUS_VIRT_TO_PFE(HIF_NOCPY_RX_INQ0_PKTPTR),		TMU_PHY4_INQ_ADDR);
-	writel(CBUS_VIRT_TO_PFE(UTIL_INQ_PKTPTR),			TMU_PHY5_INQ_ADDR);
-	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL), 	TMU_BMU_INQ_ADDR);
-
-	writel(0x3FF,	TMU_TDQ0_SCH_CTRL);	// enabling all 10 schedulers [9:0] of each TDQ 
+	writel(CBUS_VIRT_TO_PFE(HGPI_BASE_ADDR +
+		GPI_INQ_PKTPTR),	TMU_PHY3_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(HIF_NOCPY_RX_INQ0_PKTPTR), TMU_PHY4_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(UTIL_INQ_PKTPTR), TMU_PHY5_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL),
+	TMU_BMU_INQ_ADDR);
+
+	writel(0x3FF,	TMU_TDQ0_SCH_CTRL);	/*
+						* enabling all 10
+						* schedulers [9:0] of each TDQ
+						*/
 	writel(0x3FF,	TMU_TDQ1_SCH_CTRL);
 #if !defined(CONFIG_PLATFORM_LS1012A)
 	writel(0x3FF,	TMU_TDQ2_SCH_CTRL);
@@ -1979,7 +2114,8 @@ void tmu_init(TMU_CFG *cfg)
 #endif
 
 #if !defined(LS1012A_PFE_RESET_WA)
-	writel(DDR_PHYS_TO_PFE(cfg->llm_base_addr),	TMU_LLM_BASE_ADDR);	// Extra packet pointers will be stored from this address onwards
+	writel(DDR_PHYS_TO_PFE(cfg->llm_base_addr),	TMU_LLM_BASE_ADDR);
+	/* Extra packet pointers will be stored from this address onwards */
 
 	writel(cfg->llm_queue_len,	TMU_LLM_QUE_LEN);
 	writel(5,			TMU_TDQ_IIFG_CFG);
@@ -1991,33 +2127,39 @@ void tmu_init(TMU_CFG *cfg)
 	printk(KERN_INFO "%s: mem init\n", __func__);
 	writel(MEM_INIT,	TMU_CTRL);
 
-	while(!(readl(TMU_CTRL) & MEM_INIT_DONE)) ;
+	while (!(readl(TMU_CTRL) & MEM_INIT_DONE))
+		;
 
 	/* LLM init */
 	printk(KERN_INFO "%s: lmem init\n", __func__);
 	writel(LLM_INIT,	TMU_CTRL);
 
-	while(!(readl(TMU_CTRL) & LLM_INIT_DONE)) ;
+	while (!(readl(TMU_CTRL) & LLM_INIT_DONE))
+		;
 #endif
-	// set up each queue for tail drop
-	for (phyno = 0; phyno < 4; phyno++)
-	{
+	/* set up each queue for tail drop */
+	for (phyno = 0; phyno < 4; phyno++) {
 #if defined(CONFIG_PLATFORM_LS1012A)
-		if(phyno == 2) continue;
+		if (phyno == 2)
+			continue;
 #endif
-		for (q = 0; q < 16; q++)
-		{
+		for (q = 0; q < 16; q++) {
 			u32 qdepth;
+
 			writel((phyno << 8) | q, TMU_TEQ_CTRL);
-			writel(1 << 22, TMU_TEQ_QCFG); //Enable tail drop
+			writel(1 << 22, TMU_TEQ_QCFG); /*Enable tail drop */
 
 			if (phyno == 3)
 				qdepth = DEFAULT_TMU3_QDEPTH;
 			else
-				qdepth = (q == 0) ? DEFAULT_Q0_QDEPTH : DEFAULT_MAX_QDEPTH;
-
-			// LOG: 68855
-			// The following is a workaround for the reordered packet and BMU2 buffer leakage issue.
+				qdepth = (q == 0) ? DEFAULT_Q0_QDEPTH :
+						DEFAULT_MAX_QDEPTH;
+
+			/* LOG: 68855 */
+			/*
+			* The following is a workaround for the reordered
+			* packet and BMU2 buffer leakage issue.
+			*/
 			if (CHIP_REVISION() == 0)
 				qdepth = 31;
 
@@ -2053,17 +2195,20 @@ void tmu_disable(u32 pe_mask)
 	writel(readl(TMU_TX_CTRL) & ~(pe_mask & 0xF), TMU_TX_CTRL);
 }
 /** This will return the tmu queue status
- * @param[in] if_id	gem interface id or TMU index
- * @return		returns the bit mask of busy queues, zero means all queues are empty
- */
+* @param[in] if_id	gem interface id or TMU index
+* @return		returns the bit mask of busy queues, zero means all
+* queues are empty
+*/
 u32 tmu_qstatus(u32 if_id)
 {
-	return cpu_to_be32(pe_dmem_read(TMU0_ID+if_id, PESTATUS_ADDR_TMU + offsetof(PE_STATUS, tmu_qstatus), 4));
+	return cpu_to_be32(pe_dmem_read(TMU0_ID+if_id, PESTATUS_ADDR_TMU +
+		offsetof(PE_STATUS, tmu_qstatus), 4));
 }
 
 u32 tmu_pkts_processed(u32 if_id)
 {
-	return cpu_to_be32(pe_dmem_read(TMU0_ID+if_id, PESTATUS_ADDR_TMU + offsetof(PE_STATUS, rx), 4));
+	return cpu_to_be32(pe_dmem_read(TMU0_ID+if_id, PESTATUS_ADDR_TMU +
+		offsetof(PE_STATUS, rx), 4));
 }
 /**************************** UTIL ***************************/
 
@@ -2105,11 +2250,14 @@ void util_disable(void)
 */
 void hif_nocpy_init(void)
 {
-	writel(4,							HIF_NOCPY_TX_PORT_NO);
-	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),		HIF_NOCPY_LMEM_ALLOC_ADDR);
+	writel(4, HIF_NOCPY_TX_PORT_NO);
+	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR +
+		BMU_ALLOC_CTRL),		HIF_NOCPY_LMEM_ALLOC_ADDR);
 	writel(CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),	HIF_NOCPY_CLASS_ADDR);
-	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),	HIF_NOCPY_TMU_PORT0_ADDR);
-	writel(HIF_RX_POLL_CTRL_CYCLE<<16|HIF_TX_POLL_CTRL_CYCLE, HIF_NOCPY_POLL_CTRL); 
+	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),
+		HIF_NOCPY_TMU_PORT0_ADDR);
+	writel(HIF_RX_POLL_CTRL_CYCLE<<16|HIF_TX_POLL_CTRL_CYCLE,
+		HIF_NOCPY_POLL_CTRL);
 }
 
 /** Enable hif_nocpy tx DMA and interrupt
@@ -2118,8 +2266,11 @@ void hif_nocpy_init(void)
 void hif_nocpy_tx_enable(void)
 {
 	/*TODO not sure poll_cntrl_en is required or not */
-	writel( HIF_CTRL_DMA_EN, HIF_NOCPY_TX_CTRL);
-	//writel((readl(HIF_NOCPY_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN), HIF_NOCPY_INT_ENABLE);
+	writel(HIF_CTRL_DMA_EN, HIF_NOCPY_TX_CTRL);
+	/*
+	* writel((readl(HIF_NOCPY_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN),
+	* HIF_NOCPY_INT_ENABLE);
+	*/
 }
 
 /** Disable hif_nocpy tx DMA and interrupt
@@ -2142,7 +2293,8 @@ void hif_nocpy_tx_disable(void)
 void hif_nocpy_rx_enable(void)
 {
 	hif_nocpy_rx_dma_start();
-	writel((readl(HIF_NOCPY_INT_ENABLE) | HIF_INT_EN | HIF_RXPKT_INT_EN), HIF_NOCPY_INT_ENABLE);
+	writel((readl(HIF_NOCPY_INT_ENABLE) | HIF_INT_EN | HIF_RXPKT_INT_EN),
+		HIF_NOCPY_INT_ENABLE);
 }
 
 /** Disable hif_nocpy rx DMA and interrupt
@@ -2165,7 +2317,8 @@ void hif_nocpy_rx_disable(void)
 void hif_init(void)
 {
 	/*Initialize HIF registers*/
-	writel((HIF_RX_POLL_CTRL_CYCLE << 16) | HIF_TX_POLL_CTRL_CYCLE, HIF_POLL_CTRL); 
+	writel((HIF_RX_POLL_CTRL_CYCLE << 16) | HIF_TX_POLL_CTRL_CYCLE,
+		HIF_POLL_CTRL);
 }
 
 /** Enable hif tx DMA and interrupt
@@ -2175,7 +2328,8 @@ void hif_tx_enable(void)
 {
 	/*TODO not sure poll_cntrl_en is required or not */
 	writel(HIF_CTRL_DMA_EN, HIF_TX_CTRL);
-	writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN), HIF_INT_ENABLE);
+	writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN),
+		HIF_INT_ENABLE);
 }
 
 /** Disable hif tx DMA and interrupt
@@ -2198,7 +2352,8 @@ void hif_tx_disable(void)
 void hif_rx_enable(void)
 {
 	hif_rx_dma_start();
-	writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_RXPKT_INT_EN), HIF_INT_ENABLE);
+	writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_RXPKT_INT_EN),
+		HIF_INT_ENABLE);
 }
 
 /** Disable hif rx DMA and interrupt
diff --git a/drivers/staging/fsl_ppfe/pfe_hif.c b/drivers/staging/fsl_ppfe/pfe_hif.c
index c54455c..dd3818d 100644
--- a/drivers/staging/fsl_ppfe/pfe_hif.c
+++ b/drivers/staging/fsl_ppfe/pfe_hif.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifdef __KERNEL__
 #include <linux/kernel.h>
@@ -37,8 +37,10 @@
 
 #include "pfe_mod.h"
 #if 0
-#define DMA_MAP_SINGLE(dev, vaddr, size, direction)	dma_map_single(dev, vaddr, size, direction)
-#define DMA_UNMAP_SINGLE(dev, vaddr, size, direction)	dma_unmap_single(dev, vaddr, size, direction)
+#define DMA_MAP_SINGLE(dev, vaddr, size, direction)	dma_map_single(dev\
+						, vaddr, size, direction)
+#define DMA_UNMAP_SINGLE(dev, vaddr, size, direction)	dma_unmap_single(dev\
+						, vaddr, size, direction)
 void ct_flush(void *addr, u32 size)
 {
 	dma_map_single(pfe->dev, addr, size, DMA_TO_DEVICE);
@@ -51,11 +53,11 @@ void ct_flush(void *addr, u32 size)
 
 #define HIF_INT_MASK	(HIF_INT | HIF_RXPKT_INT)
 
-#define inc_cl_idx(idxname) idxname = (idxname+1) & (queue->size-1)
-#define inc_hif_rxidx(idxname) idxname = (idxname+1) & (hif->RxRingSize-1)
-#define inc_hif_txidx(idxname) idxname = (idxname+1) & (hif->TxRingSize-1)
+#define inc_cl_idx(idxname) (idxname = (idxname+1) & (queue->size-1))
+#define inc_hif_rxidx(idxname) (idxname = (idxname+1) & (hif->RxRingSize-1))
+#define inc_hif_txidx(idxname) (idxname = (idxname+1) & (hif->TxRingSize-1))
 
-unsigned char napi_first_batch = 0;
+unsigned char napi_first_batch;
 
 static int pfe_hif_alloc_descr(struct pfe_hif *hif)
 {
@@ -66,11 +68,14 @@ static int pfe_hif_alloc_descr(struct pfe_hif *hif)
 
 	printk(KERN_INFO "%s\n", __func__);
 	addr = dma_alloc_coherent(pfe->dev,
-			HIF_RX_DESC_NT * sizeof(struct hif_desc) + HIF_TX_DESC_NT * sizeof(struct hif_desc),
+			HIF_RX_DESC_NT * sizeof(struct hif_desc) +
+			HIF_TX_DESC_NT * sizeof(struct hif_desc),
 			&dma_addr, GFP_KERNEL);
 
 	if (!addr) {
-		printk(KERN_ERR "%s: Could not allocate buffer descriptors!\n", __func__);
+		printk(KERN_ERR
+			"%s: Could not allocate buffer descriptors!\n"
+			, __func__);
 		err = -ENOMEM;
 		goto err0;
 	}
@@ -95,7 +100,8 @@ static void pfe_hif_free_descr(struct pfe_hif *hif)
 	printk(KERN_INFO "%s\n", __func__);
 #if !defined(CONFIG_PLATFORM_PCI)
 	dma_free_coherent(pfe->dev,
-			hif->RxRingSize * sizeof(struct hif_desc) + hif->TxRingSize * sizeof(struct hif_desc),
+			hif->RxRingSize * sizeof(struct hif_desc) +
+			hif->TxRingSize * sizeof(struct hif_desc),
 			hif->descr_baseaddr_v, hif->descr_baseaddr_p);
 #endif
 }
@@ -103,35 +109,38 @@ void pfe_hif_desc_dump(struct pfe_hif *hif)
 {
 	struct hif_desc	*desc;
 	unsigned long desc_p;
-	int ii=0;
+	int ii = 0;
 
 	printk(KERN_INFO "%s\n", __func__);
 
 	desc = hif->RxBase;
-	desc_p = (u32)((u64)desc - (u64)hif->descr_baseaddr_v + hif->descr_baseaddr_p);
+	desc_p = (u32)((u64)desc - (u64)hif->descr_baseaddr_v +
+				hif->descr_baseaddr_p);
 
 	printk("HIF Rx desc base %p physical %x\n", desc, (u32)desc_p);
 	for (ii = 0; ii < hif->RxRingSize; ii++) {
 		printk(KERN_INFO "status: %08x, ctrl: %08x, data: %08x, next: %x\n",
-				desc->status, desc->ctrl, desc->data, desc->next);
+				desc->status, desc->ctrl, desc->data,
+			desc->next);
 		desc++;
 	}
 
 	desc = hif->TxBase;
-	desc_p = ((u64)desc - (u64)hif->descr_baseaddr_v + hif->descr_baseaddr_p);
+	desc_p = ((u64)desc - (u64)hif->descr_baseaddr_v +
+			hif->descr_baseaddr_p);
 
 	printk("HIF Tx desc base %p physical %x\n", desc, (u32)desc_p);
 	for (ii = 0; ii < hif->TxRingSize; ii++) {
-		printk(KERN_INFO "status: %08x, ctrl: %08x, data: %08x, next: %x\n",
-				desc->status, desc->ctrl, desc->data, desc->next);
+		printk(KERN_INFO
+			"status: %08x, ctrl: %08x, data: %08x, next: %x\n",
+				desc->status, desc->ctrl, desc->data,
+				desc->next);
 		desc++;
 	}
 
 }
 
-/* pfe_hif_release_buffers
- *
- */
+/* pfe_hif_release_buffers */
 static void pfe_hif_release_buffers(struct pfe_hif *hif)
 {
 	struct hif_desc	*desc;
@@ -145,14 +154,19 @@ static void pfe_hif_release_buffers(struct pfe_hif *hif)
 	desc = hif->RxBase;
 	for (i = 0; i < hif->RxRingSize; i++) {
 		if (desc->data) {
-			if ((i < hif->shm->rx_buf_pool_cnt) && (hif->shm->rx_buf_pool[i] == NULL)) {
-				//dma_unmap_single(hif->dev, desc->data,  hif->rx_buf_len[i], DMA_FROM_DEVICE);
-				DMA_UNMAP_SINGLE(hif->dev, desc->data,  hif->rx_buf_len[i], DMA_FROM_DEVICE);
+			if ((i < hif->shm->rx_buf_pool_cnt) &&
+				(hif->shm->rx_buf_pool[i] == NULL)) {
+				/*
+				 * dma_unmap_single(hif->dev, desc->data,
+				 * hif->rx_buf_len[i], DMA_FROM_DEVICE);
+				 */
+				DMA_UNMAP_SINGLE(hif->dev, desc->data,
+				hif->rx_buf_len[i], DMA_FROM_DEVICE);
 				hif->shm->rx_buf_pool[i] = hif->rx_buf_addr[i];
-			}
-			else {
+			} else {
 				/*TODO This should not happen*/
-				printk(KERN_ERR "%s: buffer pool already full\n", __func__);
+				printk(KERN_ERR "%s: buffer pool already full\n"
+					, __func__);
 			}
 		}
 
@@ -166,10 +180,10 @@ static void pfe_hif_release_buffers(struct pfe_hif *hif)
 
 
 /*
- * pfe_hif_init_buffers
- * This function initializes the HIF Rx/Tx ring descriptors and
- * initialize Rx queue with buffers.
- */
+* pfe_hif_init_buffers
+* This function initializes the HIF Rx/Tx ring descriptors and
+* initialize Rx queue with buffers.
+*/
 static int pfe_hif_init_buffers(struct pfe_hif *hif)
 {
 	struct hif_desc	*desc, *first_desc_p;
@@ -193,12 +207,13 @@ static int pfe_hif_init_buffers(struct pfe_hif *hif)
 		/* Initialize Rx buffers from the shared memory */
 
 #if defined(CONFIG_PLATFORM_PCI)
-		data = pfe->ddr_phys_baseaddr + HIF_RX_PKT_DDR_BASEADDR + i * DDR_BUF_SIZE;
+		data = pfe->ddr_phys_baseaddr + HIF_RX_PKT_DDR_BASEADDR + i *
+			DDR_BUF_SIZE;
 #else
-		data = (u32)DMA_MAP_SINGLE(hif->dev, hif->shm->rx_buf_pool[i], pfe_pkt_size, DMA_FROM_DEVICE);
+		data = (u32)DMA_MAP_SINGLE(hif->dev, hif->shm->rx_buf_pool[i],
+				pfe_pkt_size, DMA_FROM_DEVICE);
 		hif->rx_buf_addr[i] = hif->shm->rx_buf_pool[i];
 		hif->rx_buf_len[i] = pfe_pkt_size;
-	//	printk("#%d %p %p %d\n", i, data, hif->rx_buf_addr[i], hif->rx_buf_len[i]);
 		hif->shm->rx_buf_pool[i] = NULL;
 #endif
 		if (likely(dma_mapping_error(hif->dev, data) == 0)) {
@@ -228,7 +243,8 @@ static int pfe_hif_init_buffers(struct pfe_hif *hif)
 	writel(DDR_PHYS_TO_PFE(hif->descr_baseaddr_p), HIF_RX_BDP_ADDR);
 
 	hif->TxBase = hif->RxBase + hif->RxRingSize;
-	first_desc_p = (struct hif_desc *)hif->descr_baseaddr_p + hif->RxRingSize;
+	first_desc_p = (struct hif_desc *)hif->descr_baseaddr_p +
+				hif->RxRingSize;
 	memset(hif->TxBase, 0, hif->TxRingSize * sizeof(struct hif_desc));
 
 	/*Initialize tx descriptors */
@@ -238,7 +254,8 @@ static int pfe_hif_init_buffers(struct pfe_hif *hif)
 		/* Chain descriptors */
 		desc->next = (u32)DDR_PHYS_TO_PFE(first_desc_p + i + 1);
 #if defined(CONFIG_PLATFORM_PCI)
-		desc->data =  pfe->ddr_phys_baseaddr + HIF_TX_PKT_DDR_BASEADDR + i * DDR_BUF_SIZE;
+		desc->data =  pfe->ddr_phys_baseaddr + HIF_TX_PKT_DDR_BASEADDR
+				+ i * DDR_BUF_SIZE;
 #endif
 		desc->ctrl = 0;
 		desc++;
@@ -262,14 +279,16 @@ err:
 	return -ENOMEM;
 }
 
-/* pfe_hif_client_register
- *
- * This function used to register a client driver with the HIF driver.
- *
- * Return value:
- * 0 - on Successful registration
- */
-static int pfe_hif_client_register(struct pfe_hif *hif, u32 client_id, struct hif_client_shm *client_shm)
+/*
+* pfe_hif_client_register
+*
+* This function used to register a client driver with the HIF driver.
+*
+* Return value:
+* 0 - on Successful registration
+*/
+static int pfe_hif_client_register(struct pfe_hif *hif, u32 client_id,
+					struct hif_client_shm *client_shm)
 {
 	struct hif_client *client = &hif->client[client_id];
 	u32 i, cnt;
@@ -284,7 +303,8 @@ static int pfe_hif_client_register(struct pfe_hif *hif, u32 client_id, struct hi
 	spin_lock_bh(&hif->tx_lock);
 
 	if (test_bit(client_id, &hif->shm->gClient_status[0])) {
-		printk(KERN_ERR "%s: client %d already registered\n", __func__, client_id);
+		printk(KERN_ERR "%s: client %d already registered\n",
+			__func__, client_id);
 		err = -1;
 		goto unlock;
 	}
@@ -300,8 +320,7 @@ static int pfe_hif_client_register(struct pfe_hif *hif, u32 client_id, struct hi
 
 	client->rx_qn = cnt;
 	rx_qbase = (struct rx_queue_desc *)client_shm->rx_qbase;
-	for (i = 0; i < cnt; i++)
-	{
+	for (i = 0; i < cnt; i++) {
 		rx_queue = &client->rx_q[i];
 		rx_queue->base = rx_qbase + i * client_shm->rx_qsize;
 		rx_queue->size = client_shm->rx_qsize;
@@ -317,8 +336,7 @@ static int pfe_hif_client_register(struct pfe_hif *hif, u32 client_id, struct hi
 
 	client->tx_qn = cnt;
 	tx_qbase = (struct tx_queue_desc *)client_shm->tx_qbase;
-	for (i = 0; i < cnt; i++)
-	{
+	for (i = 0; i < cnt; i++) {
 		tx_queue = &client->tx_q[i];
 		tx_queue->base = tx_qbase + i * client_shm->tx_qsize;
 		tx_queue->size = client_shm->tx_qsize;
@@ -334,20 +352,25 @@ unlock:
 }
 
 
-/* pfe_hif_client_unregister
- *
- * This function used to unregister a client  from the HIF driver.
- *
- */
+/*
+* pfe_hif_client_unregister
+*
+* This function used to unregister a client  from the HIF driver.
+*
+*/
 static void pfe_hif_client_unregister(struct pfe_hif *hif, u32 client_id)
 {
 	printk(KERN_INFO "%s\n", __func__);
 
-	/* Mark client as no longer available (which prevents further packet receive for this client) */
+	/*
+	* Mark client as no longer available (which prevents further packet
+	* receive for this client)
+	*/
 	spin_lock_bh(&hif->tx_lock);
 
 	if (!test_bit(client_id, &hif->shm->gClient_status[0])) {
-		printk(KERN_ERR "%s: client %d not registered\n", __func__, client_id);
+		printk(KERN_ERR "%s: client %d not registered\n", __func__,
+			client_id);
 
 		spin_unlock_bh(&hif->tx_lock);
 		return;
@@ -358,15 +381,17 @@ static void pfe_hif_client_unregister(struct pfe_hif *hif, u32 client_id)
 	spin_unlock_bh(&hif->tx_lock);
 }
 
-/* client_put_rxpacket-
- * This functions puts the Rx pkt  in the given client Rx queue.
- * It actually swap the Rx pkt in the client Rx descriptor buffer
- * and returns the free buffer from it.
- *
- * If the funtion returns NULL means client Rx queue is full and
- * packet couldn't send to client queue.
- */
-static void *client_put_rxpacket(struct hif_rx_queue *queue, void *pkt, u32 len, u32 flags, u32 client_ctrl, u32 *rem_len)
+/*
+* client_put_rxpacket-
+* This functions puts the Rx pkt  in the given client Rx queue.
+* It actually swap the Rx pkt in the client Rx descriptor buffer
+* and returns the free buffer from it.
+*
+* If the funtion returns NULL means client Rx queue is full and
+* packet couldn't send to client queue.
+*/
+static void *client_put_rxpacket(struct hif_rx_queue *queue, void *pkt, u32 len,
+				u32 flags, u32 client_ctrl, u32 *rem_len)
 {
 	void *free_pkt = NULL;
 	struct rx_queue_desc *desc = queue->base + queue->write_idx;
@@ -379,22 +404,27 @@ static void *client_put_rxpacket(struct hif_rx_queue *queue, void *pkt, u32 len,
 		desc->ctrl = CL_DESC_BUF_LEN(len) | flags;
 		inc_cl_idx(queue->write_idx);
 #else
-		//TODO: move allocations after Rx loop to improve instruction cache locality
+		/*
+		* TODO: move allocations after Rx loop to improve instruction
+		* cache locality
+		*/
 		if (page_mode) {
-			int rem_page_size = PAGE_SIZE -  PRESENT_OFST_IN_PAGE(pkt);
-			int cur_pkt_size = ROUND_MIN_RX_SIZE(len +  pfe_pkt_headroom);
+			int rem_page_size = PAGE_SIZE -
+					PRESENT_OFST_IN_PAGE(pkt);
+			int cur_pkt_size = ROUND_MIN_RX_SIZE(len +
+					pfe_pkt_headroom);
 			*rem_len = (rem_page_size - cur_pkt_size);
-			//printk("%p rem_len %d cur_len %d buf_len %d\n", pkt, rem_page_size, cur_pkt_size, *rem_len);
-			if (*rem_len)
-			{
+			if (*rem_len) {
 				free_pkt = pkt + cur_pkt_size;
 				get_page(virt_to_page(free_pkt));
 			} else {
-				free_pkt = (void *)__get_free_page(GFP_ATOMIC | GFP_DMA_PFE);
+				free_pkt = (void
+				*)__get_free_page(GFP_ATOMIC | GFP_DMA_PFE);
 				*rem_len = pfe_pkt_size;
 			}
 		} else {
-			free_pkt = kmalloc(PFE_BUF_SIZE, GFP_ATOMIC | GFP_DMA_PFE);
+			free_pkt = kmalloc(PFE_BUF_SIZE, GFP_ATOMIC |
+					GFP_DMA_PFE);
 			*rem_len = PFE_BUF_SIZE - pfe_pkt_headroom;
 		}
 
@@ -413,10 +443,11 @@ static void *client_put_rxpacket(struct hif_rx_queue *queue, void *pkt, u32 len,
 }
 
 
-/* pfe_hif_rx_process-
- * This function does pfe hif rx queue processing.
- * Dequeue packet from Rx queue and send it to corresponding client queue 
- */
+/*
+* pfe_hif_rx_process-
+* This function does pfe hif rx queue processing.
+* Dequeue packet from Rx queue and send it to corresponding client queue
+*/
 static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 {
 	struct hif_desc	*desc;
@@ -433,8 +464,7 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 
 	rtc = hif->RxtocleanIndex;
 
-	while (rx_processed < budget)
-	{
+	while (rx_processed < budget) {
 		/*TODO may need to implement rx process budget */
 		desc = hif->RxBase + rtc;
 
@@ -444,11 +474,12 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 		if (local_desc.ctrl & BD_CTRL_DESC_EN) {
 			writel(HIF_INT_MASK, HIF_INT_SRC);
 
-			if(rx_processed == 0)
-			{
-				if(napi_first_batch == 1)
-				{
-					desc_p = hif->descr_baseaddr_p + ((unsigned long int)(desc) - (unsigned long int)hif->descr_baseaddr_v);
+			if (rx_processed == 0) {
+				if (napi_first_batch == 1) {
+					desc_p = hif->descr_baseaddr_p +
+					((unsigned long int)(desc) -
+					(unsigned long
+					int)hif->descr_baseaddr_v);
 #if defined(CONFIG_PLATFORM_C2000)
 					outer_inv_range(desc_p, (desc_p + 16));
 #endif
@@ -470,10 +501,15 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 		len = BD_BUF_LEN(local_desc.ctrl);
 #if defined(CONFIG_PLATFORM_PCI)
 		pkt_hdr = &hif_hdr;
-		memcpy(pkt_hdr, (void *)PFE_PCI_TO_HOST(local_desc.data), sizeof(struct hif_hdr));
+		memcpy(pkt_hdr, (void *)PFE_PCI_TO_HOST(local_desc.data),
+			sizeof(struct hif_hdr));
 #else
-		//dma_unmap_single(hif->dev, DDR_PFE_TO_PHYS(local_desc.data),  hif->rx_buf_len[rtc], DMA_FROM_DEVICE);
-		DMA_UNMAP_SINGLE(hif->dev, DDR_PFE_TO_PHYS(local_desc.data),  hif->rx_buf_len[rtc], DMA_FROM_DEVICE);
+		/*
+		* dma_unmap_single(hif->dev, DDR_PFE_TO_PHYS(local_desc.data),
+		* hif->rx_buf_len[rtc], DMA_FROM_DEVICE);
+		*/
+		DMA_UNMAP_SINGLE(hif->dev, DDR_PFE_TO_PHYS(local_desc.data),
+		hif->rx_buf_len[rtc], DMA_FROM_DEVICE);
 
 		pkt_hdr = (struct hif_hdr *)hif->rx_buf_addr[rtc];
 
@@ -485,13 +521,12 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 
 			hif->qno = hif_hdr.hdr.qNo;
 			hif->client_id = hif_hdr.hdr.client_id;
-			hif->client_ctrl = (hif_hdr.hdr.client_ctrl1 << 16) | hif_hdr.hdr.client_ctrl;
+			hif->client_ctrl = (hif_hdr.hdr.client_ctrl1 << 16) |
+						hif_hdr.hdr.client_ctrl;
 			flags = CL_DESC_FIRST;
 
-//			printk(KERN_INFO "start of packet: id %d, q %d, len %d, flags %x %x\n", hif->client_id, hif->qno, len, local_desc.ctrl, hif->client_ctrl);
-		}
-		else {
-//			printk(KERN_INFO "continuation: id %d, q %d, len %d, flags %x\n", hif->client_id, hif->qno, len, local_desc.ctrl);
+		} else {
+
 			flags = 0;
 		}
 
@@ -499,9 +534,13 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 			flags |= CL_DESC_LAST;
 #endif
 		/* Check for valid client id and still registered */
-		if ((hif->client_id >= HIF_CLIENTS_MAX) || !(test_bit(hif->client_id, &hif->shm->gClient_status[0]))) {
+		if ((hif->client_id >= HIF_CLIENTS_MAX) ||
+		!(test_bit(hif->client_id, &hif->shm->gClient_status[0]))) {
 			if (printk_ratelimit())
-				printk(KERN_ERR "%s: packet with invalid client id %d qNo %d\n", __func__, hif->client_id, hif->qno);
+				printk(KERN_ERR
+					"%s: packet with invalid client id %d qNo %d\n"
+					, __func__, hif->client_id,
+					hif->qno);
 
 #if defined(CONFIG_PLATFORM_PCI)
 			free_buf = local_desc.data;
@@ -513,27 +552,38 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 
 		/* Check to valid queue number */
 		if (hif->client[hif->client_id].rx_qn <= hif->qno) {
-			printk(KERN_INFO "%s: packet with invalid queue: %d\n", __func__, hif->qno);
+			printk(KERN_INFO "%s: packet with invalid queue: %d\n"
+				, __func__, hif->qno);
 			hif->qno = 0;
 		}
 
 #if defined(CONFIG_PLATFORM_PCI)
-		free_buf = client_put_rxpacket(&hif->client[hif->client_id].rx_q[hif->qno],
-				(void *)PFE_PCI_TO_HOST(desc->data), len, flags, hif->client_ctrl, &buf_zize);
+		free_buf =
+		client_put_rxpacket(&hif->client[hif->client_id].rx_q[hif->qno],
+				(void *)PFE_PCI_TO_HOST(desc->data), len,
+			flags, hif->client_ctrl, &buf_zize);
 #else
-		free_buf = client_put_rxpacket(&hif->client[hif->client_id].rx_q[hif->qno],
-				(void *)pkt_hdr, len, flags, hif->client_ctrl, &buf_size);
+		free_buf =
+		client_put_rxpacket(&hif->client[hif->client_id].rx_q[hif->qno],
+				(void *)pkt_hdr, len, flags,
+			hif->client_ctrl, &buf_size);
 #endif
 
-		hif_lib_indicate_client(hif->client_id, EVENT_RX_PKT_IND, hif->qno);
+		hif_lib_indicate_client(hif->client_id, EVENT_RX_PKT_IND,
+			hif->qno);
 
 		if (unlikely(!free_buf)) {
 #ifdef HIF_NAPI_STATS
 			hif->napi_counters[NAPI_CLIENT_FULL_COUNT]++;
 #endif
-			/* If we want to keep in polling mode to retry later, we need to tell napi that we consumed
-			the full budget or we will hit a livelock scenario. The core code keeps this napi instance
-			at the head of the list and none of the other instances get to run */
+			/*
+			 * If we want to keep in polling mode to retry later,
+			 * we need to tell napi that we consumed
+			 * the full budget or we will hit a livelock scenario.
+			 * The core code keeps this napi instance
+			 * at the head of the list and none of the other
+			 * instances get to run
+			 */
 			rx_processed = budget;
 
 			if (flags & CL_DESC_FIRST)
@@ -542,15 +592,15 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 			break;
 		}
 
-	pkt_drop:
+pkt_drop:
 #if defined(CONFIG_PLATFORM_PCI)
 		desc->data = (u32)free_buf;
 #else
 		/*Fill free buffer in the descriptor */
 		hif->rx_buf_addr[rtc] = free_buf;
 		hif->rx_buf_len[rtc] = min(pfe_pkt_size, buf_size);
-		desc->data = DDR_PHYS_TO_PFE((u32)DMA_MAP_SINGLE(hif->dev, free_buf, hif->rx_buf_len[rtc], DMA_FROM_DEVICE));
-		//printk("#%p %p %d\n", desc->data, hif->rx_buf_addr[rtc], hif->rx_buf_len[rtc]);
+		desc->data = DDR_PHYS_TO_PFE((u32)DMA_MAP_SINGLE(hif->dev,
+			free_buf, hif->rx_buf_len[rtc], DMA_FROM_DEVICE));
 #endif
 		wmb();
 		desc->ctrl = BD_CTRL_PKT_INT_EN | BD_CTRL_LIFM | BD_CTRL_DIR |
@@ -580,11 +630,13 @@ static int pfe_hif_rx_process(struct pfe_hif *hif, int budget)
 }
 
 
-/* client_ack_txpacket-
- * This function ack the Tx packet in the give client Tx queue by resetting
- * ownership bit in the descriptor.
- */
-static int client_ack_txpacket(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no)
+/*
+* client_ack_txpacket-
+* This function ack the Tx packet in the give client Tx queue by resetting
+* ownership bit in the descriptor.
+*/
+static int client_ack_txpacket(struct pfe_hif *hif, unsigned int client_id,
+				unsigned int q_no)
 {
 	struct hif_tx_queue *queue = &hif->client[client_id].tx_q[q_no];
 	struct tx_queue_desc *desc = queue->base + queue->ack_idx;
@@ -595,10 +647,12 @@ static int client_ack_txpacket(struct pfe_hif *hif, unsigned int client_id, unsi
 		inc_cl_idx(queue->ack_idx);
 
 		return 0;
-	}
-	else {
+
+	} else {
 		/*This should not happen */
-		printk(KERN_ERR "%s: %d %d %d %d %d %p %d\n", __func__, hif->Txtosend, hif->Txtoclean, hif->TxAvail, client_id, q_no, queue, queue->ack_idx);
+		printk(KERN_ERR "%s: %d %d %d %d %d %p %d\n", __func__,
+			hif->Txtosend, hif->Txtoclean, hif->TxAvail,
+			client_id, q_no, queue, queue->ack_idx);
 		BUG();
 		return 1;
 	}
@@ -623,8 +677,12 @@ void __hif_tx_done_process(struct pfe_hif *hif, int count)
 
 		if (desc_sw->data) {
 #if !defined(CONFIG_PLATFORM_PCI)
-			//dmap_unmap_single(hif->dev, desc_sw->data, desc_sw->len, DMA_TO_DEVICE);
-			DMA_UNMAP_SINGLE(hif->dev, desc_sw->data, desc_sw->len, DMA_TO_DEVICE);
+			/*
+			* dmap_unmap_single(hif->dev, desc_sw->data,
+			* desc_sw->len, DMA_TO_DEVICE);
+			*/
+			DMA_UNMAP_SINGLE(hif->dev, desc_sw->data,
+			desc_sw->len, DMA_TO_DEVICE);
 #endif
 		}
 		client_ack_txpacket(hif, desc_sw->client_id, desc_sw->q_no);
@@ -638,10 +696,12 @@ void __hif_tx_done_process(struct pfe_hif *hif, int count)
 }
 
 
-/* __hif_xmit_pkt -
- * This function puts one packet in the HIF Tx queue
- */
-void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no, void *data, u32 len, unsigned int flags)
+/*
+* __hif_xmit_pkt -
+* This function puts one packet in the HIF Tx queue
+*/
+void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int
+			q_no, void *data, u32 len, unsigned int flags)
 {
 	struct hif_desc	*desc;
 	struct hif_desc_sw *desc_sw;
@@ -652,7 +712,9 @@ void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_
 		struct queue_desc *qdesc = queue->base + queue->write_idx;
 		void *buf;
 
-		printk("%s: packet loop backed client_id:%d qno:%d data : %p len:%d\n", __func__, client_id, q_no, data, len);
+		printk(
+			"%s: packet loop backed client_id:%d qno:%d data : %p len:%d\n"
+			, __func__, client_id, q_no, data, len);
 #if 1
 		if (qdesc->ctrl & CL_DESC_OWN) {
 			buf = (void *)qdesc->data;
@@ -661,7 +723,8 @@ void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_
 			qdesc->ctrl = CL_DESC_BUF_LEN(len);
 			inc_cl_idx(queue->write_idx);
 			printk("%s: packet loop backed..\n", __func__);
-			hif_lib_indicate_client(client_id, EVENT_RX_PKT_IND, q_no);
+			hif_lib_indicate_client(client_id, EVENT_RX_PKT_IND,
+							q_no);
 			client_ack_txpacket(&hif->client[client_id].tx_q[q_no]);
 		}
 #endif
@@ -681,7 +744,8 @@ void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_
 		desc_sw->data = 0;
 		desc->data = (u32)DDR_PHYS_TO_PFE(data);
 	} else {
-		desc_sw->data = DMA_MAP_SINGLE(hif->dev, data, len, DMA_TO_DEVICE);
+		desc_sw->data = DMA_MAP_SINGLE(hif->dev, data, len,
+						DMA_TO_DEVICE);
 		desc->data = (u32)DDR_PHYS_TO_PFE(desc_sw->data);
 	}
 #else
@@ -692,9 +756,12 @@ void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_
 	inc_hif_txidx(hif->Txtosend);
 	hif->TxAvail--;
 
-	/* For TSO we skip actual TX until the last descriptor */
-	/* This reduce the number of required wmb() */
-	if ((flags & HIF_TSO) && (!((flags & HIF_DATA_VALID) && (flags & HIF_LAST_BUFFER))))
+	/*
+	* For TSO we skip actual TX until the last descriptor
+	* This reduce the number of required wmb()
+	*/
+	if ((flags & HIF_TSO) && (!((flags & HIF_DATA_VALID) && (flags &
+				HIF_LAST_BUFFER))))
 		goto skip_tx;
 
 	wmb();
@@ -704,21 +771,28 @@ void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_
 		desc = hif->TxBase + hif->Txtoflush;
 
 		if (desc_sw->flags & HIF_LAST_BUFFER) {
-			if ((desc_sw->client_id < PFE_CL_VWD0) || (desc_sw->client_id > (PFE_CL_VWD0 + MAX_VAP_SUPPORT)))
-				desc->ctrl = BD_CTRL_LIFM | BD_CTRL_BRFETCH_DISABLE |
-						BD_CTRL_RTFETCH_DISABLE | BD_CTRL_PARSE_DISABLE |
-						BD_CTRL_DESC_EN | BD_BUF_LEN(desc_sw->len);
+			if ((desc_sw->client_id < PFE_CL_VWD0) ||
+				(desc_sw->client_id > (PFE_CL_VWD0 +
+					MAX_VAP_SUPPORT)))
+				desc->ctrl = BD_CTRL_LIFM |
+						BD_CTRL_BRFETCH_DISABLE |
+						BD_CTRL_RTFETCH_DISABLE |
+						BD_CTRL_PARSE_DISABLE |
+						BD_CTRL_DESC_EN |
+						BD_BUF_LEN(desc_sw->len);
 			else {
 
-				desc->ctrl = BD_CTRL_LIFM | BD_CTRL_DESC_EN | BD_BUF_LEN(desc_sw->len);
+				desc->ctrl = BD_CTRL_LIFM | BD_CTRL_DESC_EN
+						| BD_BUF_LEN(desc_sw->len);
 			}
-		}
-		else
-			desc->ctrl = BD_CTRL_DESC_EN | BD_BUF_LEN(desc_sw->len);
+		} else
+			desc->ctrl = BD_CTRL_DESC_EN |
+					BD_BUF_LEN(desc_sw->len);
 
 		inc_hif_txidx(hif->Txtoflush);
 	}
-	while (hif->Txtoflush != hif->Txtosend);
+	while (hif->Txtoflush != hif->Txtosend)
+		;
 
 skip_tx:
 	return;
@@ -727,7 +801,8 @@ skip_tx:
 }
 
 
-int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no, void *data, unsigned int len)
+int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no,
+void *data, unsigned int len)
 {
 	int rc = 0;
 
@@ -736,7 +811,8 @@ int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no,
 	if (!hif->TxAvail)
 		rc = 1;
 	else {
-		__hif_xmit_pkt(hif, client_id, q_no, data, len, HIF_FIRST_BUFFER | HIF_LAST_BUFFER);
+		__hif_xmit_pkt(hif, client_id, q_no, data, len,
+				HIF_FIRST_BUFFER | HIF_LAST_BUFFER);
 		hif_tx_dma_start();
 	}
 	if (hif->TxAvail < (hif->TxRingSize >> 1))
@@ -747,9 +823,10 @@ int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no,
 	return rc;
 }
 
-/* hif_isr-
- * This ISR routine processes Rx/Tx done interrupts from the HIF hardware block
- */
+/*
+* hif_isr-
+* This ISR routine processes Rx/Tx done interrupts from the HIF hardware block
+*/
 static irqreturn_t hif_isr(int irq, void *dev_id)
 {
 	struct pfe_hif *hif = (struct pfe_hif *) dev_id;
@@ -759,7 +836,7 @@ static irqreturn_t hif_isr(int irq, void *dev_id)
 	int_status = readl_relaxed(HIF_INT_SRC);
 
 	if ((int_status & HIF_INT) == 0)
-		return(IRQ_NONE);
+		return IRQ_NONE;
 
 	int_status &= ~(HIF_INT);
 
@@ -768,11 +845,10 @@ static irqreturn_t hif_isr(int irq, void *dev_id)
 
 		/* Disable interrupts */
 		writel_relaxed(0, HIF_INT_ENABLE);
-		
+
 		napi_first_batch = 1;
-		
-		if (napi_schedule_prep(&hif->napi))
-		{
+
+		if (napi_schedule_prep(&hif->napi)) {
 #ifdef HIF_NAPI_STATS
 			hif->napi_counters[NAPI_SCHED_COUNT]++;
 #endif
@@ -781,7 +857,8 @@ static irqreturn_t hif_isr(int irq, void *dev_id)
 	}
 
 	if (int_status) {
-		printk(KERN_INFO "%s : Invalid interrupt : %d\n", __func__, int_status);
+		printk(KERN_INFO "%s : Invalid interrupt : %d\n", __func__,
+			int_status);
 		writel(int_status, HIF_INT_SRC);
 	}
 
@@ -793,41 +870,48 @@ void hif_process_client_req(struct pfe_hif *hif, int req, int data1, int data2)
 {
 	unsigned int client_id = data1;
 
-	if (client_id >= HIF_CLIENTS_MAX)
-	{
-		printk(KERN_ERR "%s: client id %d out of bounds\n", __func__, client_id);
+	if (client_id >= HIF_CLIENTS_MAX) {
+		printk(KERN_ERR "%s: client id %d out of bounds\n", __func__,
+			client_id);
 		return;
 	}
 
 	switch (req) {
-		case REQUEST_CL_REGISTER:
+	case REQUEST_CL_REGISTER:
 			/* Request for register a client */
-			printk(KERN_INFO "%s: register client_id %d\n", __func__, client_id);
-			pfe_hif_client_register(hif, client_id, (struct hif_client_shm *)&hif->shm->client[client_id]);
+			printk(KERN_INFO "%s: register client_id %d\n",
+				__func__, client_id);
+			pfe_hif_client_register(hif, client_id, (struct
+				hif_client_shm *)&hif->shm->client[client_id]);
 			break;
 
-		case REQUEST_CL_UNREGISTER:
-			printk(KERN_INFO "%s: unregister client_id %d\n", __func__, client_id);
+	case REQUEST_CL_UNREGISTER:
+			printk(KERN_INFO "%s: unregister client_id %d\n",
+				__func__, client_id);
 
 			/* Request for unregister a client */
 			pfe_hif_client_unregister(hif, client_id);
 
 			break;
 
-		default:
-			printk(KERN_ERR "%s: unsupported request %d\n", __func__, req);
+	default:
+			printk(KERN_ERR "%s: unsupported request %d\n",
+				__func__, req);
 			break;
 	}
 
 	/*TODO check for TMU queue resume request */
 
-	/*Process client Tx queues
-	 * Currently we don't have checking for tx pending*/
+	/*
+	* Process client Tx queues
+	* Currently we don't have checking for tx pending
+	*/
 }
 
-/** pfe_hif_rx_poll
- *  This function is NAPI poll function to process HIF Rx queue.
- */
+/*
+* pfe_hif_rx_poll
+*  This function is NAPI poll function to process HIF Rx queue.
+*/
 static int pfe_hif_rx_poll(struct napi_struct *napi, int budget)
 {
 	struct pfe_hif *hif = container_of(napi, struct pfe_hif, napi);
@@ -839,8 +923,7 @@ static int pfe_hif_rx_poll(struct napi_struct *napi, int budget)
 
 	work_done = pfe_hif_rx_process(hif, budget);
 
-	if (work_done < budget)
-	{
+	if (work_done < budget) {
 		napi_complete(napi);
 		writel_relaxed(HIF_INT_MASK, HIF_INT_ENABLE);
 	}
@@ -852,9 +935,10 @@ static int pfe_hif_rx_poll(struct napi_struct *napi, int budget)
 	return work_done;
 }
 
-/* pfe_hif_init
- * This function initializes the baseaddresses and irq, etc.
- */
+/*
+* pfe_hif_init
+* This function initializes the baseaddresses and irq, etc.
+*/
 int pfe_hif_init(struct pfe *pfe)
 {
 	struct pfe_hif *hif = &pfe->hif;
@@ -865,19 +949,21 @@ int pfe_hif_init(struct pfe *pfe)
 	hif->dev = pfe->dev;
 	hif->irq = pfe->hif_irq;
 
-	if ((err = pfe_hif_alloc_descr(hif))) {
+	if ((err = pfe_hif_alloc_descr(hif)))
 		goto err0;
-	}
 
-	if (pfe_hif_init_buffers(hif)) { 
-		printk(KERN_ERR "%s: Could not initialize buffer descriptors\n", __func__);
+	if (pfe_hif_init_buffers(hif)) {
+		printk(KERN_ERR
+			"%s: Could not initialize buffer descriptors\n"
+			, __func__);
 		err = -ENOMEM;
 		goto err1;
 	}
 
 	/* Initilize NAPI for Rx processing */
 	init_dummy_netdev(&hif->dummy_dev);
-	netif_napi_add(&hif->dummy_dev, &hif->napi, pfe_hif_rx_poll, HIF_RX_POLL_WEIGHT);
+	netif_napi_add(&hif->dummy_dev, &hif->napi, pfe_hif_rx_poll,
+			HIF_RX_POLL_WEIGHT);
 	napi_enable(&hif->napi);
 
 	spin_lock_init(&hif->tx_lock);
@@ -895,7 +981,8 @@ int pfe_hif_init(struct pfe *pfe)
 #ifdef __KERNEL__
 	err = request_irq(hif->irq, hif_isr, 0, "pfe_hif", hif);
 	if (err) {
-		printk(KERN_ERR "%s: failed to get the hif IRQ = %d\n",  __func__, hif->irq);
+		printk(KERN_ERR "%s: failed to get the hif IRQ = %d\n",
+			__func__, hif->irq);
 		goto err1;
 	}
 #else
@@ -909,8 +996,7 @@ err0:
 	return err;
 }
 
-/* pfe_hif_exit-
- */
+/* pfe_hif_exit- */
 void pfe_hif_exit(struct pfe *pfe)
 {
 	struct pfe_hif *hif = &pfe->hif;
@@ -919,7 +1005,8 @@ void pfe_hif_exit(struct pfe *pfe)
 
 	spin_lock_bh(&hif->lock);
 	hif->shm->gClient_status[0] = 0;
-	hif->shm->gClient_status[1] = 0; /* Make sure all clients are disabled */
+	/* Make sure all clients are disabled*/
+	hif->shm->gClient_status[1] = 0;
 
 	spin_unlock_bh(&hif->lock);
 
diff --git a/drivers/staging/fsl_ppfe/pfe_hif.h b/drivers/staging/fsl_ppfe/pfe_hif.h
index 7aaad0b..ed7ebed 100644
--- a/drivers/staging/fsl_ppfe/pfe_hif.h
+++ b/drivers/staging/fsl_ppfe/pfe_hif.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_HIF_H_
 #define _PFE_HIF_H_
@@ -29,8 +29,10 @@
 
 #define HIF_RX_PKT_MIN_SIZE 0x800 /* 2KB */
 #define HIF_RX_PKT_MIN_SIZE_MASK ~(HIF_RX_PKT_MIN_SIZE - 1)
-#define ROUND_MIN_RX_SIZE(_sz) ((_sz + (HIF_RX_PKT_MIN_SIZE - 1)) & HIF_RX_PKT_MIN_SIZE_MASK)
-#define PRESENT_OFST_IN_PAGE(_buf) (((unsigned long int)_buf & (PAGE_SIZE - 1)) & HIF_RX_PKT_MIN_SIZE_MASK)
+#define ROUND_MIN_RX_SIZE(_sz) ((_sz + (HIF_RX_PKT_MIN_SIZE - 1)) \
+					& HIF_RX_PKT_MIN_SIZE_MASK)
+#define PRESENT_OFST_IN_PAGE(_buf) (((unsigned long int)_buf & (PAGE_SIZE \
+					- 1)) & HIF_RX_PKT_MIN_SIZE_MASK)
 
 enum {
 	NAPI_SCHED_COUNT = 0,
@@ -43,14 +45,15 @@ enum {
 };
 
 
-/* XXX  HIF_TX_DESC_NT value should be always greter than 4,
- *      Otherwise HIF_TX_POLL_MARK will become zero.
- */
+/*
+* XXX  HIF_TX_DESC_NT value should be always greter than 4,
+*      Otherwise HIF_TX_POLL_MARK will become zero.
+*/
 #if defined(CONFIG_PLATFORM_PCI)
 #define HIF_RX_DESC_NT		4
 #define HIF_TX_DESC_NT		4
 #else
-#if defined(CONFIG_COMCERTO_64K_PAGES) 
+#if defined(CONFIG_COMCERTO_64K_PAGES)
 #define HIF_RX_DESC_NT		64
 #else
 #define HIF_RX_DESC_NT		256
@@ -60,7 +63,7 @@ enum {
 
 #define HIF_FIRST_BUFFER		(1 << 0)
 #define HIF_LAST_BUFFER		(1 << 1)
-#define HIF_DONT_DMA_MAP		(1 << 2) //TODO merge it with TSO
+#define HIF_DONT_DMA_MAP		(1 << 2) /*TODO merge it with TSO */
 #define HIF_DATA_VALID			(1 << 3)
 #define HIF_TSO			(1 << 4)
 
@@ -93,7 +96,7 @@ struct hif_tx_queue {
 /*Structure to store the client info */
 struct hif_client {
 	int	rx_qn;
-	struct hif_rx_queue 	rx_q[HIF_CLIENT_QUEUES_MAX];
+	struct hif_rx_queue	rx_q[HIF_CLIENT_QUEUES_MAX];
 	int	tx_qn;
 	struct hif_tx_queue	tx_q[HIF_CLIENT_QUEUES_MAX];
 };
@@ -141,7 +144,7 @@ struct hif_lro_hdr {
 
 struct hif_ipsec_hdr {
 	u16	sa_handle[2];
-}__attribute__((packed));
+} __packed;
 
 #define MAX_TSO_BUF_DESCS 5
 struct hif_tso_buf_desc {
@@ -157,19 +160,19 @@ struct hif_tso_hdr {
 	u16	ip_len;
 	u16	tcp_off;
 	u32	tcp_seq;
-} __attribute__((packed));
+} __packed;
 
 struct hif_tso_hdr_nocpy {
 	struct	hif_tso_hdr tso_hdr;
 	struct hif_tso_buf_desc bdesc[MAX_TSO_BUF_DESCS];
-} __attribute__((packed));
+} __packed;
 
 struct hif_pcap_hdr {
 	u8	ifindex;
-	u8 	unused;
+	u8	unused;
 	u16	seqno;
 	u32	timestamp;
-}__attribute__((packed));
+} __packed;
 
 /*  HIF_CTRL_TX... defines */
 #define HIF_CTRL_TX_TSO_NOCPY		(1 << 8)
@@ -237,10 +240,13 @@ struct pfe_hif {
 #endif
 };
 
-void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no, void *data, u32 len, unsigned int flags);
-int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no, void *data, unsigned int len);
+void __hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int
+			q_no, void *data, u32 len, unsigned int flags);
+int hif_xmit_pkt(struct pfe_hif *hif, unsigned int client_id, unsigned int q_no,
+			void *data, unsigned int len);
 void __hif_tx_done_process(struct pfe_hif *hif, int count);
-void hif_process_client_req(struct pfe_hif *hif, int req, int data1, int data2);
+void hif_process_client_req(struct pfe_hif *hif, int req, int data1, int
+				data2);
 int pfe_hif_init(struct pfe *pfe);
 void pfe_hif_exit(struct pfe *pfe);
 
@@ -269,35 +275,36 @@ static inline int __hif_tx_avail(struct pfe_hif *hif)
 #if defined(CONFIG_PLATFORM_C2000)
 static inline void __memcpy8(void *dst, void *src)
 {
-	asm volatile (	"ldm %1, {r9, r10}\n\t"
+	asm volatile ("ldm %1, {r9, r10}\n\t"
 			"stm %0, {r9, r10}\n\t"
 			:
 			: "r" (dst), "r" (src)
 			: "r9", "r10", "memory"
-		);
+	);
 }
 
 static inline void __memcpy12(void *dst, void *src)
 {
-	asm volatile (	"ldm %1, {r8, r9, r10}\n\t"
+	asm volatile ("ldm %1, {r8, r9, r10}\n\t"
 			"stm %0, {r8, r9, r10}\n\t"
 			:
 			: "r" (dst), "r" (src)
 			: "r8", "r9", "r10", "memory"
-		);
+	);
 }
 
 static inline void __memcpy16(void *dst, void *src)
 {
-	asm volatile (	"ldm %1, {r7, r8, r9, r10}\n\t"
+	asm volatile ("ldm %1, {r7, r8, r9, r10}\n\t"
 			"stm %0, {r7, r8, r9, r10}\n\t"
 			:
 			: "r"(dst), "r"(src)
 			: "r7", "r8", "r9", "r10", "memory"
-		);
+	);
 }
 
-#define HIF_MEMCPY_BURSTSIZE 32                 /*__memcpy copy 32byte in a burst*/
+/*__memcpy copy 32byte in a burst*/
+#define HIF_MEMCPY_BURSTSIZE 32
 static inline void __memcpy(void *dst, void *src, unsigned int len)
 {
 	void *end = src + len;
@@ -306,12 +313,13 @@ static inline void __memcpy(void *dst, void *src, unsigned int len)
 	src = (void *)((unsigned long)src & ~0x3);
 
 	while (src < end) {
-		asm volatile (	"ldm %1!, {r3, r4, r5, r6, r7, r8, r9, r10}\n\t"
-				"stm %0!, {r3, r4, r5, r6, r7, r8, r9, r10}\n\t"
+		asm volatile (
+			"ldm %1!, {r3, r4, r5, r6, r7, r8, r9, r10}\n\t"
+			"stm %0!, {r3, r4, r5, r6, r7, r8, r9, r10}\n\t"
 				: "+r"(dst), "+r"(src)
 				:
-				: "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "memory"
-			);
+				: "r3", "r4", "r5", "r6", "r7", "r8", "r9",
+					"r10", "memory");
 	}
 }
 #else
diff --git a/drivers/staging/fsl_ppfe/pfe_hif_lib.c b/drivers/staging/fsl_ppfe/pfe_hif_lib.c
index 89f6f5f..fad0727 100644
--- a/drivers/staging/fsl_ppfe/pfe_hif_lib.c
+++ b/drivers/staging/fsl_ppfe/pfe_hif_lib.c
@@ -1,24 +1,24 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 #include <asm/system.h>
 #endif
 #include <linux/kernel.h>
@@ -31,8 +31,8 @@
 #include <linux/skbuff.h>
 #include <linux/moduleparam.h>
 #include <linux/cpu.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-//#include <asm/system_info.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+/*#include <asm/system_info.h> */
 #endif
 
 #include "pfe_mod.h"
@@ -41,16 +41,16 @@
 #include "pfe_ctrl_hal.h"
 
 
-unsigned int lro_mode = 0;
-unsigned int page_mode = 0;
-unsigned int tx_qos = 0;
+unsigned int lro_mode;
+unsigned int page_mode;
+unsigned int tx_qos;
 unsigned int pfe_pkt_size;
 unsigned int pfe_pkt_headroom;
 unsigned int emac_txq_cnt;
 
 /** @pfe_hal_lib.c.
- * Common functions used by HIF client drivers
- */
+* Common functions used by HIF client drivers
+*/
 
 /*HIF shared memory Global variable */
 struct hif_shm ghif_shm;
@@ -59,10 +59,10 @@ struct hif_shm ghif_shm;
 unsigned int TMU_DMEM_SH(tx_trans)[EMAC_TXQ_CNT];
 
 /* Cleanup the HIF shared memory, release HIF rx_buffer_pool.
- * This function should be called after pfe_hif_exit
- *
- * @param[in] hif_shm		Shared memory address location in DDR
- */
+* This function should be called after pfe_hif_exit
+*
+* @param[in] hif_shm		Shared memory address location in DDR
+*/
 static void pfe_hif_shm_clean(struct hif_shm *hif_shm)
 {
 	int i;
@@ -74,21 +74,21 @@ static void pfe_hif_shm_clean(struct hif_shm *hif_shm)
 			hif_shm->rx_buf_pool[i] = NULL;
 			pkt -= pfe_pkt_headroom;
 
-			if (page_mode) {
+			if (page_mode)
 				put_page(virt_to_page(pkt));
-			} else
+			else
 				kfree(pkt);
 		}
 	}
 }
 
-/* Initialize shared memory used between HIF driver and clients, 
- * allocate rx_buffer_pool required for HIF Rx descriptors.
- * This function should be called before initializing HIF driver.
- *
- * @param[in] hif_shm		Shared memory address location in DDR
- * @rerurn			0 - on succes, <0 on fail to initialize
- */
+/* Initialize shared memory used between HIF driver and clients,
+* allocate rx_buffer_pool required for HIF Rx descriptors.
+* This function should be called before initializing HIF driver.
+*
+* @param[in] hif_shm		Shared memory address location in DDR
+* @rerurn			0 - on succes, <0 on fail to initialize
+*/
 static int pfe_hif_shm_init(struct hif_shm *hif_shm)
 {
 	int i;
@@ -99,7 +99,8 @@ static int pfe_hif_shm_init(struct hif_shm *hif_shm)
 
 	for (i = 0; i < hif_shm->rx_buf_pool_cnt; i++) {
 		if (page_mode) {
-			pkt = (void *)__get_free_page(GFP_KERNEL | GFP_DMA_PFE);
+			pkt = (void *)__get_free_page(GFP_KERNEL |
+				GFP_DMA_PFE);
 		} else
 			pkt = kmalloc(PFE_BUF_SIZE, GFP_KERNEL | GFP_DMA_PFE);
 
@@ -117,13 +118,17 @@ err0:
 	return -ENOMEM;
 }
 
-/*This function sends indication to HIF driver 
- *
- * @param[in] hif	hif context
- **/
-static void hif_lib_indicate_hif(struct pfe_hif *hif, int req, int data1, int data2)
+/*This function sends indication to HIF driver
+*
+* @param[in] hif	hif context
+**/
+static void hif_lib_indicate_hif(struct pfe_hif *hif, int req, int data1, int
+					data2)
 {
-	//TODO : If we separate HIF and HIF LIB, then send req and data through shared memory.
+	/*
+	* TODO : If we separate HIF and HIF LIB, then send req and data through
+	* shared memory.
+	*/
 
 	hif_process_client_req(hif, req, data1, data2);
 }
@@ -133,24 +138,26 @@ void hif_lib_indicate_client(int client_id, int event_type, int qno)
 	struct hif_client_s *client = pfe->hif_client[client_id];
 
 	/*
-	 * TODO : Right now, all events are queue number based. So we are masking events per queue 
-	 *        basis. Later if we add any events those do not depend on queue number, then we may
+	 * TODO : Right now, all events are queue number based. So we are
+	 * masking events per queue
+	 * basis. Later if we add any events those do not depend on
+	 * queue number, then we may
 	 *	  may need may need to add masking per event.
 	 */
-	if (!client || (event_type >= HIF_EVENT_MAX) || (qno >= HIF_CLIENT_QUEUES_MAX) )
+	if (!client || (event_type >= HIF_EVENT_MAX) || (qno >=
+		HIF_CLIENT_QUEUES_MAX))
 		return;
 
-	if (!test_and_set_bit(qno, &client->queue_mask[event_type])) {
+	if (!test_and_set_bit(qno, &client->queue_mask[event_type]))
 		client->event_handler(client->priv, event_type, qno);
-	}
 
 }
 
 
 /*This function releases Rx queue descriptors memory and pre-filled buffers
- *
- * @param[in] client	hif_client context
- */
+*
+* @param[in] client	hif_client context
+*/
 static void hif_lib_client_release_rx_buffers(struct hif_client_s *client)
 {
 	struct rx_queue_desc *desc;
@@ -182,31 +189,34 @@ static void hif_lib_client_release_rx_buffers(struct hif_client_s *client)
 
 
 /*This function allocates memory for the rxq descriptors and pre-fill rx queues
- * with buffers.
- * @param[in] client	client context
- * @param[in] q_size	size of the rxQ, all queues are of same size
- */
-static int hif_lib_client_init_rx_buffers(struct hif_client_s *client, int q_size)
+* with buffers.
+* @param[in] client	client context
+* @param[in] q_size	size of the rxQ, all queues are of same size
+*/
+static int hif_lib_client_init_rx_buffers(struct hif_client_s *client, int
+						q_size)
 {
 	struct rx_queue_desc *desc;
 	struct hif_client_rx_queue *queue;
 	int ii, qno;
 
 	/*Allocate memory for the client queues */
-	client->rx_qbase = kzalloc(client->rx_qn * q_size * sizeof(struct rx_queue_desc), GFP_KERNEL);
-	if (!client->rx_qbase){
+	client->rx_qbase = kzalloc(client->rx_qn * q_size * sizeof(struct
+				rx_queue_desc), GFP_KERNEL);
+	if (!client->rx_qbase)
 		goto err;
-	}
 
 	for (qno = 0; qno < client->rx_qn; qno++) {
 		queue = &client->rx_q[qno];
 
-		queue->base = client->rx_qbase + qno * q_size * sizeof(struct rx_queue_desc);
+		queue->base = client->rx_qbase + qno * q_size * sizeof(struct
+				rx_queue_desc);
 		queue->size = q_size;
 		queue->read_idx = 0;
 		queue->write_idx = 0;
 
-		dbg_print_info("rx queue: %d, base: %p, size: %d \n", qno, queue->base, queue->size);
+		dbg_print_info("rx queue: %d, base: %p, size: %d\n", qno,
+				queue->base, queue->size);
 	}
 
 	for (qno = 0; qno < client->rx_qn; qno++) {
@@ -214,7 +224,8 @@ static int hif_lib_client_init_rx_buffers(struct hif_client_s *client, int q_siz
 		desc = queue->base;
 
 		for (ii = 0; ii < queue->size; ii++) {
-			desc->ctrl = CL_DESC_BUF_LEN(pfe_pkt_size) | CL_DESC_OWN;
+			desc->ctrl = CL_DESC_BUF_LEN(pfe_pkt_size) |
+					CL_DESC_OWN;
 			desc++;
 		}
 	}
@@ -225,16 +236,19 @@ err:
 	return 1;
 }
 
-#define inc_cl_idx(idxname) idxname = (idxname+1) & (queue->size-1)
+#define inc_cl_idx(idxname) (idxname = (idxname+1) & (queue->size-1))
 
 static void hif_lib_client_cleanup_tx_queue(struct hif_client_tx_queue *queue)
 {
-	dbg_print_info( "%s\n", __func__);
-
-	/* Check if there are any pending packets. Client must flush the tx queues
-	before unregistering, by calling by calling hif_lib_tx_get_next_complete() */
-	/* Hif no longer calls since we are no longer registered */
+	dbg_print_info("%s\n", __func__);
 
+	/*
+	* Check if there are any pending packets. Client must flush the tx
+	* queues before unregistering, by calling by calling
+	* hif_lib_tx_get_next_complete()
+	*
+	* Hif no longer calls since we are no longer registered
+	*/
 	if (queue->tx_pending)
 		printk(KERN_ERR "%s: pending transmit packets\n", __func__);
 }
@@ -245,27 +259,28 @@ static void hif_lib_client_release_tx_buffers(struct hif_client_s *client)
 
 	dbg_print_info("%s\n", __func__);
 
-	for (qno = 0; qno < client->tx_qn; qno++) {
+	for (qno = 0; qno < client->tx_qn; qno++)
 		hif_lib_client_cleanup_tx_queue(&client->tx_q[qno]);
-	}
 
 	kfree(client->tx_qbase);
 }
 
-static int hif_lib_client_init_tx_buffers(struct hif_client_s *client, int q_size)
+static int hif_lib_client_init_tx_buffers(struct hif_client_s *client, int
+						q_size)
 {
 	struct hif_client_tx_queue *queue;
 	int qno;
 
-	client->tx_qbase = kzalloc(client->tx_qn * q_size * sizeof(struct tx_queue_desc), GFP_KERNEL);
-	if (!client->tx_qbase) {
+	client->tx_qbase = kzalloc(client->tx_qn * q_size * sizeof(struct
+					tx_queue_desc), GFP_KERNEL);
+	if (!client->tx_qbase)
 		return 1;
-	}
 
 	for (qno = 0; qno < client->tx_qn; qno++) {
 		queue = &client->tx_q[qno];
 
-		queue->base = client->tx_qbase + qno * q_size * sizeof(struct tx_queue_desc);
+		queue->base = client->tx_qbase + qno * q_size * sizeof(struct
+				tx_queue_desc);
 		queue->size = q_size;
 		queue->read_idx = 0;
 		queue->write_idx = 0;
@@ -274,13 +289,14 @@ static int hif_lib_client_init_tx_buffers(struct hif_client_s *client, int q_siz
 		queue->prev_tmu_tx_pkts = 0;
 		queue->done_tmu_tx_pkts = 0;
 
-		dbg_print_info("tx queue: %d, base: %p, size: %d \n", qno, queue->base, queue->size);
+		dbg_print_info("tx queue: %d, base: %p, size: %d\n", qno,
+				queue->base, queue->size);
 	}
 
 	return 0;
 }
 
-static int hif_lib_event_dummy( void *priv, int event_type, int qno)
+static int hif_lib_event_dummy(void *priv, int event_type, int qno)
 {
 	return 0;
 }
@@ -290,7 +306,7 @@ int hif_lib_client_register(struct hif_client_s *client)
 	struct hif_shm *hif_shm;
 	struct hif_client_shm *client_shm;
 	int err, i;
-//	int loop_cnt = 0;
+	/* int loop_cnt = 0; */
 
 	dbg_print_info("%s\n", __func__);
 
@@ -306,14 +322,15 @@ int hif_lib_client_register(struct hif_client_s *client)
 	}
 
 	spin_lock_bh(&pfe->hif.lock);
-	if (!(client->pfe) || (client->id >= HIF_CLIENTS_MAX) || (pfe->hif_client[client->id])) {
+	if (!(client->pfe) || (client->id >= HIF_CLIENTS_MAX) ||
+		(pfe->hif_client[client->id])) {
 		err = -EINVAL;
 		goto err;
 	}
 
 	hif_shm = client->pfe->hif.shm;
 
-	if (!client->event_handler) 
+	if (!client->event_handler)
 		client->event_handler = hif_lib_event_dummy;
 
 	/*Initialize client specific shared memory */
@@ -322,18 +339,24 @@ int hif_lib_client_register(struct hif_client_s *client)
 	client_shm->rx_qsize = client->rx_qsize;
 	client_shm->tx_qbase = (unsigned long int)client->tx_qbase;
 	client_shm->tx_qsize = client->tx_qsize;
-	client_shm->ctrl = (client->tx_qn << CLIENT_CTRL_TX_Q_CNT_OFST) | (client->rx_qn << CLIENT_CTRL_RX_Q_CNT_OFST);
-//	spin_lock_init(&client->rx_lock);
+	client_shm->ctrl = (client->tx_qn << CLIENT_CTRL_TX_Q_CNT_OFST) |
+				(client->rx_qn << CLIENT_CTRL_RX_Q_CNT_OFST);
+	/* spin_lock_init(&client->rx_lock); */
 
 	for (i = 0; i < HIF_EVENT_MAX; i++) {
-		client->queue_mask[i] = 0; /* By default all events are unmasked */
+		client->queue_mask[i] = 0;  /*
+					    * By default all events are
+					    * unmasked
+					    */
 	}
 
 	/*Indicate to HIF driver*/
 	hif_lib_indicate_hif(&pfe->hif, REQUEST_CL_REGISTER, client->id, 0);
 
-	dbg_print_info("%s: client: %p, client_id: %d, tx_qsize: %d, rx_qsize: %d\n",
-			__func__, client, client->id, client->tx_qsize, client->rx_qsize);
+	dbg_print_info(
+		"%s: client: %p, client_id: %d, tx_qsize: %d, rx_qsize: %d\n",
+			__func__, client, client->id, client->tx_qsize,
+		client->rx_qsize);
 
 	client->cpu_id = -1;
 
@@ -358,8 +381,10 @@ int hif_lib_client_unregister(struct hif_client_s *client)
 	struct pfe *pfe = client->pfe;
 	u32 client_id = client->id;
 
-	printk(KERN_INFO "%s : client: %p, client_id: %d, txQ_depth: %d, rxQ_depth: %d\n",
-			__func__, client, client->id, client->tx_qsize, client->rx_qsize);
+	printk(KERN_INFO
+		"%s : client: %p, client_id: %d, txQ_depth: %d, rxQ_depth: %d\n"
+		, __func__, client, client->id, client->tx_qsize,
+		client->rx_qsize);
 
 
 	spin_lock_bh(&pfe->hif.lock);
@@ -373,13 +398,16 @@ int hif_lib_client_unregister(struct hif_client_s *client)
 	return 0;
 }
 
-int hif_lib_event_handler_start(struct hif_client_s *client, int event, int qno)
+int hif_lib_event_handler_start(struct hif_client_s *client, int event,
+					int qno)
 {
 	struct hif_client_rx_queue *queue = &client->rx_q[qno];
 	struct rx_queue_desc *desc = queue->base + queue->read_idx;
 
-	if ((event >= HIF_EVENT_MAX) || ( qno >= HIF_CLIENT_QUEUES_MAX)) {
-		dbg_print_info("%s: Unsupported event : %d  queue number : %d\n", __func__, event, qno);
+	if ((event >= HIF_EVENT_MAX) || (qno >= HIF_CLIENT_QUEUES_MAX)) {
+		dbg_print_info(
+			"%s: Unsupported event : %d  queue number : %d\n"
+			, __func__, event, qno);
 		return -1;
 	}
 
@@ -388,7 +416,8 @@ int hif_lib_event_handler_start(struct hif_client_s *client, int event, int qno)
 	switch (event) {
 	case EVENT_RX_PKT_IND:
 		if (!(desc->ctrl & CL_DESC_OWN))
-			 hif_lib_indicate_client(client->id, EVENT_RX_PKT_IND, qno);
+			hif_lib_indicate_client(client->id,
+						EVENT_RX_PKT_IND, qno);
 		break;
 
 	case EVENT_HIGH_RX_WM:
@@ -401,27 +430,33 @@ int hif_lib_event_handler_start(struct hif_client_s *client, int event, int qno)
 }
 
 
-/*This function gets one packet from the specified client queue
- * It also refill the rx buffer */
-void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int *ofst, unsigned int *rx_ctrl, unsigned int *desc_ctrl, void **priv_data)
+/*
+* This function gets one packet from the specified client queue
+* It also refill the rx buffer
+*/
+void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int
+				*ofst, unsigned int *rx_ctrl,
+				unsigned int *desc_ctrl, void **priv_data)
 {
 	struct hif_client_rx_queue *queue = &client->rx_q[qno];
 	struct rx_queue_desc *desc;
 	void *pkt = NULL;
 
-	//printk(KERN_INFO "%s\n", __func__);
 #if defined(CONFIG_PLATFORM_EMULATION)
-	printk(KERN_INFO "%s:qno:%d cid:%d desc:%p rdidx:%d \n", 
-			__func__, qno, client->id, desc, 
+	printk(KERN_INFO "%s:qno:%d cid:%d desc:%p rdidx:%d\n",
+			__func__, qno, client->id, desc,
 			queue->read_idx);
 #endif
 
-	/* Following lock is to protect rx queue access from, hif_lib_event_handler_start.
-	 * In general below lock is not required, because hif_lib_xmit_pkt and
-	 * hif_lib_event_handler_start are called from napi poll and which is not 
-	 * re-entrant. But if some client use in different way this lock is required.
-	 */
-	//spin_lock_irqsave(&client->rx_lock, flags);
+	/*
+	* Following lock is to protect rx queue access from,
+	* hif_lib_event_handler_start.
+	* In general below lock is not required, because hif_lib_xmit_pkt and
+	* hif_lib_event_handler_start are called from napi poll and which is
+	* not re-entrant. But if some client use in different way this lock is
+	* required.
+	*/
+	/*spin_lock_irqsave(&client->rx_lock, flags); */
 	desc = queue->base + queue->read_idx;
 	if (!(desc->ctrl & CL_DESC_OWN)) {
 		pkt = desc->data - pfe_pkt_headroom;
@@ -433,11 +468,14 @@ void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int *o
 			u16 size = *rx_ctrl >> HIF_CTRL_RX_OFFSET_OFST;
 
 			if (size) {
-				*len = CL_DESC_BUF_LEN(desc->ctrl) - PFE_PKT_HEADER_SZ - size;
-				*ofst = pfe_pkt_headroom + PFE_PKT_HEADER_SZ + size;
+				*len = CL_DESC_BUF_LEN(desc->ctrl) -
+						PFE_PKT_HEADER_SZ - size;
+				*ofst = pfe_pkt_headroom + PFE_PKT_HEADER_SZ
+								+ size;
 				*priv_data = desc->data + PFE_PKT_HEADER_SZ;
 			} else {
-				*len = CL_DESC_BUF_LEN(desc->ctrl) - PFE_PKT_HEADER_SZ;
+				*len = CL_DESC_BUF_LEN(desc->ctrl) -
+						PFE_PKT_HEADER_SZ;
 				*ofst = pfe_pkt_headroom + PFE_PKT_HEADER_SZ;
 				*priv_data = NULL;
 			}
@@ -447,22 +485,29 @@ void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int *o
 			*ofst = pfe_pkt_headroom;
 		}
 
-		desc->data = NULL; // Needed so we don't free a buffer/page twice on module_exit
+		/*
+		* Needed so we don't free a buffer/page
+		* twice on module_exit
+		*/
+		desc->data = NULL;
 		smp_wmb();
 
 		desc->ctrl = CL_DESC_BUF_LEN(pfe_pkt_size) | CL_DESC_OWN;
 		inc_cl_idx(queue->read_idx);
 	}
 
-	//spin_unlock_irqrestore(&client->rx_lock, flags);
+	/*spin_unlock_irqrestore(&client->rx_lock, flags); */
 	return pkt;
 }
 
-static inline void hif_hdr_write(struct hif_hdr *pkt_hdr, unsigned int client_id, unsigned int qno, u32 client_ctrl)
+static inline void hif_hdr_write(struct hif_hdr *pkt_hdr, unsigned int
+					client_id, unsigned int qno,
+					u32 client_ctrl)
 {
 	/* Optimize the write since the destinaton may be non-cacheable */
 	if (!((unsigned long)pkt_hdr & 0x3)) {
-		((u32 *)pkt_hdr)[0] = (client_ctrl << 16) | (qno << 8) | client_id;
+		((u32 *)pkt_hdr)[0] = (client_ctrl << 16) | (qno << 8) |
+					client_id;
 	} else {
 		((u16 *)pkt_hdr)[0] = (qno << 8) | (client_id & 0xFF);
 		((u16 *)pkt_hdr)[1] = (client_ctrl & 0xFFFF);
@@ -470,16 +515,16 @@ static inline void hif_hdr_write(struct hif_hdr *pkt_hdr, unsigned int client_id
 }
 
 /*This function puts the given packet in the specific client queue */
-void __hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data, unsigned int len, u32 client_ctrl, unsigned int flags, void *client_data)
+void __hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void
+				*data, unsigned int len, u32 client_ctrl,
+				unsigned int flags, void *client_data)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 	struct tx_queue_desc *desc = queue->base + queue->write_idx;
 
-	//printk(KERN_INFO "%s\n",__func__);
 
 	/* First buffer */
-	if (flags & HIF_FIRST_BUFFER)
-	{
+	if (flags & HIF_FIRST_BUFFER) {
 		data -= sizeof(struct hif_hdr);
 		len += sizeof(struct hif_hdr);
 
@@ -498,12 +543,12 @@ void __hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *dat
 }
 
 /*This function puts the given packet in the specific client queue */
-int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data, unsigned int len, u32 client_ctrl, void *client_data)
+int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data,
+			unsigned int len, u32 client_ctrl, void *client_data)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 	struct tx_queue_desc *desc = queue->base + queue->write_idx;
 
-	//printk(KERN_INFO "%s\n",__func__);
 
 	if (queue->tx_pending < queue->size) {
 		/*Construct pkt header */
@@ -514,7 +559,8 @@ int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data,
 		hif_hdr_write(data, client->id, qno, client_ctrl);
 
 		desc->data = client_data;
-		desc->ctrl = CL_DESC_OWN | CL_DESC_FLAGS(HIF_FIRST_BUFFER | HIF_LAST_BUFFER | HIF_DATA_VALID);
+		desc->ctrl = CL_DESC_OWN | CL_DESC_FLAGS(HIF_FIRST_BUFFER |
+				HIF_LAST_BUFFER | HIF_DATA_VALID);
 
 		if (hif_xmit_pkt(&pfe->hif, client->id, qno, data, len))
 			return 1;
@@ -526,39 +572,44 @@ int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data,
 		return 0;
 	}
 
-	dbg_print_info("%s Tx client %d qno %d is full\n",__func__, client->id, qno);
+	dbg_print_info("%s Tx client %d qno %d is full\n", __func__, client->id,
+			qno);
 	return 1;
 }
 
-void *hif_lib_tx_get_next_complete(struct hif_client_s *client, int qno, unsigned int *flags, int count)
+void *hif_lib_tx_get_next_complete(struct hif_client_s *client, int qno,
+					unsigned int *flags, int count)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 	struct tx_queue_desc *desc = queue->base + queue->read_idx;
 
-	dbg_print_info("%s: qno : %d rd_indx: %d pending:%d\n",__func__, qno, queue->read_idx, queue->tx_pending);
+	dbg_print_info("%s: qno : %d rd_indx: %d pending:%d\n", __func__, qno,
+			queue->read_idx, queue->tx_pending);
 
-	if (!queue->tx_pending )
+	if (!queue->tx_pending)
 		return NULL;
 
 	if (queue->nocpy_flag && !queue->done_tmu_tx_pkts) {
-		u32 tmu_tx_pkts = be32_to_cpu(pe_dmem_read(TMU0_ID + client->id, virt_to_tmu_dmem(&tx_trans[qno]), 4));
+		u32 tmu_tx_pkts = be32_to_cpu(pe_dmem_read(TMU0_ID +
+			client->id, virt_to_tmu_dmem(&tx_trans[qno]), 4));
 
 		if (queue->prev_tmu_tx_pkts > tmu_tx_pkts)
-			queue->done_tmu_tx_pkts = UINT_MAX - queue->prev_tmu_tx_pkts + tmu_tx_pkts;
+			queue->done_tmu_tx_pkts = UINT_MAX -
+				queue->prev_tmu_tx_pkts + tmu_tx_pkts;
 		else
-			queue->done_tmu_tx_pkts = tmu_tx_pkts - queue->prev_tmu_tx_pkts;
+			queue->done_tmu_tx_pkts = tmu_tx_pkts -
+						queue->prev_tmu_tx_pkts;
 
 		queue->prev_tmu_tx_pkts  = tmu_tx_pkts;
 
-		if (!queue->done_tmu_tx_pkts) {
+		if (!queue->done_tmu_tx_pkts)
 			return NULL;
-		}
 	}
 
 	if (desc->ctrl & CL_DESC_OWN) {
 		hif_tx_done_process(&pfe->hif, count);
 
-		//Check again, if packets done in tx queue.
+		/*Check again, if packets done in tx queue. */
 		if (desc->ctrl & CL_DESC_OWN)
 			return NULL;
 	}
@@ -575,45 +626,60 @@ void *hif_lib_tx_get_next_complete(struct hif_client_s *client, int qno, unsigne
 	return desc->data;
 }
 
-//FIXME: TMU queues length mapping needs to be declared in shared PFE/PFE_CTRL header
+/*
+* FIXME: TMU queues length mapping needs to be declared in shared PFE/PFE_CTRL
+* header
+*/
 static void hif_lib_tmu_credit_init(struct pfe *pfe)
 {
 	int i, q;
 
 	for (i = 0; i < NUM_GEMAC_SUPPORT; i++)
 		for (q = 0; q < emac_txq_cnt; q++) {
-			pfe->tmu_credit.tx_credit_max[i][q] = (q == 0) ? DEFAULT_Q0_QDEPTH : DEFAULT_MAX_QDEPTH;
-			pfe->tmu_credit.tx_credit[i][q] = pfe->tmu_credit.tx_credit_max[i][q];
+			pfe->tmu_credit.tx_credit_max[i][q] = (q == 0) ?
+					DEFAULT_Q0_QDEPTH : DEFAULT_MAX_QDEPTH;
+			pfe->tmu_credit.tx_credit[i][q] =
+					pfe->tmu_credit.tx_credit_max[i][q];
 		}
 }
 /** __hif_lib_update_credit
- *
- * @param[in] client	hif client context
- * @param[in] queue	queue number in match with TMU
- */
+*
+* @param[in] client	hif client context
+* @param[in] queue	queue number in match with TMU
+*/
 void __hif_lib_update_credit(struct hif_client_s *client, unsigned int queue)
 {
 	unsigned int tmu_tx_packets, tmp;
 
 	if (tx_qos) {
-		tmu_tx_packets = be32_to_cpu(pe_dmem_read(TMU0_ID + client->id, virt_to_tmu_dmem(&tx_trans[queue]), 4));
-
-		// tx_packets counter overflowed
-		if (tmu_tx_packets > pfe->tmu_credit.tx_packets[client->id][queue]) {
-			tmp = UINT_MAX - tmu_tx_packets + pfe->tmu_credit.tx_packets[client->id][queue];
-			pfe->tmu_credit.tx_credit[client->id][queue] = pfe->tmu_credit.tx_credit_max[client->id][queue] - tmp;
+		tmu_tx_packets = be32_to_cpu(pe_dmem_read(TMU0_ID +
+			client->id, virt_to_tmu_dmem(&tx_trans[queue]), 4));
+
+		/* tx_packets counter overflowed */
+		if (tmu_tx_packets >
+			pfe->tmu_credit.tx_packets[client->id][queue]) {
+			tmp = UINT_MAX - tmu_tx_packets +
+			pfe->tmu_credit.tx_packets[client->id][queue];
+			pfe->tmu_credit.tx_credit[client->id][queue] =
+			pfe->tmu_credit.tx_credit_max[client->id][queue] - tmp;
 		}
-		// TMU tx <= pfe_eth tx, normal case or both OF since last time
+		/*
+		* TMU tx <= pfe_eth tx, normal case or both OF since last
+		* time
+		*/
 		else
-			pfe->tmu_credit.tx_credit[client->id][queue] = pfe->tmu_credit.tx_credit_max[client->id][queue] - (pfe->tmu_credit.tx_packets[client->id][queue] - tmu_tx_packets);
+			pfe->tmu_credit.tx_credit[client->id][queue] =
+			pfe->tmu_credit.tx_credit_max[client->id][queue] -
+				(pfe->tmu_credit.tx_packets[client->id][queue]
+				- tmu_tx_packets);
 	}
 }
 
 /** hif_lib_update_credit
- *
- * @param[in] client	hif client context
- * @param[in] queue	queue number in match with TMU
- */
+*
+* @param[in] client	hif client context
+* @param[in] queue	queue number in match with TMU
+*/
 void hif_lib_update_credit(struct hif_client_s *client, unsigned int queue)
 {
 	spin_lock_bh(&pfe->hif.tx_lock);
diff --git a/drivers/staging/fsl_ppfe/pfe_hif_lib.h b/drivers/staging/fsl_ppfe/pfe_hif_lib.h
index 1e9a134..20d85be 100644
--- a/drivers/staging/fsl_ppfe/pfe_hif_lib.h
+++ b/drivers/staging/fsl_ppfe/pfe_hif_lib.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_HIF_LIB_H_
 #define _PFE_HIF_LIB_H_
@@ -23,10 +23,10 @@
 #include "pfe_hif.h"
 
 #ifdef HIF_LIB_DEBUG
-#define dbg_print_info( fmt, args...) \
+#define dbg_print_info(fmt, args...) \
 	printk(KERN_INFO fmt, ##args)
 #else
-#define dbg_print_info( fmt, args...) 
+#define dbg_print_info(fmt, args...)
 #endif
 
 #define HIF_CL_REQ_TIMEOUT	10
@@ -44,9 +44,12 @@ enum {
 };
 
 enum {
-	EVENT_HIGH_RX_WM = 0,     /* Event to indicate that client rx queue is reached water mark level */
-	EVENT_RX_PKT_IND,	/* Event to indicate that, packet recieved for client */
-	EVENT_TXDONE_IND,	/* Event to indicate that, packet tx done for client */
+	/* Event to indicate that client rx queue is reached water mark level */
+	EVENT_HIGH_RX_WM = 0,
+	/* Event to indicate that, packet recieved for client */
+	EVENT_RX_PKT_IND,
+	/* Event to indicate that, packet tx done for client */
+	EVENT_TXDONE_IND,
 	HIF_EVENT_MAX
 };
 
@@ -71,22 +74,24 @@ struct hif_client_tx_queue {
 	u32	prev_tmu_tx_pkts;
 	u32	done_tmu_tx_pkts;
 	u32	cur_tso_hdr_p;
-	int 	tso_buf_cnt;
+	int	tso_buf_cnt;
 };
 
-struct hif_client_s
-{
+struct hif_client_s {
 	int	id;
 	int	tx_qn;
 	int	rx_qn;
 	void	*rx_qbase;
 	void	*tx_qbase;
-	/* FIXME tx/rx_qsize fields  can be removed after per queue depth is supported*/
+	/*
+	* FIXME tx/rx_qsize fields  can be removed after per queue depth is
+	* supported
+	*/
 	int	tx_qsize;
 	int	rx_qsize;
 	int	cpu_id;
 
-//	spinlock_t 	rx_lock;
+	/*	spinlock_t	rx_lock; */
 	struct hif_client_tx_queue tx_q[HIF_CLIENT_QUEUES_MAX];
 	struct hif_client_rx_queue rx_q[HIF_CLIENT_QUEUES_MAX];
 	int (*event_handler)(void *priv, int event, int data);
@@ -96,8 +101,10 @@ struct hif_client_s
 };
 
 
-/* Client specific shared memory 
- * It contains number of Rx/Tx queues, base addresses and queue sizes */
+/*
+* Client specific shared memory
+* It contains number of Rx/Tx queues, base addresses and queue sizes
+*/
 struct hif_client_shm {
 	u32 ctrl; /*0-7: number of Rx queues, 8-15: number of tx queues */
 	unsigned long rx_qbase; /*Rx queue base address */
@@ -109,30 +116,39 @@ struct hif_client_shm {
 /*Client shared memory ctrl bit description */
 #define CLIENT_CTRL_RX_Q_CNT_OFST	0
 #define CLIENT_CTRL_TX_Q_CNT_OFST	8
-#define CLIENT_CTRL_RX_Q_CNT(ctrl)	(((ctrl) >> CLIENT_CTRL_RX_Q_CNT_OFST) & 0xFF)
-#define CLIENT_CTRL_TX_Q_CNT(ctrl)	(((ctrl) >> CLIENT_CTRL_TX_Q_CNT_OFST) & 0xFF)
+#define CLIENT_CTRL_RX_Q_CNT(ctrl)	(((ctrl) >> CLIENT_CTRL_RX_Q_CNT_OFST) \
+						& 0xFF)
+#define CLIENT_CTRL_TX_Q_CNT(ctrl)	(((ctrl) >> CLIENT_CTRL_TX_Q_CNT_OFST) \
+						& 0xFF)
 
 
 
-/*Shared memory used to communicate between HIF driver and host/client drivers
- * Before starting the hif driver rx_buf_pool ans rx_buf_pool_cnt should be 
- * initialized with host buffers and buffers count in the pool. 
- * rx_buf_pool_cnt should be >= HIF_RX_DESC_NT.
- * 
- */
+/*
+* Shared memory used to communicate between HIF driver and host/client drivers
+* Before starting the hif driver rx_buf_pool ans rx_buf_pool_cnt should be
+* initialized with host buffers and buffers count in the pool.
+* rx_buf_pool_cnt should be >= HIF_RX_DESC_NT.
+*
+*/
 struct hif_shm {
 	u32 rx_buf_pool_cnt; /*Number of rx buffers available*/
-	void *rx_buf_pool[HIF_RX_DESC_NT];/*Rx buffers required to initialize HIF rx descriptors */
+	/*Rx buffers required to initialize HIF rx descriptors */
+	void *rx_buf_pool[HIF_RX_DESC_NT];
 	unsigned long gClient_status[2]; /*Global client status bit mask */
 	u32 hif_qfull; /*TODO Client-id that caused for the TMU3 queue stop */
 	u32 hif_qresume; /*TODO */
-	struct hif_client_shm client[HIF_CLIENTS_MAX]; /* Client specific shared memory */
+	/* Client specific shared memory */
+	struct hif_client_shm client[HIF_CLIENTS_MAX];
 };
 
 
-#define CL_DESC_OWN			(1 << 31) /* This sets owner ship to HIF driver */
-#define CL_DESC_LAST		(1 << 30) /* This indicates last packet for multi buffers handling */
-#define CL_DESC_FIRST		(1 << 29) /* This indicates first packet for multi buffers handling */
+#define CL_DESC_OWN			(1 << 31)
+/* This sets owner ship to HIF driver */
+#define CL_DESC_LAST		(1 << 30)
+/* This indicates last packet for multi buffers handling */
+#define CL_DESC_FIRST		(1 << 29)
+/* This indicates first packet for multi buffers handling */
+
 #define CL_DESC_BUF_LEN(x)		((x) & 0xFFFF)
 #define CL_DESC_FLAGS(x)		(((x) & 0xF) << 16)
 #define CL_DESC_GET_FLAGS(x)		(((x) >> 16) & 0xF)
@@ -148,23 +164,30 @@ struct tx_queue_desc {
 	u32	ctrl; /*0-15bit len, 16-20bit flags, 31bit owner*/
 };
 
-/* HIF Rx is not working properly for 2-byte aligned buffers and   
- * ip_header should be 4byte aligned for better iperformance.
- * "ip_header = 64 + 6(hif_header) + 14 (MAC Header)" will be 4byte aligned. 
- */
+/*
+* HIF Rx is not working properly for 2-byte aligned buffers and
+* ip_header should be 4byte aligned for better iperformance.
+* "ip_header = 64 + 6(hif_header) + 14 (MAC Header)" will be 4byte aligned.
+*/
 #define PFE_PKT_HEADER_SZ	sizeof(struct hif_hdr)
-#define PFE_BUF_SIZE		2048	/* must be big enough for headroom, pkt size and skb shared info */
+#define PFE_BUF_SIZE		2048
+/* must be big enough for headroom, pkt size and skb shared info */
 #define PFE_PKT_HEADROOM	128
-#define SKB_SHARED_INFO_SIZE	256    /* At least sizeof(struct skb_shared_info) bytes */
+#define SKB_SHARED_INFO_SIZE	(sizeof(struct skb_shared_info))
+#define PFE_PKT_SIZE		(PFE_BUF_SIZE - PFE_PKT_HEADROOM \
+					- SKB_SHARED_INFO_SIZE)
 
-//#define PFE_PKT_SIZE		1544	/* maximum ethernet packet size */
-#define PFE_PKT_SIZE		(PFE_BUF_SIZE - PFE_PKT_HEADROOM - SKB_SHARED_INFO_SIZE)	/* maximum ethernet packet size after reassembly offload*/
 #define MAX_L2_HDR_SIZE		14	/* Not correct for VLAN/PPPoE */
 #define MAX_L3_HDR_SIZE		20	/* Not correct for IPv6 */
 #define MAX_L4_HDR_SIZE		60	/* TCP with maximum options */
-#define MAX_HDR_SIZE		(MAX_L2_HDR_SIZE + MAX_L3_HDR_SIZE + MAX_L4_HDR_SIZE)
-#define MAX_WIFI_HDR_SIZE 	(MAX_L2_HDR_SIZE + MAX_L3_HDR_SIZE + 6)
-#define MAX_PFE_PKT_SIZE	16380UL		/* Used in page mode to clamp packet size to the maximum supported by the hif hw interface (<16KiB) */
+#define MAX_HDR_SIZE		(MAX_L2_HDR_SIZE + MAX_L3_HDR_SIZE + \
+					MAX_L4_HDR_SIZE)
+#define MAX_WIFI_HDR_SIZE	(MAX_L2_HDR_SIZE + MAX_L3_HDR_SIZE + 6)
+#define MAX_PFE_PKT_SIZE	16380UL
+/*
+* Used in page mode to clamp packet size to the maximum
+* supported by the hif hw interface (<16KiB)
+*/
 
 extern unsigned int pfe_pkt_size;
 extern unsigned int pfe_pkt_headroom;
@@ -177,27 +200,40 @@ int pfe_hif_lib_init(struct pfe *pfe);
 void pfe_hif_lib_exit(struct pfe *pfe);
 int hif_lib_client_register(struct hif_client_s *client);
 int hif_lib_client_unregister(struct  hif_client_s *client);
-void __hif_lib_xmit_tso_hdr(struct hif_client_s *client, unsigned int qno, u32 client_ctrl, unsigned int ip_off, unsigned int ip_id, unsigned int ip_len, unsigned int tcp_off, unsigned int tcp_seq);
-void __hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data, unsigned int len, u32 client_ctrl, unsigned int flags, void *client_data);
-int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data, unsigned int len, u32 client_ctrl, void *client_data);
+void __hif_lib_xmit_tso_hdr(struct hif_client_s *client, unsigned int qno, u32
+				client_ctrl, unsigned int ip_off,
+				unsigned int ip_id, unsigned int ip_len,
+				unsigned int tcp_off, unsigned int tcp_seq);
+void __hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void
+				*data, unsigned int len, u32 client_ctrl,
+				unsigned int flags, void *client_data);
+int hif_lib_xmit_pkt(struct hif_client_s *client, unsigned int qno, void *data,
+unsigned int len, u32 client_ctrl, void *client_data);
 void hif_lib_indicate_client(int cl_id, int event, int data);
-int hif_lib_event_handler_start( struct hif_client_s *client, int event, int data );
-int hif_lib_tmu_queue_start( struct hif_client_s *client, int qno );
-int hif_lib_tmu_queue_stop( struct hif_client_s *client, int qno );
-void *hif_lib_tx_get_next_complete(struct hif_client_s *client, int qno, unsigned int *flags, int count);
-void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int *ofst, unsigned int *rx_ctrl, unsigned int *desc_ctrl, void **priv_data);
+int hif_lib_event_handler_start(struct hif_client_s *client, int event, int
+					data);
+int hif_lib_tmu_queue_start(struct hif_client_s *client, int qno);
+int hif_lib_tmu_queue_stop(struct hif_client_s *client, int qno);
+void *hif_lib_tx_get_next_complete(struct hif_client_s *client, int qno,
+					unsigned int *flags, int count);
+void *hif_lib_receive_pkt(struct hif_client_s *client, int qno, int *len, int
+				*ofst, unsigned int *rx_ctrl,
+				unsigned int *desc_ctrl, void **priv_data);
 void hif_lib_update_credit(struct hif_client_s *client, unsigned int qno);
 void __hif_lib_update_credit(struct hif_client_s *client, unsigned int queue);
 void hif_lib_set_rx_cpu_affinity(struct hif_client_s *client, int cpu_id);
-void hif_lib_set_tx_queue_nocpy(struct hif_client_s *client, int qno, int enable);
-static inline int hif_lib_tx_avail(struct hif_client_s *client, unsigned int qno)
+void hif_lib_set_tx_queue_nocpy(struct hif_client_s *client, int qno, int
+					enable);
+static inline int hif_lib_tx_avail(struct hif_client_s *client, unsigned int
+					qno)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 
 	return (queue->size - queue->tx_pending);
 }
 
-static inline int hif_lib_get_tx_wrIndex(struct hif_client_s *client, unsigned int qno)
+static inline int hif_lib_get_tx_wrIndex(struct hif_client_s *client, unsigned
+						int qno)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 
@@ -205,7 +241,8 @@ static inline int hif_lib_get_tx_wrIndex(struct hif_client_s *client, unsigned i
 }
 
 
-static inline int hif_lib_tx_pending(struct hif_client_s *client, unsigned int qno)
+static inline int hif_lib_tx_pending(struct hif_client_s *client, unsigned int
+					qno)
 {
 	struct hif_client_tx_queue *queue = &client->tx_q[qno];
 
@@ -213,7 +250,11 @@ static inline int hif_lib_tx_pending(struct hif_client_s *client, unsigned int q
 }
 
 #define hif_lib_tx_credit_avail(pfe, id, qno) pfe->tmu_credit.tx_credit[id][qno]
-#define hif_lib_tx_credit_max(pfe, id, qno) pfe->tmu_credit.tx_credit_max[id][qno]
-#define hif_lib_tx_credit_use(pfe, id, qno, credit) do {if (tx_qos) {pfe->tmu_credit.tx_credit[id][qno]-= credit; pfe->tmu_credit.tx_packets[id][qno]+=credit;}} while (0)
+#define hif_lib_tx_credit_max(pfe, id, qno\
+				) pfe->tmu_credit.tx_credit_max[id][qno]
+#define hif_lib_tx_credit_use(pfe, id, qno, credit) do {if (tx_qos) \
+				{pfe->tmu_credit.tx_credit[id][qno] -= credit; \
+				pfe->tmu_credit.tx_packets[id][qno] += credit;\
+				} } while (0)
 
 #endif /* _PFE_HIF_LIB_H_ */
diff --git a/drivers/staging/fsl_ppfe/pfe_hw.c b/drivers/staging/fsl_ppfe/pfe_hw.c
index 7b30c38..d8aaded 100644
--- a/drivers/staging/fsl_ppfe/pfe_hw.c
+++ b/drivers/staging/fsl_ppfe/pfe_hw.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #include "pfe_mod.h"
 #include "pfe_hw.h"
@@ -26,7 +26,8 @@ int pfe_hw_init(struct pfe *pfe, int resume)
 {
 	CLASS_CFG class_cfg = {
 		.pe_sys_clk_ratio = PE_SYS_CLK_RATIO,
-		.route_table_baseaddr = pfe->ddr_phys_baseaddr + ROUTE_TABLE_BASEADDR,
+		.route_table_baseaddr = pfe->ddr_phys_baseaddr +
+					ROUTE_TABLE_BASEADDR,
 		.route_table_hash_bits = ROUTE_TABLE_HASH_BITS,
 	};
 
@@ -43,13 +44,15 @@ int pfe_hw_init(struct pfe *pfe, int resume)
 #endif
 
 	BMU_CFG bmu1_cfg = {
-		.baseaddr = CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR + BMU1_LMEM_BASEADDR),
+		.baseaddr = CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR +
+						BMU1_LMEM_BASEADDR),
 		.count = BMU1_BUF_COUNT,
 		.size = BMU1_BUF_SIZE,
 	};
 
 	BMU_CFG bmu2_cfg = {
-		.baseaddr = DDR_PHYS_TO_PFE(pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR),
+		.baseaddr = DDR_PHYS_TO_PFE(pfe->ddr_phys_baseaddr +
+						BMU2_DDR_BASEADDR),
 		.count = BMU2_BUF_COUNT,
 		.size = BMU2_BUF_SIZE,
 	};
@@ -84,33 +87,42 @@ int pfe_hw_init(struct pfe *pfe, int resume)
 
 #if defined(CONFIG_PLATFORM_LS1012A) && !defined(LS1012A_PFE_RESET_WA)
 	/* LS1012A needs this to make PE work correctly */
-        writel(0x3,     CLASS_PE_SYS_CLK_RATIO);
-        writel(0x3,     TMU_PE_SYS_CLK_RATIO);
-        writel(0x3,     UTIL_PE_SYS_CLK_RATIO);
-        udelay(10);
+	writel(0x3,     CLASS_PE_SYS_CLK_RATIO);
+	writel(0x3,     TMU_PE_SYS_CLK_RATIO);
+	writel(0x3,     UTIL_PE_SYS_CLK_RATIO);
+	udelay(10);
 #endif
 
 	printk(KERN_INFO "CLASS version: %x\n", readl(CLASS_VERSION));
 	printk(KERN_INFO "TMU version: %x\n", readl(TMU_VERSION));
 
-	printk(KERN_INFO "BMU1 version: %x\n", readl(BMU1_BASE_ADDR + BMU_VERSION));
-	printk(KERN_INFO "BMU2 version: %x\n", readl(BMU2_BASE_ADDR + BMU_VERSION));
+	printk(KERN_INFO "BMU1 version: %x\n", readl(BMU1_BASE_ADDR +
+		BMU_VERSION));
+	printk(KERN_INFO "BMU2 version: %x\n", readl(BMU2_BASE_ADDR +
+		BMU_VERSION));
 #if defined(CONFIG_PLATFORM_C2000)
-	printk(KERN_INFO "EMAC1 network cfg: %x\n", readl(EMAC1_BASE_ADDR + EMAC_NETWORK_CONFIG));
-	printk(KERN_INFO "EMAC2 network cfg: %x\n", readl(EMAC2_BASE_ADDR + EMAC_NETWORK_CONFIG));
+	printk(KERN_INFO "EMAC1 network cfg: %x\n", readl(EMAC1_BASE_ADDR +
+		EMAC_NETWORK_CONFIG));
+	printk(KERN_INFO "EMAC2 network cfg: %x\n", readl(EMAC2_BASE_ADDR +
+		EMAC_NETWORK_CONFIG));
 #if !defined(CONFIG_PLATFORM_PCI)
-	printk(KERN_INFO "EMAC3 network cfg: %x\n", readl(EMAC3_BASE_ADDR + EMAC_NETWORK_CONFIG));
+	printk(KERN_INFO "EMAC3 network cfg: %x\n", readl(EMAC3_BASE_ADDR +
+		EMAC_NETWORK_CONFIG));
 #endif
 #else
-	//TODO print MTIP config
+	/*TODO print MTIP config */
 #endif
 
-	printk(KERN_INFO "EGPI1 version: %x\n", readl(EGPI1_BASE_ADDR + GPI_VERSION));
-	printk(KERN_INFO "EGPI2 version: %x\n", readl(EGPI2_BASE_ADDR + GPI_VERSION));
+	printk(KERN_INFO "EGPI1 version: %x\n", readl(EGPI1_BASE_ADDR +
+		GPI_VERSION));
+	printk(KERN_INFO "EGPI2 version: %x\n", readl(EGPI2_BASE_ADDR +
+		GPI_VERSION));
 #if !defined(CONFIG_PLATFORM_PCI) && !defined(CONFIG_PLATFORM_LS1012A)
-	printk(KERN_INFO "EGPI3 version: %x\n", readl(EGPI3_BASE_ADDR + GPI_VERSION));
+	printk(KERN_INFO "EGPI3 version: %x\n", readl(EGPI3_BASE_ADDR +
+		GPI_VERSION));
 #endif
-	printk(KERN_INFO "HGPI version: %x\n", readl(HGPI_BASE_ADDR + GPI_VERSION));
+	printk(KERN_INFO "HGPI version: %x\n", readl(HGPI_BASE_ADDR +
+		GPI_VERSION));
 
 #if !defined(CONFIG_PLATFORM_PCI)
 	printk(KERN_INFO "GPT version: %x\n", readl(CBUS_GPT_VERSION));
@@ -122,7 +134,8 @@ int pfe_hw_init(struct pfe *pfe, int resume)
 #if !defined(CONFIG_UTIL_DISABLED)
 	printk(KERN_INFO "UTIL version: %x\n", readl(UTIL_VERSION));
 #endif
-	while(!(readl(TMU_CTRL) & ECC_MEM_INIT_DONE)) ;
+	while (!(readl(TMU_CTRL) & ECC_MEM_INIT_DONE))
+		;
 
 	hif_rx_disable();
 	hif_tx_disable();
diff --git a/drivers/staging/fsl_ppfe/pfe_hw.h b/drivers/staging/fsl_ppfe/pfe_hw.h
index 69ef630..eed0df4 100644
--- a/drivers/staging/fsl_ppfe/pfe_hw.h
+++ b/drivers/staging/fsl_ppfe/pfe_hw.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_HW_H_
 #define _PFE_HW_H_
diff --git a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
index 5550a43..7ea7c42 100644
--- a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
+++ b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #include <linux/module.h>
 #include <linux/device.h>
@@ -34,8 +34,10 @@ struct comcerto_pfe_platform_data pfe_platform_data;
 
 
 
-static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int if_cnt,
-					struct comcerto_pfe_platform_data *pdata)
+static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
+					if_cnt,
+					struct comcerto_pfe_platform_data
+					*pdata)
 {
 	struct device_node *gem = NULL, *phy = NULL;
 	int size;
@@ -53,7 +55,8 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	}
 
 	if (ii >= if_cnt) {
-		printk(KERN_ERR "%s:%d Failed to find interface = %d\n", __func__, __LINE__, if_cnt);
+		printk(KERN_ERR "%s:%d Failed to find interface = %d\n",
+		__func__, __LINE__, if_cnt);
 		goto err;
 	}
 
@@ -62,43 +65,53 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	mac_addr = of_get_mac_address(gem);
 
 	if (mac_addr) {
-		memcpy(pdata->comcerto_eth_pdata[port].mac_addr, mac_addr, ETH_ALEN);
+		memcpy(pdata->comcerto_eth_pdata[port].mac_addr, mac_addr,
+			ETH_ALEN);
 	}
 
-	if ((pdata->comcerto_eth_pdata[port].mii_config = of_get_phy_mode(gem)) < 0)
-		printk(KERN_ERR "%s:%d Incorrect Phy mode....\n", __func__, __LINE__);
+	if ((pdata->comcerto_eth_pdata[port].mii_config = of_get_phy_mode(gem))
+		< 0)
+		printk(KERN_ERR "%s:%d Incorrect Phy mode....\n", __func__,
+			__LINE__);
 
 
 	addr = of_get_property(gem, "fsl,gemac-bus-id", &size);
 	if (!addr)
-		printk(KERN_ERR "%s:%d Invalid gemac-bus-id....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Invalid gemac-bus-id....\n", __func__,
+			__LINE__);
 	else
 		pdata->comcerto_eth_pdata[port].bus_id = be32_to_cpup(addr);
 
 	addr = of_get_property(gem, "fsl,gemac-phy-id", &size);
 	if (!addr)
-		printk(KERN_ERR "%s:%d Invalid gemac-phy-id....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Invalid gemac-phy-id....\n", __func__,
+			__LINE__);
 	else
-		phy_id = pdata->comcerto_eth_pdata[port].phy_id = be32_to_cpup(addr);
+		phy_id = pdata->comcerto_eth_pdata[port].phy_id =
+				be32_to_cpup(addr);
 
 	addr = of_get_property(gem, "fsl,mdio-mux-val", &size);
 	if (!addr)
 		printk(KERN_ERR "%s: Invalid mdio-mux-val....\n", __func__);
 	else
-		phy_id = pdata->comcerto_eth_pdata[port].mdio_muxval= be32_to_cpup(addr);
+		phy_id = pdata->comcerto_eth_pdata[port].mdio_muxval =
+			be32_to_cpup(addr);
 
 
 	addr = of_get_property(gem, "fsl,pfe-phy-if-flags", &size);
 	if (!addr)
-		printk(KERN_ERR "%s:%d Invalid pfe-phy-if-flags....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Invalid pfe-phy-if-flags....\n",
+			__func__, __LINE__);
 	else
 		pdata->comcerto_eth_pdata[port].phy_flags = be32_to_cpup(addr);
 
 	addr = of_get_property(gem, "fsl,pfe-gemac-mode", &size);
 	if (!addr)
-		printk(KERN_ERR "%s:%d Invalid pfe-gemac-mode....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Invalid pfe-gemac-mode....\n",
+			__func__, __LINE__);
 	else
-		pdata->comcerto_eth_pdata[port].gemac_mode = be32_to_cpup(addr);
+		pdata->comcerto_eth_pdata[port].gemac_mode =
+			be32_to_cpup(addr);
 
 
 	/* If PHY is enabled, read mdio properties */
@@ -108,17 +121,19 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	phy = of_get_next_child(gem, NULL);
 
 	addr = of_get_property(phy, "reg", &size);
-        
+
 	if (!addr)
-		printk(KERN_ERR "%s:%d Invalid phy enable flag....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Invalid phy enable flag....\n",
+			__func__, __LINE__);
 	else
 		pdata->comcerto_mdio_pdata[port].enabled = be32_to_cpup(addr);
 
-	addr = of_get_property (phy, "fsl,mdio-phy-mask", &size);
+	addr = of_get_property(phy, "fsl,mdio-phy-mask", &size);
 	if (!addr)
-		printk(KERN_ERR "%s:%d Unable to read mdio-phy-mask....\n", __func__, __LINE__);
+		printk(KERN_ERR "%s:%d Unable to read mdio-phy-mask....\n",
+			__func__, __LINE__);
 	else
-		pdata->comcerto_mdio_pdata[port].phy_mask= be32_to_cpup(addr);
+		pdata->comcerto_mdio_pdata[port].phy_mask = be32_to_cpup(addr);
 	pdata->comcerto_mdio_pdata[port].irq[0] = PHY_POLL;
 
 done:
@@ -129,10 +144,10 @@ err:
 	return -1;
 }
 /**
- * pfe_platform_probe -
- *
- *
- */
+* pfe_platform_probe -
+*
+*
+*/
 static int pfe_platform_probe(struct platform_device *pdev)
 {
 	struct resource res;
@@ -157,8 +172,7 @@ static int pfe_platform_probe(struct platform_device *pdev)
 
 	dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
 
-	if (of_address_to_resource(np, 2, &res))
-	{
+	if (of_address_to_resource(np, 2, &res)) {
 		rc = -ENOMEM;
 		printk(KERN_ERR "failed to get ddr resource\n");
 		goto err_ddr;
@@ -168,7 +182,7 @@ static int pfe_platform_probe(struct platform_device *pdev)
 	pfe->ddr_phys_baseaddr = res.start;
 	pfe->ddr_size = resource_size(&res);
 
-	//pfe->ddr_baseaddr = ioremap(res.start, resource_size(&res));
+	/*pfe->ddr_baseaddr = ioremap(res.start, resource_size(&res)); */
 	pfe->ddr_baseaddr = phys_to_virt(res.start);
 	if (!pfe->ddr_baseaddr) {
 		printk(KERN_ERR "ioremap() ddr failed\n");
@@ -176,42 +190,39 @@ static int pfe_platform_probe(struct platform_device *pdev)
 		goto err_ddr;
 	}
 
-	/*printk("%s:%d : DDR Res : Phy addr:len = %x:%x Mapped addr : %x\n", __func__, __LINE__, 
-						pfe->ddr_phys_baseaddr, pfe->ddr_size, pfe->ddr_baseaddr);*/
 
-	pfe->scfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,"fsl,pfe-scfg");
+	pfe->scfg =
+		syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+		"fsl,pfe-scfg");
 	if (IS_ERR(pfe->scfg)) {
 		dev_err(&pdev->dev, "No syscfg phandle specified\n");
 		return PTR_ERR(pfe->scfg);
 	}
-	/*printk("%s scfg %p\n",__func__,pfe->scfg);*/
 
 
 #if 1
-	if (!(pfe->cbus_baseaddr = of_iomap(np, 1)))
-	{
+	if (!(pfe->cbus_baseaddr = of_iomap(np, 1))) {
 		rc = -ENOMEM;
 		printk(KERN_ERR "failed to get axi resource\n");
 		goto err_axi;
 	}
 
-	/*printk("%s:%d : AXI Mapped addr : %lx\n", __func__, __LINE__, pfe->cbus_baseaddr);
-	printk("%s:%d : AXI Mapped addr : phys %lx\n", __func__, __LINE__, virt_to_phys(pfe->cbus_baseaddr));*/
 #else
 
-	if (of_address_to_resource(np, 1, &res))
-	{
+	if (of_address_to_resource(np, 1, &res)) {
 		rc = -ENOMEM;
 		printk(KERN_ERR "failed to get AXI resource\n");
 		goto err_iram;
 	}
 	pfe->cbus_baseaddr = ioremap(res.start, resource_size(&res));
 	if (!pfe->cbus_baseaddr) {
-		printk(KERN_INFO "ioremap() AXI failed %lx %x\n", res.start, resource_size(&res));
+		printk(KERN_INFO "ioremap() AXI failed %lx %x\n", res.start,
+		resource_size(&res));
 		rc = -ENOMEM;
 		goto err_iram;
 	}
-	printk("%s:%d : AXI Mapped addr : %x PHY addr = %x\n", __func__, __LINE__, pfe->cbus_baseaddr, res.start);
+	printk("%s:%d : AXI Mapped addr : %x PHY addr = %x\n", __func__,
+		__LINE__, pfe->cbus_baseaddr, res.start);
 #endif
 
 	pfe->hif_irq = platform_get_irq(pdev, 0);
@@ -220,7 +231,6 @@ static int pfe_platform_probe(struct platform_device *pdev)
 		rc = pfe->hif_irq;
 		goto err_hif_irq;
 	}
-	/*printk("hif_irq: %d \n", pfe->hif_irq);*/
 
 	/* Read interface count */
 	prop = of_get_property(np, "fsl,pfe-num-interfaces", &size);
@@ -231,15 +241,16 @@ static int pfe_platform_probe(struct platform_device *pdev)
 	}
 
 	interface_count = be32_to_cpup(prop);
-	/*printk(KERN_INFO "%s:%d Number of interfaces : %d\n", __func__, __LINE__, interface_count);*/
 	if (interface_count <= 0) {
-		printk(KERN_ERR "No ethernet interface count : %d\n", interface_count);
+		printk(KERN_ERR "No ethernet interface count : %d\n",
+			interface_count);
 		rc = -ENXIO;
 		goto err_prop;
 	}
 
 	for (ii = 0; ii < interface_count; ii++) {
-		pfe_get_gemac_if_proprties(np, ii, interface_count, &pfe_platform_data);
+		pfe_get_gemac_if_proprties(np, ii, interface_count,
+						&pfe_platform_data);
 	}
 
 
@@ -247,8 +258,8 @@ static int pfe_platform_probe(struct platform_device *pdev)
 
 	pfe->dev->platform_data = &pfe_platform_data;
 
-	//FIXME get the correct clock from dts 
-	pfe->ctrl.sys_clk = 250000;  // save sys_clk value as KHz
+	/*FIXME get the correct clock from dts */
+	pfe->ctrl.sys_clk = 250000;  /* save sys_clk value as KHz */
 
 	rc = pfe_probe(pfe);
 	if (rc < 0)
@@ -276,15 +287,15 @@ err_alloc:
 
 
 /**
- * pfe_platform_remove -
- *
- *
- */
+* pfe_platform_remove -
+*
+*
+*/
 static int pfe_platform_remove(struct platform_device *pdev)
 {
 	struct pfe *pfe = platform_get_drvdata(pdev);
 	int rc;
-	
+
 	printk(KERN_INFO "%s\n", __func__);
 
 	rc = pfe_remove(pfe);
diff --git a/drivers/staging/fsl_ppfe/pfe_mod.c b/drivers/staging/fsl_ppfe/pfe_mod.c
index 45ad41c..c70d2c8 100644
--- a/drivers/staging/fsl_ppfe/pfe_mod.c
+++ b/drivers/staging/fsl_ppfe/pfe_mod.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #include <linux/dma-mapping.h>
 #include "pfe_mod.h"
@@ -23,33 +23,42 @@
 struct pfe *pfe;
 
 /**
- * pfe_probe - 
- *
- *
- */
+* pfe_probe -
+*
+*
+*/
 int pfe_probe(struct pfe *pfe)
 {
 	int rc;
 
 
 	if (DDR_MAX_SIZE > pfe->ddr_size) {
-		printk(KERN_ERR "%s: required DDR memory (%x) above platform ddr memory (%x)\n", __func__, DDR_MAX_SIZE, pfe->ddr_size);
+		printk(KERN_ERR
+			"%s: required DDR memory (%x) above platform ddr memory (%x)\n",
+			__func__, DDR_MAX_SIZE, pfe->ddr_size);
 		rc = -ENOMEM;
 		goto err_hw;
 	}
 
-	if (((int) (pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR) & (8*SZ_1M - 1)) != 0) {
-			printk(KERN_ERR "%s: BMU2 base address (0x%x) must be aligned on 8MB boundary\n", __func__, (int) pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR);
+	if (((int) (pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR) &
+			(8*SZ_1M - 1)) != 0) {
+			printk(KERN_ERR
+				"%s: BMU2 base address (0x%x) must bealigned on 8MB boundary\n",
+				 __func__, (int) pfe->ddr_phys_baseaddr +
+				BMU2_DDR_BASEADDR);
 			rc = -ENOMEM;
 			goto err_hw;
 	}
 
 
-	printk(KERN_INFO "cbus_baseaddr: %lx, ddr_baseaddr: %lx, ddr_phys_baseaddr: %lx, ddr_size: %x\n",
-			(unsigned long)pfe->cbus_baseaddr, (unsigned long)pfe->ddr_baseaddr,
+	printk(KERN_INFO
+		"cbus_baseaddr: %lx, ddr_baseaddr: %lx, ddr_phys_baseaddr: %lx, ddr_size: %x\n",
+			(unsigned long)pfe->cbus_baseaddr,
+			(unsigned long)pfe->ddr_baseaddr,
 			pfe->ddr_phys_baseaddr, pfe->ddr_size);
 
-	pfe_lib_init(pfe->cbus_baseaddr, pfe->ddr_baseaddr, pfe->ddr_phys_baseaddr, pfe->ddr_size);
+	pfe_lib_init(pfe->cbus_baseaddr, pfe->ddr_baseaddr,
+			pfe->ddr_phys_baseaddr, pfe->ddr_size);
 
 	rc = pfe_hw_init(pfe, 0);
 	if (rc < 0)
@@ -76,7 +85,7 @@ int pfe_probe(struct pfe *pfe)
 		goto err_eth;
 
 	rc = pfe_sysfs_init(pfe);
-	if(rc < 0)
+	if (rc < 0)
 		goto err_sysfs;
 
 	rc = pfe_debugfs_init(pfe);
@@ -112,10 +121,10 @@ err_hw:
 
 
 /**
- * pfe_remove - 
- *
- *
- */
+* pfe_remove -
+*
+*
+*/
 int pfe_remove(struct pfe *pfe)
 {
 	printk(KERN_INFO "%s\n", __func__);
diff --git a/drivers/staging/fsl_ppfe/pfe_mod.h b/drivers/staging/fsl_ppfe/pfe_mod.h
index df93cc7..d4c00d2 100644
--- a/drivers/staging/fsl_ppfe/pfe_mod.h
+++ b/drivers/staging/fsl_ppfe/pfe_mod.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_MOD_H_
 #define _PFE_MOD_H_
@@ -52,8 +52,8 @@ struct pfe {
 	void *apb_baseaddr;
 	unsigned long iram_phys_baseaddr;
 	void *iram_baseaddr;
-        unsigned long ipsec_phys_baseaddr;
-        void *ipsec_baseaddr;
+	unsigned long ipsec_phys_baseaddr;
+	void *ipsec_baseaddr;
 	int hif_irq;
 	int hif_client_irq;
 	struct device *dev;
@@ -69,7 +69,7 @@ struct pfe {
 	struct pfe_cpumon cpumon;
 	struct pfe_memmon memmon;
 	int wake;
-	struct clk * hfe_clock;
+	struct clk *hfe_clock;
 };
 
 extern struct pfe *pfe;
@@ -91,7 +91,8 @@ int pfe_remove(struct pfe *pfe);
 #define ROUTE_TABLE_HASH_BITS	15	/**< 32K entries */
 #define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS) * CLASS_ROUTE_SIZE)
 #define BMU2_DDR_BASEADDR	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
-#define BMU2_BUF_COUNT		(4096 - 256)			/**< This is to get a total DDR size of 12MiB */
+#define BMU2_BUF_COUNT		(4096 - 256)
+/**< This is to get a total DDR size of 12MiB */
 #define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
 #define UTIL_CODE_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
 #define UTIL_CODE_SIZE		(128 * SZ_1K)
@@ -102,8 +103,10 @@ int pfe_remove(struct pfe *pfe);
 #define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
 #define TMU_DDR_DATA_SIZE	(32 * SZ_1K)
 #define TMU_LLM_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
-#define TMU_LLM_QUEUE_LEN	(8 * 512)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
-#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+#define TMU_LLM_QUEUE_LEN	(8 * 512)
+/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)
+/**< (4 TMU's x 16 queues x queue_len) */
 
 #define DDR_MAX_SIZE		(TMU_LLM_BASEADDR + TMU_LLM_SIZE)
 
@@ -128,8 +131,11 @@ int pfe_remove(struct pfe *pfe);
 #define BMU2_BUF_COUNT		16
 #define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
 #define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
-#define TMU_LLM_QUEUE_LEN	(16 * 8)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
-#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+#define TMU_LLM_QUEUE_LEN	(16 * 8)
+/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)
+/**< (4 TMU's x 16 queues x queue_len) */
+
 #define HIF_DESC_BASEADDR	(TMU_LLM_BASEADDR + TMU_LLM_SIZE)
 #define HIF_RX_DESC_SIZE	(16*HIF_RX_DESC_NT)
 #define HIF_TX_DESC_SIZE	(16*HIF_TX_DESC_NT)
@@ -143,8 +149,8 @@ int pfe_remove(struct pfe *pfe);
 
 #define DDR_MAX_SIZE		(ROUTE_BASEADDR + ROUTE_SIZE)
 
-#define PFE_HOST_TO_PCI(addr)	(((u32)addr)- ((u32)DDR_BASE_ADDR))
-#define PFE_PCI_TO_HOST(addr)	(((u32)addr)+ ((u32)DDR_BASE_ADDR))
+#define PFE_HOST_TO_PCI(addr)	(((u32)addr) - ((u32)DDR_BASE_ADDR))
+#define PFE_PCI_TO_HOST(addr)	(((u32)addr) + ((u32)DDR_BASE_ADDR))
 #endif
 
 /* IRAM Mapping */
@@ -155,7 +161,7 @@ int pfe_remove(struct pfe *pfe);
 #define BMU1_LMEM_BASEADDR	0
 #define BMU1_BUF_COUNT		256
 #define BMU1_LMEM_SIZE		(LMEM_BUF_SIZE * BMU1_BUF_COUNT)
-#define IPSEC_LMEM_BASEADDR	(BMU1_LMEM_BASEADDR + BMU1_LMEM_SIZE)	
+#define IPSEC_LMEM_BASEADDR	(BMU1_LMEM_BASEADDR + BMU1_LMEM_SIZE)
 #define IPSEC_LMEM_SIZE		(30 * 1024)
 
 
diff --git a/drivers/staging/fsl_ppfe/pfe_perfmon.c b/drivers/staging/fsl_ppfe/pfe_perfmon.c
index 133ebf9..eb5d38b 100644
--- a/drivers/staging/fsl_ppfe/pfe_perfmon.c
+++ b/drivers/staging/fsl_ppfe/pfe_perfmon.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* PFE performance monitoring functions */
 
@@ -30,7 +30,8 @@ u32 TMU_DMEM_SH2(cpu_ticks[2]);
 u32 UTIL_DMEM_SH2(cpu_ticks[2]);
 #endif
 
-#define compute_active_pct(total_ticks, active_ticks) ((active_ticks * 100 + (total_ticks >> 1)) / total_ticks)
+#define compute_active_pct(total_ticks, active_ticks) ((active_ticks * 100 \
+					+ (total_ticks >> 1)) / total_ticks)
 
 static void cpumon_timer_handler(void)
 {
@@ -41,11 +42,10 @@ static void cpumon_timer_handler(void)
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 	struct pfe_cpumon *cpumon = &pfe->cpumon;
 
-	// Process class PE's
+	/* Process class PE's */
 	total = active = 0;
 	dmem_addr = virt_to_class_dmem(&class_cpu_ticks[0]);
-	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++)
-	{
+	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++) {
 		cpumon->cpu_usage_pct[id] = 0;
 		if (pe_sync_stop(ctrl, (1 << id)) < 0)
 			continue;
@@ -54,25 +54,30 @@ static void cpumon_timer_handler(void)
 		pe_dmem_write(id, 0, dmem_addr, 4);
 		pe_dmem_write(id, 0, dmem_addr + 4, 4);
 		pe_start(ctrl, (1 << id));
-		ticks[0] >>= 8;	// divide both values by 256, so multiply by 100 won't overflow
+		/*
+		* divide both values by 256,
+		* so multiply by 100 won't overflow
+		*/
+		ticks[0] >>= 8;
 		ticks[1] >>= 8;
 		total += ticks[0];
 		active += ticks[1];
 		if (ticks[0] != 0)
-			cpumon->cpu_usage_pct[id] = compute_active_pct(ticks[0], ticks[1]);
+			cpumon->cpu_usage_pct[id] =
+			compute_active_pct(ticks[0], ticks[1]);
 	}
 	if (total != 0)
 		cpumon->class_usage_pct = compute_active_pct(total, active);
 	else
 		cpumon->class_usage_pct = 0;
 
-	// Process TMU PE's
+	/* Process TMU PE's */
 	total = active = 0;
 	dmem_addr = virt_to_tmu_dmem(&tmu_cpu_ticks[0]);
-	for (id = TMU0_ID; id <= TMU_MAX_ID; id++)
-	{
+	for (id = TMU0_ID; id <= TMU_MAX_ID; id++) {
 #if defined(CONFIG_PLATFORM_LS1012A)
-		if(id == TMU2_ID) continue;
+		if (id == TMU2_ID)
+			continue;
 #endif
 		cpumon->cpu_usage_pct[id] = 0;
 		if (pe_sync_stop(ctrl, (1 << id)) < 0)
@@ -82,13 +87,18 @@ static void cpumon_timer_handler(void)
 		pe_dmem_write(id, 0, dmem_addr, 4);
 		pe_dmem_write(id, 0, dmem_addr + 4, 4);
 		pe_start(ctrl, (1 << id));
-		ticks[0] >>= 8;	// divide both values by 256, so multiply by 100 won't overflow
+		/*
+		* divide both values by 256,
+		* so multiply by 100 won't overflow
+		*/
+		ticks[0] >>= 8;
 		ticks[1] >>= 8;
 		if (ticks[0] != 0)
-			cpumon->cpu_usage_pct[id] = compute_active_pct(ticks[0], ticks[1]);
+			cpumon->cpu_usage_pct[id] =
+			compute_active_pct(ticks[0], ticks[1]);
 	}
 #if !defined(CONFIG_UTIL_DISABLED)
-	// Process Util PE
+	/* Process Util PE */
 	dmem_addr = virt_to_util_dmem(&util_cpu_ticks[0]);
 	cpumon->cpu_usage_pct[UTIL_ID] = 0;
 	if (pe_sync_stop(ctrl, (1 << UTIL_ID)) < 0)
@@ -98,10 +108,15 @@ static void cpumon_timer_handler(void)
 	pe_dmem_write(UTIL_ID, 0, dmem_addr, 4);
 	pe_dmem_write(UTIL_ID, 0, dmem_addr + 4, 4);
 	pe_start(ctrl, (1 << UTIL_ID));
-	ticks[0] >>= 8;	// divide both values by 256, so multiply by 100 won't overflow
+	/*
+	* divide both values by 256, so multiply by
+	* 100 won't overflow
+	*/
+	ticks[0] >>= 8;
 	ticks[1] >>= 8;
 	if (ticks[0] != 0)
-		cpumon->cpu_usage_pct[UTIL_ID] = compute_active_pct(ticks[0], ticks[1]);
+		cpumon->cpu_usage_pct[UTIL_ID] = compute_active_pct(ticks[0],
+						ticks[1]);
 #endif
 }
 
@@ -118,24 +133,25 @@ static void pfe_cpumon_exit(struct pfe *pfe)
 }
 
 
-/*********************************************************************************/
 
-// Memory monitor functions
+/* Memory monitor functions */
 
-void * pfe_kmalloc(size_t size, int flags)
+void *pfe_kmalloc(size_t size, int flags)
 {
 	struct pfe_memmon *memmon = &pfe->memmon;
 	void *ptr;
+
 	ptr = kmalloc(size, flags);
 	if (ptr)
 		memmon->kernel_memory_allocated += ksize(ptr);
 	return ptr;
 }
 
-void * pfe_kzalloc(size_t size, int flags)
+void *pfe_kzalloc(size_t size, int flags)
 {
 	struct pfe_memmon *memmon = &pfe->memmon;
 	void *ptr;
+
 	ptr = kzalloc(size, flags);
 	if (ptr)
 		memmon->kernel_memory_allocated += ksize(ptr);
@@ -145,6 +161,7 @@ void * pfe_kzalloc(size_t size, int flags)
 void pfe_kfree(void *ptr)
 {
 	struct pfe_memmon *memmon = &pfe->memmon;
+
 	memmon->kernel_memory_allocated -= ksize(ptr);
 	kfree(ptr);
 }
@@ -158,7 +175,6 @@ static void pfe_memmon_exit(struct pfe *pfe)
 {
 }
 
-/*********************************************************************************/
 
 
 int pfe_perfmon_init(struct pfe *pfe)
diff --git a/drivers/staging/fsl_ppfe/pfe_perfmon.h b/drivers/staging/fsl_ppfe/pfe_perfmon.h
index f6fb2c9..5c86614 100644
--- a/drivers/staging/fsl_ppfe/pfe_perfmon.h
+++ b/drivers/staging/fsl_ppfe/pfe_perfmon.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_PERFMON_H_
 #define _PFE_PERFMON_H_
@@ -31,8 +31,8 @@ struct pfe_memmon {
 	u32 kernel_memory_allocated;
 };
 
-void * pfe_kmalloc(size_t size, int flags);
-void * pfe_kzalloc(size_t size, int flags);
+void *pfe_kmalloc(size_t size, int flags);
+void *pfe_kzalloc(size_t size, int flags);
 void pfe_kfree(void *ptr);
 
 int pfe_perfmon_init(struct pfe *pfe);
diff --git a/drivers/staging/fsl_ppfe/pfe_platform.c b/drivers/staging/fsl_ppfe/pfe_platform.c
index 701d4d8..ffe61a7 100644
--- a/drivers/staging/fsl_ppfe/pfe_platform.c
+++ b/drivers/staging/fsl_ppfe/pfe_platform.c
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -25,10 +25,10 @@
 #include "pfe_mod.h"
 
 /**
- * pfe_platform_probe -
- *
- *
- */
+* pfe_platform_probe -
+*
+*
+*/
 static int pfe_platform_probe(struct platform_device *pdev)
 {
 	struct resource *r;
@@ -51,7 +51,7 @@ static int pfe_platform_probe(struct platform_device *pdev)
 		rc = -ENXIO;
 		goto err_ddr;
 	}
-	
+
 	pfe->ddr_phys_baseaddr = r->start;
 	pfe->ddr_size = resource_size(r);
 
@@ -61,7 +61,7 @@ static int pfe_platform_probe(struct platform_device *pdev)
 		rc = -ENOMEM;
 		goto err_ddr;
 	}
-	
+
 	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "axi");
 	if (!r) {
 		printk(KERN_INFO "platform_get_resource_byname(axi) failed\n");
@@ -92,7 +92,8 @@ static int pfe_platform_probe(struct platform_device *pdev)
 
 	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "iram");
 	if (!r) {
-		printk(KERN_INFO "platform_get_resource_byname(iram) failed\n");
+		printk(KERN_INFO
+			"platform_get_resource_byname(iram) failed\n");
 		rc = -ENXIO;
 		goto err_iram;
 	}
@@ -105,25 +106,25 @@ static int pfe_platform_probe(struct platform_device *pdev)
 		goto err_iram;
 	}
 
-        r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ipsec");
-        if (!r) {
-                printk(KERN_INFO "platform_get_resource_byname(ipsec) failed\n");
-                rc = -ENXIO;
-                goto err_ipsec;
-        }
-
-        pfe->ipsec_phys_baseaddr = r->start;
-	/* Just map only initial 1MB , as its enough to access espah engine
-	*/
-        //pfe->ipsec_baseaddr = ioremap(r->start, resource_size(r));
-        pfe->ipsec_baseaddr = ioremap(r->start, 1*1024*1024);
-        if (!pfe->ipsec_baseaddr) {
-                printk(KERN_INFO "ioremap() ipsec failed\n");
-                rc = -ENOMEM;
-                goto err_ipsec;
-        }
-
-        printk(KERN_INFO "ipsec: baseaddr :%x --- %x\n",  (u32)pfe->ipsec_phys_baseaddr,  (u32)pfe->ipsec_baseaddr);
+	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ipsec");
+	if (!r) {
+		printk(KERN_INFO "platform_get_resource_byname(ipsec) failed\n");
+		rc = -ENXIO;
+		goto err_ipsec;
+	}
+
+	pfe->ipsec_phys_baseaddr = r->start;
+	/* Just map only initial 1MB , as its enough to access espah engine */
+	/*pfe->ipsec_baseaddr = ioremap(r->start, resource_size(r)); */
+	pfe->ipsec_baseaddr = ioremap(r->start, 1*1024*1024);
+	if (!pfe->ipsec_baseaddr) {
+		printk(KERN_INFO "ioremap() ipsec failed\n");
+		rc = -ENOMEM;
+		goto err_ipsec;
+	}
+
+	printk(KERN_INFO "ipsec: baseaddr :%x --- %x\n",
+		(u32)pfe->ipsec_phys_baseaddr, (u32)pfe->ipsec_baseaddr);
 
 	pfe->hif_irq = platform_get_irq_byname(pdev, "hif");
 	if (pfe->hif_irq < 0) {
@@ -135,7 +136,8 @@ static int pfe_platform_probe(struct platform_device *pdev)
 #if 0
 	pfe->hif_client_irq = platform_get_irq_byname(pdev, "hif_client");
 	if (pfe->hif_client_irq < 0) {
-		printk(KERN_INFO "platform_get_irq_byname(hif_client) failed\n");
+		printk(KERN_INFO
+			"platform_get_irq_byname(hif_client) failed\n");
 		rc = pfe->hif_client_irq;
 		goto err_hif_irq;
 	}
@@ -145,7 +147,7 @@ static int pfe_platform_probe(struct platform_device *pdev)
 
 
 	/* Get the system clock */
-	clk_axi = clk_get(NULL,"axi");
+	clk_axi = clk_get(NULL, "axi");
 	if (IS_ERR(clk_axi)) {
 		printk(KERN_INFO "clk_get call failed\n");
 		rc = -ENXIO;
@@ -167,7 +169,8 @@ static int pfe_platform_probe(struct platform_device *pdev)
 	clk_enable(pfe->hfe_clock);
 
 	pfe->ctrl.clk_axi = clk_axi;
-	pfe->ctrl.sys_clk = clk_get_rate(clk_axi) / 1000;  // save sys_clk value as KHz
+	/* save sys_clk value as KHz */
+	pfe->ctrl.sys_clk = clk_get_rate(clk_axi) / 1000;
 
 	rc = pfe_probe(pfe);
 	if (rc < 0)
@@ -181,7 +184,7 @@ err_hfe_clock:
 	clk_put(clk_axi);
 err_clk:
 err_hif_irq:
-        iounmap(pfe->ipsec_baseaddr);
+	iounmap(pfe->ipsec_baseaddr);
 err_ipsec:
 	iounmap(pfe->iram_baseaddr);
 err_iram:
@@ -204,15 +207,15 @@ err_alloc:
 
 
 /**
- * pfe_platform_remove -
- *
- *
- */
+* pfe_platform_remove -
+*
+*
+*/
 static int pfe_platform_remove(struct platform_device *pdev)
 {
 	struct pfe *pfe = platform_get_drvdata(pdev);
 	int rc;
-	
+
 	printk(KERN_INFO "%s\n", __func__);
 
 	rc = pfe_remove(pfe);
@@ -247,14 +250,14 @@ static int pfe_platform_suspend(struct device *dev)
 
 	pfe->wake = 0;
 
-	for (i = 0; i < (NUM_GEMAC_SUPPORT - 1); i++ ) {
+	for (i = 0; i < (NUM_GEMAC_SUPPORT - 1); i++) {
 		netdev = pfe->eth.eth_priv[i]->dev;
 
 		netif_device_detach(netdev);
 
 		if (netif_running(netdev))
-			if(pfe_eth_suspend(netdev))
-				pfe->wake =1;
+			if (pfe_eth_suspend(netdev))
+				pfe->wake = 1;
 	}
 
 	/* Shutdown PFE only if we're not waking up the system */
@@ -302,7 +305,7 @@ static int pfe_platform_resume(struct device *dev)
 		pfe_ctrl_resume(&pfe->ctrl);
 	}
 
-	for(i = 0; i < (NUM_GEMAC_SUPPORT - 1); i++) {
+	for (i = 0; i < (NUM_GEMAC_SUPPORT - 1); i++) {
 		netdev = pfe->eth.eth_priv[i]->dev;
 
 		if (pfe->eth.eth_priv[i]->mii_bus)
diff --git a/drivers/staging/fsl_ppfe/pfe_sysfs.c b/drivers/staging/fsl_ppfe/pfe_sysfs.c
index a2fff43..20119ab 100644
--- a/drivers/staging/fsl_ppfe/pfe_sysfs.c
+++ b/drivers/staging/fsl_ppfe/pfe_sysfs.c
@@ -1,25 +1,26 @@
 /*
- *  (C) Copyright 2011
- *  Author : Freescale Semiconductor, Inc.
- *
- *  See file CREDITS for list of people who contributed to this
- *  project.
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License as
- *  published by the Free Software Foundation; either version 2 of
- *  the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *  MA 02111-1307 USA
- * */
+*  (C) Copyright 2011
+*  Author : Freescale Semiconductor, Inc.
+*
+*  See file CREDITS for list of people who contributed to this
+*  project.
+*
+*  This program is free software; you can redistribute it and/or
+*  modify it under the terms of the GNU General Public License as
+*  published by the Free Software Foundation; either version 2 of
+*  the License, or (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program; if not, write to the Free Software
+*  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+*  MA 02111-1307 USA
+*
+*/
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -55,15 +56,16 @@ static char exception_name[14][20] = {
 	"Interrupt",
 };
 
-static unsigned long class_do_clear = 0;
-static unsigned long tmu_do_clear = 0;
+static unsigned long class_do_clear;
+static unsigned long tmu_do_clear;
 #if !defined(CONFIG_UTIL_DISABLED)
-static unsigned long util_do_clear = 0;
+static unsigned long util_do_clear;
 #endif
 
 u32 qm_read_drop_stat(u32 tmu, u32 queue, u32 *total_drops, int do_reset);
 
-static ssize_t display_pe_status(char *buf, int id, u32 dmem_addr, unsigned long do_clear)
+static ssize_t display_pe_status(char *buf, int id, u32 dmem_addr, unsigned long
+					do_clear)
 {
 	ssize_t len = 0;
 	u32 val;
@@ -110,40 +112,41 @@ static ssize_t display_pe_status(char *buf, int id, u32 dmem_addr, unsigned long
 
 	debug_indicator = pe_dmem_read(id, dmem_addr, 4);
 	dmem_addr += 4;
-	if (!strncmp((char *)&debug_indicator, "DBUG", 4))
-	{
+	if (!strncmp((char *)&debug_indicator, "DBUG", 4)) {
 		int j, last = 0;
-		for (j = 0; j < 16; j++)
-		{
+
+		for (j = 0; j < 16; j++) {
 			debug[j] = pe_dmem_read(id, dmem_addr, 4);
-			if (debug[j])
-			{
+			if (debug[j]) {
 				if (do_clear)
 					pe_dmem_write(id, 0, dmem_addr, 4);
 				last = j + 1;
 			}
 			dmem_addr += 4;
 		}
-		for (j = 0; j < last; j++)
-		{
-			len += sprintf(buf + len, "%08x%s", cpu_to_be32(debug[j]),
-							(j & 0x7) == 0x7 || j == last - 1 ? "\n" : " ");
+		for (j = 0; j < last; j++) {
+			len += sprintf(buf + len, "%08x%s",
+			cpu_to_be32(debug[j]),
+			(j & 0x7) == 0x7 || j == last - 1 ? "\n" : " ");
 		}
 	}
 
-	if (!strncmp(statebuf, "DEAD", 4))
-	{
+	if (!strncmp(statebuf, "DEAD", 4)) {
 		u32 i, dump = PE_EXCEPTION_DUMP_ADDRESS;
 
 		len += sprintf(buf + len, "Exception details:\n");
 		for (i = 0; i < 20; i++) {
 			debug[i] = pe_dmem_read(id, dump, 4);
-			dump +=4;
+			dump += 4;
 			if (i == 2)
-				len += sprintf(buf + len, "%4s = %08x (=%s) ", register_name[i], cpu_to_be32(debug[i]), exception_name[min((u32) cpu_to_be32(debug[i]), (u32)13)]);
+				len += sprintf(buf + len, "%4s = %08x (=%s) ",
+				register_name[i], cpu_to_be32(debug[i]),
+				exception_name[min((u32)
+				cpu_to_be32(debug[i]), (u32)13)]);
 			else
-				len += sprintf(buf + len, "%4s = %08x%s", register_name[i], cpu_to_be32(debug[i]),
-							(i & 0x3) == 0x3 || i == 19 ? "\n" : " ");
+				len += sprintf(buf + len, "%4s = %08x%s",
+				register_name[i], cpu_to_be32(debug[i]),
+				(i & 0x3) == 0x3 || i == 19 ? "\n" : " ");
 		}
 	}
 
@@ -160,42 +163,52 @@ static ssize_t class_phy_stats(char *buf, int phy)
 		off1 = CLASS_PHY4_RX_PKTS - CLASS_PHY1_RX_PKTS;
 
 	len += sprintf(buf + len, "phy: %d\n", phy);
-	len += sprintf(buf + len, "  rx:   %10u, tx:   %10u, intf:  %10u, ipv4:    %10u, ipv6: %10u\n",
-			readl(CLASS_PHY1_RX_PKTS + off1), readl(CLASS_PHY1_TX_PKTS + off1),
-			readl(CLASS_PHY1_INTF_MATCH_PKTS + off1), readl(CLASS_PHY1_V4_PKTS + off1),
+	len += sprintf(buf + len,
+			"  rx:   %10u, tx:   %10u, intf:  %10u, ipv4:    %10u, ipv6: %10u\n",
+			readl(CLASS_PHY1_RX_PKTS + off1),
+			readl(CLASS_PHY1_TX_PKTS + off1),
+			readl(CLASS_PHY1_INTF_MATCH_PKTS + off1),
+			readl(CLASS_PHY1_V4_PKTS + off1),
 			readl(CLASS_PHY1_V6_PKTS + off1));
 
-	len += sprintf(buf + len, "  icmp: %10u, igmp: %10u, tcp:   %10u, udp:     %10u\n",
-			readl(CLASS_PHY1_ICMP_PKTS + off2), readl(CLASS_PHY1_IGMP_PKTS + off2),
-			readl(CLASS_PHY1_TCP_PKTS + off2), readl(CLASS_PHY1_UDP_PKTS + off2));
+	len += sprintf(buf + len,
+			"  icmp: %10u, igmp: %10u, tcp:   %10u, udp:     %10u\n",
+			readl(CLASS_PHY1_ICMP_PKTS + off2),
+			readl(CLASS_PHY1_IGMP_PKTS + off2),
+			readl(CLASS_PHY1_TCP_PKTS + off2),
+			readl(CLASS_PHY1_UDP_PKTS + off2));
 
 	len += sprintf(buf + len, "  err\n");
-	len += sprintf(buf + len, "  lp:   %10u, intf: %10u, l3:    %10u, chcksum: %10u, ttl:  %10u\n",
-			readl(CLASS_PHY1_LP_FAIL_PKTS + off1), readl(CLASS_PHY1_INTF_FAIL_PKTS + off1),
-			readl(CLASS_PHY1_L3_FAIL_PKTS + off1), readl(CLASS_PHY1_CHKSUM_ERR_PKTS + off1),
+	len += sprintf(buf + len,
+			"  lp:   %10u, intf: %10u, l3:    %10u, chcksum: %10u, ttl:  %10u\n",
+			readl(CLASS_PHY1_LP_FAIL_PKTS + off1),
+			readl(CLASS_PHY1_INTF_FAIL_PKTS + off1),
+			readl(CLASS_PHY1_L3_FAIL_PKTS + off1),
+			readl(CLASS_PHY1_CHKSUM_ERR_PKTS + off1),
 			readl(CLASS_PHY1_TTL_ERR_PKTS + off1));
 
 	return len;
 }
 
 /** qm_read_drop_stat
- * This function is used to read the drop statistics from the TMU
- * hw drop counter.  Since the hw counter is always cleared afer
- * reading, this function maintains the previous drop count, and
- * adds the new value to it.  That value can be retrieved by
- * passing a pointer to it with the total_drops arg.
- *
- * @param tmu		TMU number (0 - 3)
- * @param queue		queue number (0 - 15)
- * @param total_drops	pointer to location to store total drops (or NULL)
- * @param do_reset	if TRUE, clear total drops after updating
- *
- */
+* This function is used to read the drop statistics from the TMU
+* hw drop counter.  Since the hw counter is always cleared afer
+* reading, this function maintains the previous drop count, and
+* adds the new value to it.  That value can be retrieved by
+* passing a pointer to it with the total_drops arg.
+*
+* @param tmu		TMU number (0 - 3)
+* @param queue		queue number (0 - 15)
+* @param total_drops	pointer to location to store total drops (or NULL)
+* @param do_reset	if TRUE, clear total drops after updating
+*
+*/
 
 u32 qm_read_drop_stat(u32 tmu, u32 queue, u32 *total_drops, int do_reset)
 {
 	static u32 qtotal[TMU_MAX_ID + 1][NUM_QUEUES];
 	u32 val;
+
 	writel((tmu << 8) | queue, TMU_TEQ_CTRL);
 	writel((tmu << 8) | queue, TMU_LLM_CTRL);
 	val = readl(TMU_TEQ_DROP_STAT);
@@ -220,7 +233,8 @@ static ssize_t tmu_queue_stats(char *buf, int tmu, int queue)
 	writel((tmu << 8) | queue, TMU_TEQ_CTRL);
 	writel((tmu << 8) | queue, TMU_LLM_CTRL);
 
-	len += sprintf(buf + len, "(teq) drop: %10u, tx: %10u (llm) head: %08x, tail: %08x, drop: %10u\n",
+	len += sprintf(buf + len,
+			"(teq) drop: %10u, tx: %10u (llm) head: %08x, tail: %08x, drop: %10u\n",
 		drops, readl(TMU_TEQ_TRANS_STAT),
 		readl(TMU_LLM_QUE_HEADPTR), readl(TMU_LLM_QUE_TAILPTR),
 		readl(TMU_LLM_QUE_DROPCNT));
@@ -246,30 +260,34 @@ static ssize_t tmu_ctx(char *buf, int tmu)
 	int i;
 	u32 val, tmu_context_addr = TMU_CONTEXT_ADDR;
 
-	len += sprintf(buf+len, " TMU %d \n", TMU0_ID+tmu);
-	for (i = 1; i <= 160 ; i++, tmu_context_addr += 4)
-	{
-		val = pe_dmem_read(TMU0_ID+tmu, tmu_context_addr , 4);
+	len += sprintf(buf+len, " TMU %d\n", TMU0_ID+tmu);
+	for (i = 1; i <= 160 ; i++, tmu_context_addr += 4) {
+		val = pe_dmem_read(TMU0_ID+tmu, tmu_context_addr, 4);
 		if (i == 5)
-			len += sprintf(buf+len, "\nShapers: Each shaper structure is 8 bytes and there are 10 shapers\n");
+			len += sprintf(buf+len,
+				"\nShapers: Each shaper structure is 8 bytes and there are 10 shapers\n");
 
 		if (i == 25)
-			len += sprintf(buf+len, "\nScheduler: Each scheduler structure is 48 bytes and there are 8 schedulers\n");
+			len += sprintf(buf+len,
+				"\nScheduler: Each scheduler structure is 48 bytes and there are 8 schedulers\n");
 		if (i == 121)
-			len += sprintf(buf+len, "\nQueue: Each queue structure is 2 bytes and there are 16 queues\n");
+			len += sprintf(buf+len,
+				"\nQueue: Each queue structure is 2 bytes and there are 16 queues\n");
 
 		if (i == 129)
-			len += sprintf(buf+len, "\nqlenmasks array for  16 queues\n");
+			len += sprintf(buf+len,
+				"\nqlenmasks array for  16 queues\n");
 		if (i == 145)
-			len += sprintf(buf+len, "\nqresultmap array for  16 queues\n");
+			len += sprintf(buf+len,
+				"\nqresultmap array for  16 queues\n");
 		if (i%8 == 0)
-			len += sprintf(buf+len, "%08x \n",  cpu_to_be32(val));
+			len += sprintf(buf+len, "%08x\n",  cpu_to_be32(val));
 		else
 			len += sprintf(buf+len, "%08x ",  cpu_to_be32(val));
 	}
-	
+
 	len += sprintf(buf+len, "\n");
-		
+
 	return len;
 }
 
@@ -279,7 +297,8 @@ static ssize_t block_version(char *buf, void *addr)
 	u32 val;
 
 	val = readl(addr);
-	len += sprintf(buf + len, "revision: %x, version: %x, id: %x\n", (val >> 24) & 0xff, (val >> 16) & 0xff, val & 0xffff);
+	len += sprintf(buf + len, "revision: %x, version: %x, id: %x\n",
+		(val >> 24) & 0xff, (val >> 16) & 0xff, val & 0xffff);
 
 	return len;
 }
@@ -292,11 +311,16 @@ static ssize_t bmu(char *buf, int id, void *base)
 
 	len += block_version(buf + len, base + BMU_VERSION);
 
-	len += sprintf(buf + len, "  buf size:  %x\n", (1 << readl(base + BMU_BUF_SIZE)));
-	len += sprintf(buf + len, "  buf count: %x\n", readl(base + BMU_BUF_CNT));
-	len += sprintf(buf + len, "  buf rem:   %x\n", readl(base + BMU_REM_BUF_CNT));
-	len += sprintf(buf + len, "  buf curr:  %x\n", readl(base + BMU_CURR_BUF_CNT));
-	len += sprintf(buf + len, "  free err:  %x\n", readl(base + BMU_FREE_ERR_ADDR));
+	len += sprintf(buf + len, "  buf size:  %x\n", (1 << readl(base +
+			BMU_BUF_SIZE)));
+	len += sprintf(buf + len, "  buf count: %x\n", readl(base +
+			BMU_BUF_CNT));
+	len += sprintf(buf + len, "  buf rem:   %x\n", readl(base +
+			BMU_REM_BUF_CNT));
+	len += sprintf(buf + len, "  buf curr:  %x\n", readl(base +
+			BMU_CURR_BUF_CNT));
+	len += sprintf(buf + len, "  free err:  %x\n", readl(base +
+			BMU_FREE_ERR_ADDR));
 
 	return len;
 }
@@ -309,24 +333,32 @@ static ssize_t gpi(char *buf, int id, void *base)
 	len += sprintf(buf + len, "gpi%d:\n  ", id);
 	len += block_version(buf + len, base + GPI_VERSION);
 
-	len += sprintf(buf + len, "  tx under stick: %x\n", readl(base + GPI_FIFO_STATUS));
+	len += sprintf(buf + len, "  tx under stick: %x\n", readl(base +
+			GPI_FIFO_STATUS));
 	val = readl(base + GPI_FIFO_DEBUG);
-	len += sprintf(buf + len, "  tx pkts:        %x\n", (val >> 23) & 0x3f);
-	len += sprintf(buf + len, "  rx pkts:        %x\n", (val >> 18) & 0x3f);
-	len += sprintf(buf + len, "  tx bytes:       %x\n", (val >> 9) & 0x1ff);
-	len += sprintf(buf + len, "  rx bytes:       %x\n", (val >> 0) & 0x1ff);
-	len += sprintf(buf + len, "  overrun:        %x\n", readl(base + GPI_OVERRUN_DROPCNT));
+	len += sprintf(buf + len, "  tx pkts:        %x\n", (val >> 23) &
+			0x3f);
+	len += sprintf(buf + len, "  rx pkts:        %x\n", (val >> 18) &
+			0x3f);
+	len += sprintf(buf + len, "  tx bytes:       %x\n", (val >> 9) &
+			0x1ff);
+	len += sprintf(buf + len, "  rx bytes:       %x\n", (val >> 0) &
+			0x1ff);
+	len += sprintf(buf + len, "  overrun:        %x\n", readl(base +
+			GPI_OVERRUN_DROPCNT));
 
 	return len;
 }
 
-static ssize_t pfe_set_class(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pfe_set_class(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	class_do_clear = simple_strtoul(buf, NULL, 0);
 	return count;
 }
 
-static ssize_t pfe_show_class(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_class(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 	int id;
@@ -335,20 +367,24 @@ static ssize_t pfe_show_class(struct device *dev, struct device_attribute *attr,
 
 	len += block_version(buf + len, CLASS_VERSION);
 
-	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++)
-	{
+	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++) {
 		len += sprintf(buf + len, "%d: ", id - CLASS0_ID);
 
 		val = readl(CLASS_PE0_DEBUG + id * 4);
 		len += sprintf(buf + len, "pc=1%04x ", val & 0xffff);
 
-		len += display_pe_status(buf + len, id, PESTATUS_ADDR_CLASS, class_do_clear);
+		len += display_pe_status(buf + len, id, PESTATUS_ADDR_CLASS,
+						class_do_clear);
 	}
-	len += sprintf(buf + len, "aggregate load=%d%%\n\n", cpumon->class_usage_pct);
-
-	len += sprintf(buf + len, "pe status:   0x%x\n", readl(CLASS_PE_STATUS));
-	len += sprintf(buf + len, "max buf cnt: 0x%x   afull thres: 0x%x\n", readl(CLASS_MAX_BUF_CNT), readl(CLASS_AFULL_THRES));
-	len += sprintf(buf + len, "tsq max cnt: 0x%x   tsq fifo thres: 0x%x\n", readl(CLASS_TSQ_MAX_CNT), readl(CLASS_TSQ_FIFO_THRES));
+	len += sprintf(buf + len, "aggregate load=%d%%\n\n",
+			cpumon->class_usage_pct);
+
+	len += sprintf(buf + len, "pe status:   0x%x\n",
+			readl(CLASS_PE_STATUS));
+	len += sprintf(buf + len, "max buf cnt: 0x%x   afull thres: 0x%x\n",
+			readl(CLASS_MAX_BUF_CNT), readl(CLASS_AFULL_THRES));
+	len += sprintf(buf + len, "tsq max cnt: 0x%x   tsq fifo thres: 0x%x\n",
+			readl(CLASS_TSQ_MAX_CNT), readl(CLASS_TSQ_FIFO_THRES));
 	len += sprintf(buf + len, "state:       0x%x\n", readl(CLASS_STATE));
 
 	len += class_phy_stats(buf + len, 0);
@@ -359,13 +395,15 @@ static ssize_t pfe_show_class(struct device *dev, struct device_attribute *attr,
 	return len;
 }
 
-static ssize_t pfe_set_tmu(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pfe_set_tmu(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	tmu_do_clear = simple_strtoul(buf, NULL, 0);
 	return count;
 }
 
-static ssize_t pfe_show_tmu(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 	int id;
@@ -373,18 +411,20 @@ static ssize_t pfe_show_tmu(struct device *dev, struct device_attribute *attr, c
 
 	len += block_version(buf + len, TMU_VERSION);
 
-	for (id = TMU0_ID; id <= TMU_MAX_ID; id++)
-	{
+	for (id = TMU0_ID; id <= TMU_MAX_ID; id++) {
 #if defined(CONFIG_PLATFORM_LS1012A)
-		if(id == TMU2_ID) continue;
+		if (id == TMU2_ID)
+			continue;
 #endif
 		len += sprintf(buf + len, "%d: ", id - TMU0_ID);
 
-		len += display_pe_status(buf + len, id, PESTATUS_ADDR_TMU, tmu_do_clear);
+		len += display_pe_status(buf + len, id, PESTATUS_ADDR_TMU,
+						tmu_do_clear);
 	}
 
 	len += sprintf(buf + len, "pe status:    %x\n", readl(TMU_PE_STATUS));
-	len += sprintf(buf + len, "inq fifo cnt: %x\n", readl(TMU_PHY_INQ_FIFO_CNT));
+	len += sprintf(buf + len, "inq fifo cnt: %x\n",
+			readl(TMU_PHY_INQ_FIFO_CNT));
 	val = readl(TMU_INQ_STAT);
 	len += sprintf(buf + len, "inq wr ptr:     %x\n", val & 0x3ff);
 	len += sprintf(buf + len, "inq rd ptr:     %x\n", val >> 10);
@@ -394,7 +434,7 @@ static ssize_t pfe_show_tmu(struct device *dev, struct device_attribute *attr, c
 }
 
 
-static unsigned long drops_do_clear = 0;
+static unsigned long drops_do_clear;
 static u32 CLASS_DMEM_SH2(drop_counter)[CLASS_NUM_DROP_COUNTERS];
 #if !defined(CONFIG_UTIL_DISABLED)
 static u32 UTIL_DMEM_SH2(drop_counter)[UTIL_NUM_DROP_COUNTERS];
@@ -428,14 +468,16 @@ char *util_drop_description[UTIL_NUM_DROP_COUNTERS] = {
 };
 #endif
 
-static ssize_t pfe_set_drops(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pfe_set_drops(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	drops_do_clear = simple_strtoul(buf, NULL, 0);
 	return count;
 }
 
 static u32 tmu_drops[4][16];
-static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 	int id, dropnum;
@@ -446,13 +488,13 @@ static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
 
 	memset(class_drop_counter, 0, sizeof(class_drop_counter));
-	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++)
-	{
+	for (id = CLASS0_ID; id <= CLASS_MAX_ID; id++) {
 		if (drops_do_clear)
 			pe_sync_stop(ctrl, (1 << id));
-		for (dropnum = 0; dropnum < CLASS_NUM_DROP_COUNTERS; dropnum++)
-		{
-			dmem_addr = virt_to_class_dmem(&class_drop_counter[dropnum]);
+		for (dropnum = 0; dropnum < CLASS_NUM_DROP_COUNTERS;
+			dropnum++) {
+			dmem_addr =
+			virt_to_class_dmem(&class_drop_counter[dropnum]);
 			val = be32_to_cpu(pe_dmem_read(id, dmem_addr, 4));
 			class_drop_counter[dropnum] += val;
 			num_class_drops += val;
@@ -466,8 +508,7 @@ static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
 #if !defined(CONFIG_UTIL_DISABLED)
 	if (drops_do_clear)
 		pe_sync_stop(ctrl, (1 << UTIL_ID));
-	for (dropnum = 0; dropnum < UTIL_NUM_DROP_COUNTERS; dropnum++)
-	{
+	for (dropnum = 0; dropnum < UTIL_NUM_DROP_COUNTERS; dropnum++) {
 		dmem_addr = virt_to_util_dmem(&util_drop_counter[dropnum]);
 		val = be32_to_cpu(pe_dmem_read(UTIL_ID, dmem_addr, 4));
 		util_drop_counter[dropnum] = val;
@@ -478,11 +519,10 @@ static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
 	if (drops_do_clear)
 		pe_start(ctrl, (1 << UTIL_ID));
 #endif
-	for (tmu = 0; tmu < 4; tmu++)
-	{
-		for (queue = 0; queue < 16; queue++)
-		{
-			qm_read_drop_stat(tmu, queue, &tmu_drops[tmu][queue], drops_do_clear);
+	for (tmu = 0; tmu < 4; tmu++) {
+		for (queue = 0; queue < 16; queue++) {
+			qm_read_drop_stat(tmu, queue, &tmu_drops[tmu][queue],
+						drops_do_clear);
 			num_tmu_drops += tmu_drops[tmu][queue];
 		}
 	}
@@ -490,38 +530,38 @@ static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
 	if (num_class_drops == 0 && num_util_drops == 0 && num_tmu_drops == 0)
 		len += sprintf(buf + len, "No PE drops\n\n");
 
-	if (num_class_drops > 0)
-	{
+	if (num_class_drops > 0) {
 		len += sprintf(buf + len, "Class PE drops --\n");
-		for (dropnum = 0; dropnum < CLASS_NUM_DROP_COUNTERS; dropnum++)
-		{
+		for (dropnum = 0; dropnum < CLASS_NUM_DROP_COUNTERS;
+			dropnum++) {
 			if (class_drop_counter[dropnum] > 0)
-				len += sprintf(buf + len, "  %s: %d\n", class_drop_description[dropnum], class_drop_counter[dropnum]);
+				len += sprintf(buf + len, "  %s: %d\n",
+					class_drop_description[dropnum],
+					class_drop_counter[dropnum]);
 		}
 		len += sprintf(buf + len, "\n");
 	}
 
 #if !defined(CONFIG_UTIL_DISABLED)
-	if (num_util_drops > 0)
-	{
+	if (num_util_drops > 0) {
 		len += sprintf(buf + len, "Util PE drops --\n");
-		for (dropnum = 0; dropnum < UTIL_NUM_DROP_COUNTERS; dropnum++)
-		{
+		for (dropnum = 0; dropnum < UTIL_NUM_DROP_COUNTERS; dropnum++) {
 			if (util_drop_counter[dropnum] > 0)
-				len += sprintf(buf + len, "  %s: %d\n", util_drop_description[dropnum], util_drop_counter[dropnum]);
+				len += sprintf(buf + len, "  %s: %d\n",
+					util_drop_description[dropnum],
+					util_drop_counter[dropnum]);
 		}
 		len += sprintf(buf + len, "\n");
 	}
 #endif
-	if (num_tmu_drops > 0)
-	{
+	if (num_tmu_drops > 0) {
 		len += sprintf(buf + len, "TMU drops --\n");
-		for (tmu = 0; tmu < 4; tmu++)
-		{
-			for (queue = 0; queue < 16; queue++)
-			{
+		for (tmu = 0; tmu < 4; tmu++) {
+			for (queue = 0; queue < 16; queue++) {
 				if (tmu_drops[tmu][queue] > 0)
-					len += sprintf(buf + len, "  TMU%d-Q%d: %d\n", tmu, queue, tmu_drops[tmu][queue]);
+					len += sprintf(buf + len,
+						"  TMU%d-Q%d: %d\n"
+					, tmu, queue, tmu_drops[tmu][queue]);
 			}
 		}
 		len += sprintf(buf + len, "\n");
@@ -530,53 +570,63 @@ static ssize_t pfe_show_drops(struct device *dev, struct device_attribute *attr,
 	return len;
 }
 
-static ssize_t pfe_show_tmu0_queues(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu0_queues(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
 	return tmu_queues(buf, 0);
 }
 
-static ssize_t pfe_show_tmu1_queues(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu1_queues(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
 	return tmu_queues(buf, 1);
 }
 
-static ssize_t pfe_show_tmu2_queues(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu2_queues(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
 	return tmu_queues(buf, 2);
 }
 
-static ssize_t pfe_show_tmu3_queues(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu3_queues(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
 	return tmu_queues(buf, 3);
 }
 
-static ssize_t pfe_show_tmu0_ctx(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu0_ctx(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
-        return tmu_ctx(buf, 0);
+	return tmu_ctx(buf, 0);
 }
-static ssize_t pfe_show_tmu1_ctx(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu1_ctx(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
-        return tmu_ctx(buf, 1);
+	return tmu_ctx(buf, 1);
 }
-static ssize_t pfe_show_tmu2_ctx(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu2_ctx(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
-        return tmu_ctx(buf, 2);
+	return tmu_ctx(buf, 2);
 }
 
-static ssize_t pfe_show_tmu3_ctx(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_tmu3_ctx(struct device *dev, struct device_attribute
+					*attr, char *buf)
 {
-        return tmu_ctx(buf, 3);
+	return tmu_ctx(buf, 3);
 }
 
 
 #if !defined(CONFIG_UTIL_DISABLED)
-static ssize_t pfe_set_util(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pfe_set_util(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
 {
 	util_do_clear = simple_strtoul(buf, NULL, 0);
 	return count;
 }
 
-static ssize_t pfe_show_util(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_util(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 	struct pfe_ctrl *ctrl = &pfe->ctrl;
@@ -585,18 +635,22 @@ static ssize_t pfe_show_util(struct device *dev, struct device_attribute *attr,
 	len += block_version(buf + len, UTIL_VERSION);
 
 	pe_sync_stop(ctrl, (1 << UTIL_ID));
-	len += display_pe_status(buf + len, UTIL_ID, PESTATUS_ADDR_UTIL, util_do_clear);
+	len += display_pe_status(buf + len, UTIL_ID, PESTATUS_ADDR_UTIL,
+					util_do_clear);
 	pe_start(ctrl, (1 << UTIL_ID));
 
 	len += sprintf(buf + len, "pe status:   %x\n", readl(UTIL_PE_STATUS));
-	len += sprintf(buf + len, "max buf cnt: %x\n", readl(UTIL_MAX_BUF_CNT));
-	len += sprintf(buf + len, "tsq max cnt: %x\n", readl(UTIL_TSQ_MAX_CNT));
+	len += sprintf(buf + len, "max buf cnt: %x\n",
+			readl(UTIL_MAX_BUF_CNT));
+	len += sprintf(buf + len, "tsq max cnt: %x\n",
+			readl(UTIL_TSQ_MAX_CNT));
 
 	return len;
 }
 #endif
 
-static ssize_t pfe_show_bmu(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_bmu(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 
@@ -606,37 +660,51 @@ static ssize_t pfe_show_bmu(struct device *dev, struct device_attribute *attr, c
 	return len;
 }
 
-static ssize_t pfe_show_hif(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_hif(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 
 	len += sprintf(buf + len, "hif:\n  ");
 	len += block_version(buf + len, HIF_VERSION);
 
-	len += sprintf(buf + len, "  tx curr bd:    %x\n", readl(HIF_TX_CURR_BD_ADDR));
-	len += sprintf(buf + len, "  tx status:     %x\n", readl(HIF_TX_STATUS));
-	len += sprintf(buf + len, "  tx dma status: %x\n", readl(HIF_TX_DMA_STATUS));
+	len += sprintf(buf + len, "  tx curr bd:    %x\n",
+			readl(HIF_TX_CURR_BD_ADDR));
+	len += sprintf(buf + len, "  tx status:     %x\n",
+			readl(HIF_TX_STATUS));
+	len += sprintf(buf + len, "  tx dma status: %x\n",
+			readl(HIF_TX_DMA_STATUS));
 
-	len += sprintf(buf + len, "  rx curr bd:    %x\n", readl(HIF_RX_CURR_BD_ADDR));
-	len += sprintf(buf + len, "  rx status:     %x\n", readl(HIF_RX_STATUS));
-	len += sprintf(buf + len, "  rx dma status: %x\n", readl(HIF_RX_DMA_STATUS));
+	len += sprintf(buf + len, "  rx curr bd:    %x\n",
+			readl(HIF_RX_CURR_BD_ADDR));
+	len += sprintf(buf + len, "  rx status:     %x\n",
+			readl(HIF_RX_STATUS));
+	len += sprintf(buf + len, "  rx dma status: %x\n",
+			readl(HIF_RX_DMA_STATUS));
 
 	len += sprintf(buf + len, "hif nocopy:\n  ");
 	len += block_version(buf + len, HIF_NOCPY_VERSION);
 
-	len += sprintf(buf + len, "  tx curr bd:    %x\n", readl(HIF_NOCPY_TX_CURR_BD_ADDR));
-	len += sprintf(buf + len, "  tx status:     %x\n", readl(HIF_NOCPY_TX_STATUS));
-	len += sprintf(buf + len, "  tx dma status: %x\n", readl(HIF_NOCPY_TX_DMA_STATUS));
+	len += sprintf(buf + len, "  tx curr bd:    %x\n",
+			readl(HIF_NOCPY_TX_CURR_BD_ADDR));
+	len += sprintf(buf + len, "  tx status:     %x\n",
+			readl(HIF_NOCPY_TX_STATUS));
+	len += sprintf(buf + len, "  tx dma status: %x\n",
+			readl(HIF_NOCPY_TX_DMA_STATUS));
 
-	len += sprintf(buf + len, "  rx curr bd:    %x\n", readl(HIF_NOCPY_RX_CURR_BD_ADDR));
-	len += sprintf(buf + len, "  rx status:     %x\n", readl(HIF_NOCPY_RX_STATUS));
-	len += sprintf(buf + len, "  rx dma status: %x\n", readl(HIF_NOCPY_RX_DMA_STATUS));
+	len += sprintf(buf + len, "  rx curr bd:    %x\n",
+			readl(HIF_NOCPY_RX_CURR_BD_ADDR));
+	len += sprintf(buf + len, "  rx status:     %x\n",
+			readl(HIF_NOCPY_RX_STATUS));
+	len += sprintf(buf + len, "  rx dma status: %x\n",
+			readl(HIF_NOCPY_RX_DMA_STATUS));
 
 	return len;
 }
 
 
-static ssize_t pfe_show_gpi(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_gpi(struct device *dev, struct device_attribute *attr,
+				char *buf)
 {
 	ssize_t len = 0;
 
@@ -650,34 +718,47 @@ static ssize_t pfe_show_gpi(struct device *dev, struct device_attribute *attr, c
 	return len;
 }
 
-static ssize_t pfe_show_pfemem(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_pfemem(struct device *dev, struct device_attribute
+				*attr, char *buf)
 {
 	ssize_t len = 0;
 	struct pfe_memmon *memmon = &pfe->memmon;
 
-	len += sprintf(buf + len, "Kernel Memory: %d Bytes (%d KB)\n", memmon->kernel_memory_allocated, (memmon->kernel_memory_allocated + 1023) / 1024);
+	len += sprintf(buf + len, "Kernel Memory: %d Bytes (%d KB)\n",
+		memmon->kernel_memory_allocated,
+		(memmon->kernel_memory_allocated + 1023) / 1024);
 
 	return len;
 }
 
 #ifdef HIF_NAPI_STATS
-static ssize_t pfe_show_hif_napi_stats(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t pfe_show_hif_napi_stats(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct pfe *pfe = platform_get_drvdata(pdev);
 	ssize_t len = 0;
 
-	len += sprintf(buf + len, "sched:  %u\n", pfe->hif.napi_counters[NAPI_SCHED_COUNT]);
-	len += sprintf(buf + len, "poll:   %u\n", pfe->hif.napi_counters[NAPI_POLL_COUNT]);
-	len += sprintf(buf + len, "packet: %u\n", pfe->hif.napi_counters[NAPI_PACKET_COUNT]);
-	len += sprintf(buf + len, "budget: %u\n", pfe->hif.napi_counters[NAPI_FULL_BUDGET_COUNT]);
-	len += sprintf(buf + len, "desc:   %u\n", pfe->hif.napi_counters[NAPI_DESC_COUNT]);
-	len += sprintf(buf + len, "full:   %u\n", pfe->hif.napi_counters[NAPI_CLIENT_FULL_COUNT]);
+	len += sprintf(buf + len, "sched:  %u\n",
+			pfe->hif.napi_counters[NAPI_SCHED_COUNT]);
+	len += sprintf(buf + len, "poll:   %u\n",
+			pfe->hif.napi_counters[NAPI_POLL_COUNT]);
+	len += sprintf(buf + len, "packet: %u\n",
+			pfe->hif.napi_counters[NAPI_PACKET_COUNT]);
+	len += sprintf(buf + len, "budget: %u\n",
+			pfe->hif.napi_counters[NAPI_FULL_BUDGET_COUNT]);
+	len += sprintf(buf + len, "desc:   %u\n",
+			pfe->hif.napi_counters[NAPI_DESC_COUNT]);
+	len += sprintf(buf + len, "full:   %u\n",
+			pfe->hif.napi_counters[NAPI_CLIENT_FULL_COUNT]);
 
 	return len;
 }
 
-static ssize_t pfe_set_hif_napi_stats(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pfe_set_hif_napi_stats(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct pfe *pfe = platform_get_drvdata(pdev);
@@ -687,7 +768,8 @@ static ssize_t pfe_set_hif_napi_stats(struct device *dev, struct device_attribut
 	return count;
 }
 
-static DEVICE_ATTR(hif_napi_stats, 0644, pfe_show_hif_napi_stats, pfe_set_hif_napi_stats);
+static DEVICE_ATTR(hif_napi_stats, 0644, pfe_show_hif_napi_stats,
+			pfe_set_hif_napi_stats);
 #endif
 
 
diff --git a/drivers/staging/fsl_ppfe/pfe_sysfs.h b/drivers/staging/fsl_ppfe/pfe_sysfs.h
index d0d53de..c2f4960 100644
--- a/drivers/staging/fsl_ppfe/pfe_sysfs.h
+++ b/drivers/staging/fsl_ppfe/pfe_sysfs.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PFE_SYSFS_H_
 #define _PFE_SYSFS_H_
@@ -26,8 +26,8 @@
 #define	PESTATUS_ADDR_TMU	0x80
 #define	PESTATUS_ADDR_UTIL	0x0
 
-#define TMU_CONTEXT_ADDR 	0x3c8
-#define IPSEC_CNTRS_ADDR 	0x840
+#define TMU_CONTEXT_ADDR	0x3c8
+#define IPSEC_CNTRS_ADDR	0x840
 
 int pfe_sysfs_init(struct pfe *pfe);
 void pfe_sysfs_exit(struct pfe *pfe);
diff --git a/drivers/staging/fsl_ppfe/platform.h b/drivers/staging/fsl_ppfe/platform.h
index 137ab73..bfd3578 100644
--- a/drivers/staging/fsl_ppfe/platform.h
+++ b/drivers/staging/fsl_ppfe/platform.h
@@ -1,21 +1,21 @@
 /*
- *
- *  Copyright (C) 2007 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+*
+*  Copyright (C) 2007 Freescale Semiconductor, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 #ifndef _PLATFORM_H_
 #define _PLATFORM_H_
diff --git a/include/linux/phy.h b/include/linux/phy.h
index bfac2c8..c2618dc 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -121,6 +121,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "moca";
 	case PHY_INTERFACE_MODE_QSGMII:
 		return "qsgmii";
+	case PHY_INTERFACE_MODE_SGMII_2500:
+		return "sgmii-2500";
 	default:
 		return "unknown";
 	}
-- 
1.7.9.5

